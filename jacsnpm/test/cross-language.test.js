/**
 * Cross-language verification tests for JACS Node.js bindings.
 *
 * These tests verify that documents signed by the Rust core can be verified
 * by the Node.js bindings using verifyStandalone(), and that Node.js can
 * countersign documents originally signed by Rust.
 *
 * Fixture directory: jacs/tests/fixtures/cross-language/
 * Generated by Rust integration tests (see jacs/tests/cross_language/mod.rs).
 *
 * IMPORTANT: verifyStandalone requires a local key cache:
 *   - keyResolution: 'local'
 *   - dataDirectory/keyDirectory: directory containing public_keys/{hash}.pem + .enc_type
 *   - This suite builds that cache in a temp dir from committed fixture files.
 *
 * Algorithms tested: Ed25519, pq2025 (more may be added by Rust fixture generator)
 */

const { expect } = require('chai');
const path = require('path');
const fs = require('fs');

let simple;
try {
  simple = require('../simple.js');
} catch (e) {
  simple = null;
}

let clientModule;
try {
  clientModule = require('../client.js');
} catch (e) {
  clientModule = null;
}

// Fixtures are at jacs/tests/fixtures/cross-language/ relative to the workspace root.
const WORKSPACE_ROOT = path.resolve(__dirname, '../..');
const FIXTURES_DIR = path.join(WORKSPACE_ROOT, 'jacs', 'tests', 'fixtures', 'cross-language');
const UPDATE_FIXTURES = /^(1|true|yes)$/i.test(process.env.UPDATE_CROSS_LANG_FIXTURES || '');
let STANDALONE_CACHE_DIR = null;

// Relative path from CWD to standalone key cache dir (required by standalone verifier).
function fixturesRelPath() {
  if (!STANDALONE_CACHE_DIR) {
    throw new Error('Standalone key cache directory is not initialized');
  }
  const rel = path.relative(process.cwd(), STANDALONE_CACHE_DIR);
  return rel || '.';
}

// Options for verifyStandalone that point to the fixtures directory
function standaloneOpts() {
  const rel = fixturesRelPath();
  return { keyResolution: 'local', dataDirectory: rel, keyDirectory: rel };
}

// Expected fixture algorithms and their file prefixes
const ALGORITHMS = [
  { prefix: 'ed25519', name: 'Ed25519', nodeAlgo: 'ring-Ed25519' },
  { prefix: 'pq2025', name: 'pq2025', nodeAlgo: 'pq2025' },
];
const PYTHON_FIXTURES = [
  { prefix: 'python_ed25519', name: 'Python Ed25519' },
  { prefix: 'python_pq2025', name: 'Python pq2025' },
];

function fixtureExists(prefix) {
  return (
    fs.existsSync(path.join(FIXTURES_DIR, `${prefix}_signed.json`)) &&
    fs.existsSync(path.join(FIXTURES_DIR, `${prefix}_metadata.json`)) &&
    fs.existsSync(path.join(FIXTURES_DIR, `${prefix}_public_key.pem`))
  );
}

function readFixture(prefix) {
  const signedPath = path.join(FIXTURES_DIR, `${prefix}_signed.json`);
  const metadataPath = path.join(FIXTURES_DIR, `${prefix}_metadata.json`);
  return {
    signed: fs.readFileSync(signedPath, 'utf8'),
    metadata: JSON.parse(fs.readFileSync(metadataPath, 'utf8')),
  };
}

function writeFixtureIfEnabled(outputPath, content) {
  if (!UPDATE_FIXTURES) {
    return;
  }
  try {
    fs.writeFileSync(outputPath, content);
  } catch (_) {
    // Fixture directory may not be writable
  }
}

function allFixturePrefixes() {
  return [...ALGORITHMS.map((a) => a.prefix), ...PYTHON_FIXTURES.map((p) => p.prefix)];
}

function buildStandaloneKeyCache() {
  const varDir = path.join(WORKSPACE_ROOT, 'jacsnpm', 'var');
  fs.mkdirSync(varDir, { recursive: true });
  const cacheDir = path.join(varDir, `cross-lang-key-cache-${process.pid}-${Date.now()}`);
  fs.mkdirSync(cacheDir, { recursive: true });
  const publicKeysDir = path.join(cacheDir, 'public_keys');
  fs.mkdirSync(publicKeysDir, { recursive: true });

  for (const prefix of allFixturePrefixes()) {
    if (!fixtureExists(prefix)) {
      continue;
    }
    const { metadata } = readFixture(prefix);
    const rawKeyPath = path.join(FIXTURES_DIR, `${prefix}_public_key.pem`);
    const keyHash = metadata.public_key_hash;
    const signingAlgorithm = metadata.signing_algorithm;
    if (!keyHash || !signingAlgorithm || !fs.existsSync(rawKeyPath)) {
      continue;
    }

    const keyBytes = fs.readFileSync(rawKeyPath);
    fs.writeFileSync(path.join(publicKeysDir, `${keyHash}.pem`), keyBytes);
    fs.writeFileSync(path.join(publicKeysDir, `${keyHash}.enc_type`), signingAlgorithm);
  }

  return cacheDir;
}

function hasCacheEntryFor(prefix) {
  if (!STANDALONE_CACHE_DIR || !fixtureExists(prefix)) {
    return false;
  }
  const { metadata } = readFixture(prefix);
  const keyHash = metadata.public_key_hash;
  if (!keyHash) {
    return false;
  }
  const pem = path.join(STANDALONE_CACHE_DIR, 'public_keys', `${keyHash}.pem`);
  const encType = path.join(STANDALONE_CACHE_DIR, 'public_keys', `${keyHash}.enc_type`);
  return fs.existsSync(pem) && fs.existsSync(encType);
}

describe('Cross-language verification', function () {
  this.timeout(30000);

  const available = simple !== null;
  const fixturesDirExists = fs.existsSync(FIXTURES_DIR);

  before(function () {
    if (!available) {
      console.log('  Skipping cross-language tests - simple.js not compiled');
      this.skip();
    }
    if (!fixturesDirExists) {
      console.log('  Skipping cross-language tests - fixtures directory not found');
      this.skip();
    }
    STANDALONE_CACHE_DIR = buildStandaloneKeyCache();
    console.log(`  Standalone key cache: ${STANDALONE_CACHE_DIR}`);
  });

  after(function () {
    if (STANDALONE_CACHE_DIR) {
      fs.rmSync(STANDALONE_CACHE_DIR, { recursive: true, force: true });
      STANDALONE_CACHE_DIR = null;
    }
  });

  // ---------------------------------------------------------------------------
  // Per-algorithm: verify Rust-signed documents with Node.js verifyStandalone
  // ---------------------------------------------------------------------------

  for (const algo of ALGORITHMS) {
    describe(`${algo.name} (${algo.prefix})`, () => {
      const hasFixture = fixturesDirExists && fixtureExists(algo.prefix);

      (available && hasFixture ? it : it.skip)(
        'should verify a Rust-signed document with verifyStandalone',
        () => {
          const { signed, metadata } = readFixture(algo.prefix);
          expect(hasCacheEntryFor(algo.prefix)).to.equal(
            true,
            `Missing standalone key cache entry for fixture ${algo.prefix}`,
          );

          const result = simple.verifyStandalone(signed, standaloneOpts());

          expect(result).to.be.an('object');
          expect(result.valid).to.equal(true, `Failed to verify ${algo.name} document`);
          expect(result.signerId).to.equal(
            metadata.agent_id,
            `Signer ID should match metadata for ${algo.name}`,
          );
        },
      );

      (available && hasFixture ? it : it.skip)(
        'should reject a tampered Rust-signed document',
        () => {
          const { signed } = readFixture(algo.prefix);
          const doc = JSON.parse(signed);
          doc.content.tampered = true;

          const result = simple.verifyStandalone(JSON.stringify(doc), standaloneOpts());

          expect(result.valid).to.equal(false, `Tampered ${algo.name} document should not verify`);
        },
      );

      (available && hasFixture ? it : it.skip)(
        'should extract correct signer metadata',
        () => {
          const { signed, metadata } = readFixture(algo.prefix);

          const result = simple.verifyStandalone(signed, standaloneOpts());

          expect(result.signerId).to.equal(metadata.agent_id);
          const doc = JSON.parse(signed);
          expect(doc.jacsSignature).to.have.property('signingAlgorithm');
          expect(doc.jacsSignature.signingAlgorithm).to.equal(metadata.signing_algorithm);
        },
      );

      (available && hasFixture ? it : it.skip)(
        'should have consistent document structure',
        () => {
          const { signed } = readFixture(algo.prefix);
          const doc = JSON.parse(signed);

          // Required JACS fields
          expect(doc).to.have.property('jacsId');
          expect(doc).to.have.property('jacsSignature');
          expect(doc).to.have.property('jacsSha256');
          expect(doc.jacsSignature).to.have.property('agentID');
          expect(doc.jacsSignature).to.have.property('signature');
          expect(doc.jacsSignature).to.have.property('publicKeyHash');
          expect(doc.jacsSignature).to.have.property('signingAlgorithm');
          expect(doc.jacsSignature).to.have.property('date');
          expect(doc.jacsSignature).to.have.property('fields').that.is.an('array');
        },
      );
    });
  }

  // ---------------------------------------------------------------------------
  // Countersigning: Node agent signs over a Rust-signed document
  // ---------------------------------------------------------------------------

  describe('countersigning', () => {
    const ed25519Exists = fixturesDirExists && fixtureExists('ed25519');

    (available && ed25519Exists && clientModule ? it : it.skip)(
      'should countersign a Rust-signed Ed25519 document with a Node Ed25519 agent',
      async () => {
        const { signed } = readFixture('ed25519');

        const client = await clientModule.JacsClient.ephemeral('ring-Ed25519');
        expect(client.agentId).to.be.a('string').and.not.empty;

        // Sign the Rust-produced document as content for a new message
        const countersigned = await client.signMessage({
          type: 'countersign',
          originalDocument: JSON.parse(signed),
          endorsement: 'Verified and approved by Node.js agent',
        });

        expect(countersigned).to.have.property('raw');
        expect(countersigned).to.have.property('documentId').that.is.a('string').and.not.empty;
        expect(countersigned.agentId).to.equal(client.agentId);

        // Verify structure of the countersigned document
        const doc = JSON.parse(countersigned.raw);
        expect(doc).to.have.property('jacsSignature');
        expect(doc.jacsSignature.agentID).to.equal(client.agentId);
        expect(doc.jacsSignature).to.have.property('signature').that.is.a('string').and.not.empty;
        expect(doc.jacsSignature).to.have.property('signingAlgorithm', 'ring-Ed25519');

        // The original Rust doc should be embedded in content
        expect(doc.content).to.have.property('originalDocument');
        expect(doc.content.originalDocument).to.have.property('jacsSignature');

        // Export countersigned doc to fixtures
        const outputPath = path.join(FIXTURES_DIR, 'node_ed25519_countersigned.json');
        writeFixtureIfEnabled(outputPath, countersigned.raw);
      },
    );

    (available && ed25519Exists && clientModule ? it : it.skip)(
      'should countersign a Rust-signed Ed25519 document with a different algorithm (pq2025)',
      async () => {
        const { signed } = readFixture('ed25519');

        const client = await clientModule.JacsClient.ephemeral('pq2025');
        expect(client.agentId).to.be.a('string').and.not.empty;

        const countersigned = await client.signMessage({
          type: 'countersign',
          originalDocument: JSON.parse(signed),
          endorsement: 'Cross-algorithm countersign',
        });

        expect(countersigned).to.have.property('raw');
        expect(countersigned).to.have.property('documentId').that.is.a('string').and.not.empty;
        expect(countersigned.agentId).to.equal(client.agentId);

        // Verify structure -- different algorithm from original
        const doc = JSON.parse(countersigned.raw);
        expect(doc.jacsSignature.agentID).to.equal(client.agentId);
        expect(doc.jacsSignature).to.have.property('signature').that.is.a('string').and.not.empty;
        // pq2025 uses ML-DSA under the hood
        expect(doc.jacsSignature.signingAlgorithm).to.match(/pq2025|ML-DSA/);

        // Export countersigned doc to fixtures
        const outputPath = path.join(FIXTURES_DIR, 'node_pq2025_countersigned.json');
        writeFixtureIfEnabled(outputPath, countersigned.raw);
      },
    );
  });

  // ---------------------------------------------------------------------------
  // Cross-language chain: verify Python-signed fixtures from Node
  // Proves: Rust generates fixture → Python signs → Node verifies
  // ---------------------------------------------------------------------------

  for (const pf of PYTHON_FIXTURES) {
    describe(`${pf.name} (${pf.prefix})`, () => {
      const hasFixture = fixturesDirExists && fixtureExists(pf.prefix);

      (available && hasFixture ? it : it.skip)(
        'should verify a Python-signed document with verifyStandalone',
        () => {
          const { signed, metadata } = readFixture(pf.prefix);
          expect(hasCacheEntryFor(pf.prefix)).to.equal(
            true,
            `Missing standalone key cache entry for fixture ${pf.prefix}`,
          );

          const result = simple.verifyStandalone(signed, standaloneOpts());

          expect(result.valid).to.equal(true, `Failed to verify ${pf.name} document`);
          expect(result.signerId).to.equal(metadata.agent_id);
        },
      );

      (available && hasFixture ? it : it.skip)(
        'should reject a tampered Python-signed document',
        () => {
          const { signed } = readFixture(pf.prefix);
          const doc = JSON.parse(signed);
          // Python fixtures may nest content under jacsDocument.content or top-level content
          if (doc.jacsDocument && doc.jacsDocument.content) {
            doc.jacsDocument.content.tampered = true;
          } else if (doc.content) {
            doc.content.tampered = true;
          } else {
            doc.tampered = true;
          }

          const result = simple.verifyStandalone(JSON.stringify(doc), standaloneOpts());

          expect(result.valid).to.equal(false);
        },
      );

      (available && hasFixture ? it : it.skip)(
        'should confirm Python fixture was generated by python',
        () => {
          const { metadata } = readFixture(pf.prefix);

          expect(metadata.generated_by).to.equal('python');
          expect(metadata).to.have.property('original_fixture');
        },
      );
    });
  }

  // ---------------------------------------------------------------------------
  // Full chain: Node countersigns a Python-signed doc, then verifies structure
  // Chain: Rust → Python → Node
  // ---------------------------------------------------------------------------

  describe('full chain: Rust -> Python -> Node', () => {
    const pyEd25519Exists = fixturesDirExists && fixtureExists('python_ed25519');

    (available && pyEd25519Exists && clientModule ? it : it.skip)(
      'should countersign a Python-signed Ed25519 doc with a Node agent',
      async () => {
        const { signed: pythonSigned, metadata: pyMeta } = readFixture('python_ed25519');
        expect(hasCacheEntryFor('python_ed25519')).to.equal(
          true,
          'Missing standalone key cache entry for fixture python_ed25519',
        );

        // Verify the Python doc first
        const verifyResult = simple.verifyStandalone(pythonSigned, standaloneOpts());
        expect(verifyResult.valid).to.equal(true, 'Python fixture should verify');

        // Countersign with a Node ephemeral agent
        const client = await clientModule.JacsClient.ephemeral('ring-Ed25519');
        const countersigned = await client.signMessage({
          type: 'chain-countersign',
          chain: ['rust', 'python', 'node'],
          pythonDocument: JSON.parse(pythonSigned),
          pythonAgentId: pyMeta.agent_id,
          endorsement: 'Full chain: Rust -> Python -> Node',
        });

        expect(countersigned.documentId).to.be.a('string').and.not.empty;
        expect(countersigned.agentId).to.equal(client.agentId);

        const doc = JSON.parse(countersigned.raw);
        expect(doc.jacsSignature.agentID).to.equal(client.agentId);
        expect(doc.content.chain).to.deep.equal(['rust', 'python', 'node']);
        expect(doc.content.pythonDocument).to.have.property('jacsSignature');

        // Export for potential Rust verification
        const outputPath = path.join(FIXTURES_DIR, 'node_chain_countersigned.json');
        writeFixtureIfEnabled(outputPath, countersigned.raw);
      },
    );
  });

  // ---------------------------------------------------------------------------
  // generateVerifyLink on cross-language fixtures
  // ---------------------------------------------------------------------------

  describe('generateVerifyLink with cross-language fixtures', () => {
    const ed25519Exists = fixturesDirExists && fixtureExists('ed25519');

    (available && ed25519Exists ? it : it.skip)(
      'should generate a verify link for a Rust-signed Ed25519 document',
      () => {
        const { signed } = readFixture('ed25519');
        // The full signed document may exceed URL length limits
        try {
          const url = simple.generateVerifyLink(signed);
          expect(url).to.be.a('string');
          expect(url).to.match(/^https:\/\/hai\.ai\/jacs\/verify\?s=/);
        } catch (e) {
          // Expected if document is too large for URL encoding
          expect(String(e)).to.match(/max length/i);
        }
      },
    );
  });

  // ---------------------------------------------------------------------------
  // Fixture completeness check
  // ---------------------------------------------------------------------------

  describe('fixture completeness', () => {
    (fixturesDirExists ? it : it.skip)(
      'should report which algorithm fixtures are available',
      () => {
        const status = ALGORITHMS.map((a) => ({
          algorithm: a.name,
          prefix: a.prefix,
          available: fixtureExists(a.prefix),
        }));

        console.log('    Cross-language fixture status:');
        for (const s of status) {
          console.log(`      ${s.available ? '[ok]' : '[--]'} ${s.algorithm} (${s.prefix})`);
        }

        // At minimum, Ed25519 should exist
        const ed25519 = status.find((s) => s.prefix === 'ed25519');
        expect(ed25519.available).to.equal(
          true,
          'Ed25519 fixtures must exist (generated by Rust fixture creator)',
        );
      },
    );
  });
});
