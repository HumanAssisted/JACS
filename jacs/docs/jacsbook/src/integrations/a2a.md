# A2A Interoperability

This guide describes how JACS interoperates with Agent-to-Agent (A2A) systems in real deployments.

## What JACS Adds

JACS adds cryptographic provenance to A2A artifacts:

- Signed artifact envelopes (`a2a-task`, `a2a-message`, etc.)
- Verifiable signer identity via public key resolution
- Chain-of-custody support through parent signatures
- Well-known discovery documents for external verifiers
- Trust policy enforcement (open / verified / strict)

## Interoperability Contract

JACS A2A integration targets the v0.4.0 Agent Card shape, implemented in the Rust, Python, and Node bindings.

Required well-known documents (all five are generated by every binding):

| Document | Purpose |
|----------|---------|
| `/.well-known/agent-card.json` | A2A Agent Card with JWS signature |
| `/.well-known/jwks.json` | JWK Set for A2A verifiers |
| `/.well-known/jacs-agent.json` | JACS agent descriptor |
| `/.well-known/jacs-pubkey.json` | JACS public key |
| `/.well-known/jacs-extension.json` | JACS provenance extension descriptor |

## Quick Start

> **New to A2A?** See the [A2A Quickstart Guide](../guides/a2a-quickstart.md) for a step-by-step walkthrough from install to serving discovery endpoints.

Every JACS agent is an A2A agent -- zero additional configuration.
MCP and A2A cover different layers: MCP standardizes model-to-tool interactions inside an application boundary, while A2A standardizes agent-to-agent discovery and exchange across boundaries.
For A2A security, JACS is an OAuth alternative for service-to-service agent trust (mTLS-like at the payload layer), not a replacement for OAuth/OIDC delegated user authorization.

### Python

```python
from jacs.client import JacsClient

client = JacsClient.quickstart()
card = client.export_agent_card(url="agents.example.com")
signed = client.sign_artifact({"action": "classify", "input": "hello"}, "task")
```

### Node.js

```typescript
import { JacsClient } from '@hai.ai/jacs/client';

const client = await JacsClient.quickstart();
const card = client.exportAgentCard();
const signed = await client.signArtifact({ action: 'classify', input: 'hello' }, 'task');
```

### Serve Discovery Documents (Python)

> **Note:** `serve()` requires `pip install jacs[a2a-server]` (adds FastAPI + uvicorn).

```python
from jacs.client import JacsClient
from jacs.a2a import JACSA2AIntegration

client = JacsClient.quickstart()
a2a = client.get_a2a(url="http://localhost:8080")
a2a.serve(port=8080)  # Publishes all 5 /.well-known/ endpoints
```

Or as a one-liner:

```python
JACSA2AIntegration.quickstart(url="http://localhost:8080").serve(port=8080)
```

For production use, mount the A2A router into your own FastAPI app:

```python
from jacs.a2a_server import jacs_a2a_routes, create_a2a_app

# Option 1: Get a router to mount in your existing app
router = jacs_a2a_routes(client)
app.include_router(router)

# Option 2: Get a complete FastAPI app
app = create_a2a_app(client, title="My A2A Agent")
```

## Trust Policies

JACS trust policies control how your agent handles foreign A2A signatures:

| Policy | Behavior |
|--------|----------|
| `open` | Accept all agents without verification |
| `verified` | Require the JACS provenance extension (`urn:hai.ai:jacs-provenance-v1`) in the agent card (**default**) |
| `strict` | Require the signer to be in the local trust store |

Trust is the key differentiator between JACS A2A and vanilla A2A -- every artifact carries cryptographic proof of who signed it, and your agent decides how much proof it requires.

### Python Trust Policy

```python
from jacs.client import JacsClient
from jacs.a2a import JACSA2AIntegration

client = JacsClient.quickstart()
a2a = JACSA2AIntegration(client, trust_policy="strict")

# Assess a remote agent's trustworthiness
result = a2a.assess_remote_agent(remote_card_json)
# result: {"card": {...}, "jacs_registered": True, "trust_level": "trusted", "allowed": True}

# Add a remote agent to your trust store
a2a.trust_a2a_agent(remote_card_json)

# Verify an artifact with trust assessment included
result = a2a.verify_wrapped_artifact(artifact, assess_trust=True)
# result includes a "trust" key with trust_level and allowed
```

### Node.js Trust Policy

```typescript
import { JACSA2AIntegration } from '@hai.ai/jacs/a2a';

const a2a = new JACSA2AIntegration(client, 'strict');

const assessment = a2a.assessRemoteAgent(remoteCardJson);
// { jacsRegistered, trustLevel, allowed, inTrustStore }

a2a.trustA2AAgent(remoteAgentId);
```

### Framework Adapter Trust

All JACS framework adapters inherit trust methods from `BaseJacsAdapter`:

```python
from jacs.adapters.fastapi import JacsMiddleware

# FastAPI middleware with A2A enabled
middleware = JacsMiddleware(client=client, a2a=True)

# Any adapter can assess trust
adapter.assess_trust(remote_card_json, policy="verified")
adapter.export_agent_card(url="agents.example.com")
```

See [Framework Adapters](../python/adapters.md) for more details.

## Agent Card Discovery

Use the discovery client to find and assess remote A2A agents:

```python
from jacs.a2a_discovery import discover_agent, discover_and_assess

# Async: fetch a remote agent card
card = await discover_agent("https://agent.example.com")

# Async: fetch + assess trust
result = await discover_and_assess(
    "https://agent.example.com",
    policy="verified",
    client=client,  # needed for "strict" policy
)
if result["allowed"]:
    print(f"Trusted: {result['card']['name']}")

# Sync wrappers available too
from jacs.a2a_discovery import discover_agent_sync, discover_and_assess_sync
card = discover_agent_sync("https://agent.example.com")
```

## Verification Model

When verifying foreign-agent A2A artifacts, JACS resolves keys using `JACS_KEY_RESOLUTION` order:

- `local`: trusted local key cache
- `dns`: identity validation only (does not return key bytes)
- `hai`: remote key retrieval from HAI key service

If a key is found, JACS performs full signature verification and returns a verified status.
If no key is found, verification is explicitly marked unverified (not silently accepted).

## 12-Factor Runtime Configuration

Use environment variables for deploy-time behavior:

```bash
export JACS_PRIVATE_KEY_PASSWORD="your-strong-password"
export JACS_KEY_RESOLUTION="local,hai"
export HAI_KEYS_BASE_URL="https://keys.hai.ai"
```

For offline/air-gapped operation:

```bash
export JACS_KEY_RESOLUTION="local"
```

## Python: `JACSA2AIntegration` Class

The `jacs.a2a` module provides the `JACSA2AIntegration` class which handles the full A2A lifecycle: agent card export, artifact signing, verification, trust assessment, chain-of-custody, and well-known document generation.

### Create from a JacsClient

```python
from jacs.client import JacsClient
from jacs.a2a import JACSA2AIntegration

client = JacsClient.quickstart()
a2a = client.get_a2a(url="http://localhost:8080")
```

Or use the backward-compatible factory:

```python
a2a = JACSA2AIntegration.from_config("jacs.config.json")
```

### Export an A2A Agent Card

Export your JACS agent as a v0.4.0 A2A Agent Card. JACS services are automatically converted to A2A skills, and a `urn:hai.ai:jacs-provenance-v1` extension is declared in capabilities.

```python
# Via JacsClient (preferred)
card = client.export_agent_card(url="agents.example.com")

# Via JACSA2AIntegration (for full control)
import json
agent_data = json.loads(client.export_agent())
card = a2a.export_agent_card(agent_data)
# card.name, card.skills, card.capabilities.extensions
```

### Generate Well-Known Documents

```python
docs = a2a.generate_well_known_documents(
    agent_card=card,
    jws_signature="eyJhbGciOi...",
    public_key_b64="MIIBIjANBg...",
    agent_data=agent_data,
)
# docs contains all 5 well-known paths:
#   /.well-known/agent-card.json
#   /.well-known/jwks.json
#   /.well-known/jacs-agent.json
#   /.well-known/jacs-pubkey.json
#   /.well-known/jacs-extension.json
```

### Sign and Verify A2A Artifacts

```python
# Sign an artifact
signed = a2a.sign_artifact(
    {"taskId": "task-456", "operation": "classify"},
    "task",
)

# Verify a received artifact
result = a2a.verify_wrapped_artifact(signed)
assert result["valid"]
assert result["artifact_type"] == "a2a-task"

# Verify with trust assessment
result = a2a.verify_wrapped_artifact(signed, assess_trust=True)
assert result["trust"]["allowed"]
```

### Chain of Custody

Build a provenance chain when artifacts pass between agents:

```python
# Agent A signs step 1
step1 = a2a_agent_a.sign_artifact({"step": 1, "data": "raw_input"}, "message")

# Agent B signs step 2, referencing step 1
step2 = a2a_agent_b.sign_artifact(
    {"step": 2, "data": "processed"},
    "message",
    parent_signatures=[step1],
)

# Verify the full chain
result = a2a_agent_b.verify_wrapped_artifact(step2)
assert result["valid"]
assert result["parent_signatures_valid"]

# Generate audit trail
chain = a2a_agent_b.create_chain_of_custody([step1, step2])
```

### Cross-Organization Trust via Discovery

To discover and verify a remote agent from another organization:

1. Fetch their `/.well-known/agent-card.json` (use `discover_agent()` from `jacs.a2a_discovery`)
2. Assess trust with `a2a.assess_remote_agent(card_json)` or `discover_and_assess()`
3. Check the `urn:hai.ai:jacs-provenance-v1` extension for JACS compatibility
4. Use `JACS_KEY_RESOLUTION` to resolve their public key and verify artifacts
5. Optionally add them to your trust store with `a2a.trust_a2a_agent(card_json)`

## Rust Example

```rust
use jacs::a2a::provenance::{wrap_artifact_with_provenance, verify_wrapped_artifact};
use serde_json::json;

let wrapped = wrap_artifact_with_provenance(
    &mut agent,
    json!({"taskId": "task-123", "operation": "classify"}),
    "task",
    None,
)?;

let result = verify_wrapped_artifact(&agent, &wrapped)?;
assert!(result.valid);
```

## Node.js: `JACSA2AIntegration` Class

```typescript
import { JacsClient } from '@hai.ai/jacs/client';

const client = await JacsClient.quickstart();
const a2a = client.getA2A();

// Sign an artifact
const signed = await a2a.signArtifact(
  { taskId: 'task-123', operation: 'classify' },
  'task',
);

// Verify a received artifact
const result = a2a.verifyWrappedArtifact(signed);
console.log(result.valid, result.parentSignaturesValid);

// Assess trust
const assessment = a2a.assessRemoteAgent(remoteCardJson);
console.log(assessment.allowed, assessment.trustLevel);
```

Or use the JacsClient shorthand:

```typescript
const card = client.exportAgentCard();
const signed = await client.signArtifact({ action: 'classify' }, 'task');
```

## MCP Integration

Register A2A and trust store tools on an MCP server:

```python
from fastmcp import FastMCP
from jacs.adapters.mcp import register_jacs_tools, register_a2a_tools, register_trust_tools

mcp = FastMCP("jacs-a2a-server")
register_jacs_tools(mcp, client=client)     # core signing/verification
register_a2a_tools(mcp, client=client)      # agent card, sign/verify artifacts, assess trust
register_trust_tools(mcp, client=client)    # trust store management
mcp.run()
```

Or use the middleware with `a2a=True`:

```python
from jacs.adapters.mcp import JacsMCPMiddleware

mw = JacsMCPMiddleware(client=client, a2a=True)
mw.register_tools(mcp)  # registers all 8 A2A + trust tools
mcp.add_middleware(mw)
```

See [MCP Integration](mcp.md) for more details.

## FastAPI Middleware

Inject well-known endpoints into your FastAPI app:

```python
from fastapi import FastAPI
from jacs.adapters.fastapi import JacsMiddleware

app = FastAPI()
app.add_middleware(JacsMiddleware, client=client, a2a=True)
# Now serves /.well-known/agent-card.json, jwks.json, etc.
```

See [Framework Adapters](../python/adapters.md) for more details.

## API Reference

### Python `JACSA2AIntegration`

| Method | Description |
|--------|-------------|
| `JACSA2AIntegration(client, trust_policy)` | Create from a `JacsClient` with optional trust policy |
| `JACSA2AIntegration.from_config(path)` | Create from a config file |
| `JACSA2AIntegration.quickstart(...)` | Zero-config quickstart with optional URL |
| `export_agent_card(agent_data)` | Convert JACS agent data to `A2AAgentCard` |
| `sign_artifact(artifact, type, parents)` | Sign an A2A artifact with JACS provenance |
| `verify_wrapped_artifact(wrapped, assess_trust, trust_policy)` | Verify signature + optional trust assessment |
| `assess_remote_agent(card_json, policy)` | Assess trust for a remote Agent Card |
| `trust_a2a_agent(card_json)` | Add remote agent to local trust store |
| `create_chain_of_custody(artifacts)` | Build audit trail from signed artifacts |
| `generate_well_known_documents(...)` | Generate all 5 `.well-known` documents |
| `create_extension_descriptor()` | Return JACS extension descriptor for A2A |
| `serve(port, host)` | Start a FastAPI server publishing well-known docs |

### Python `JacsClient` A2A Methods

| Method | Description |
|--------|-------------|
| `get_a2a(url, skills)` | Get a `JACSA2AIntegration` wired to this client |
| `export_agent_card(url, skills)` | Export an `A2AAgentCard` from this agent |
| `sign_artifact(artifact, type, parents)` | Sign an A2A artifact (convenience shorthand) |

### Python Discovery Client (`jacs.a2a_discovery`)

| Function | Description |
|----------|-------------|
| `discover_agent(url)` | Async: fetch remote Agent Card |
| `discover_and_assess(url, policy, client)` | Async: fetch + trust assessment |
| `discover_agent_sync(url)` | Sync wrapper |
| `discover_and_assess_sync(url, policy, client)` | Sync wrapper |

### Python A2A Server (`jacs.a2a_server`)

| Function | Description |
|----------|-------------|
| `jacs_a2a_routes(client, skills)` | Returns a FastAPI `APIRouter` with 5 well-known endpoints |
| `create_a2a_app(client, skills, title)` | Returns a complete FastAPI app with CORS |
| `serve_a2a(client, port, host, skills)` | Blocking convenience server via uvicorn |

### Node.js `JACSA2AIntegration`

| Method | Description |
|--------|-------------|
| `new JACSA2AIntegration(client, trustPolicy?)` | Create from a `JacsClient` with optional trust policy |
| `exportAgentCard(agentData)` | Convert JACS agent data to A2A Agent Card |
| `signArtifact(artifact, type, parents)` | Sign an A2A artifact with JACS provenance |
| `verifyWrappedArtifact(wrapped)` | Verify signature + recursive parent chain |
| `assessRemoteAgent(cardJson)` | Assess trust for a remote Agent Card |
| `trustA2AAgent(agentId)` | Add remote agent to local trust store |
| `createChainOfCustody(artifacts)` | Build audit trail from signed artifacts |
| `generateWellKnownDocuments(...)` | Generate all 5 `.well-known` documents |

### Node.js `JacsClient` A2A Methods

| Method | Description |
|--------|-------------|
| `getA2A()` | Get a `JACSA2AIntegration` wired to this client |
| `exportAgentCard(agentData?)` | Export an A2A Agent Card from this agent |
| `signArtifact(artifact, type, parents)` | Sign an A2A artifact (convenience shorthand) |

## DevEx Expectations

Before merging A2A changes, ensure:

1. Rust, Python, and Node A2A tests all pass.
2. Foreign-signature verification is covered by tests (resolved and unresolved key paths).
3. Documentation snippets match package names and executable APIs.
4. All 5 well-known documents are generated and match output from all bindings.
5. Trust policy behavior (open/verified/strict) is consistent across bindings.

## Troubleshooting

- `Unverified` foreign signatures: no signer key available from configured resolution order.
- `Invalid` signatures: signature bytes, signer key, or signed payload fields do not match.
- Missing `jwks.json`: ensure you are using current A2A helper APIs in your binding.
- `Cycle detected`: parent signature chain has a circular reference. Each artifact's `jacsId` must be unique.
- Trust policy rejections: check that `trust_policy` matches your requirements. Use `"open"` for development, `"strict"` for production.
