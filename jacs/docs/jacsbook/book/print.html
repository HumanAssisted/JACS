<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JACS Usage Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="getting-started/what-is-jacs.html"><strong aria-hidden="true">1.</strong> What is JACS?</a></li><li class="chapter-item expanded "><a href="getting-started/concepts.html"><strong aria-hidden="true">2.</strong> Core Concepts</a></li><li class="chapter-item expanded "><a href="getting-started/quick-start.html"><strong aria-hidden="true">3.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="usecases.html"><strong aria-hidden="true">4.</strong> Use cases</a></li><li class="chapter-item expanded "><a href="rust/installation.html"><strong aria-hidden="true">5.</strong> Installation</a></li><li class="chapter-item expanded "><a href="rust/cli.html"><strong aria-hidden="true">6.</strong> CLI Usage</a></li><li class="chapter-item expanded "><a href="rust/agent.html"><strong aria-hidden="true">7.</strong> Creating an Agent</a></li><li class="chapter-item expanded "><a href="rust/documents.html"><strong aria-hidden="true">8.</strong> Working with Documents</a></li><li class="chapter-item expanded "><a href="rust/agreements.html"><strong aria-hidden="true">9.</strong> Creating and Using Agreements</a></li><li class="chapter-item expanded "><a href="rust/dns.html"><strong aria-hidden="true">10.</strong> DNS-Based Verification</a></li><li class="chapter-item expanded "><a href="rust/library.html"><strong aria-hidden="true">11.</strong> Rust Library API</a></li><li class="chapter-item expanded "><a href="rust/observability.html"><strong aria-hidden="true">12.</strong> Observability</a></li><li class="chapter-item expanded "><a href="nodejs/installation.html"><strong aria-hidden="true">13.</strong> Installation</a></li><li class="chapter-item expanded "><a href="nodejs/simple-api.html"><strong aria-hidden="true">14.</strong> Simplified API</a></li><li class="chapter-item expanded "><a href="nodejs/basic-usage.html"><strong aria-hidden="true">15.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="nodejs/mcp.html"><strong aria-hidden="true">16.</strong> MCP Integration</a></li><li class="chapter-item expanded "><a href="nodejs/http.html"><strong aria-hidden="true">17.</strong> HTTP Server</a></li><li class="chapter-item expanded "><a href="nodejs/express.html"><strong aria-hidden="true">18.</strong> Express Middleware</a></li><li class="chapter-item expanded "><a href="nodejs/api.html"><strong aria-hidden="true">19.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="python/installation.html"><strong aria-hidden="true">20.</strong> Installation</a></li><li class="chapter-item expanded "><a href="python/simple-api.html"><strong aria-hidden="true">21.</strong> Simplified API</a></li><li class="chapter-item expanded "><a href="python/basic-usage.html"><strong aria-hidden="true">22.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="python/mcp.html"><strong aria-hidden="true">23.</strong> MCP Integration</a></li><li class="chapter-item expanded "><a href="python/api.html"><strong aria-hidden="true">24.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="schemas/overview.html"><strong aria-hidden="true">25.</strong> JSON Schemas</a></li><li class="chapter-item expanded "><a href="schemas/agent.html"><strong aria-hidden="true">26.</strong> Agent Schema</a></li><li class="chapter-item expanded "><a href="schemas/document.html"><strong aria-hidden="true">27.</strong> Document Schema</a></li><li class="chapter-item expanded "><a href="schemas/task.html"><strong aria-hidden="true">28.</strong> Task Schema</a></li><li class="chapter-item expanded "><a href="schemas/agentstate.html"><strong aria-hidden="true">29.</strong> Agent State Schema</a></li><li class="chapter-item expanded "><a href="schemas/commitment.html"><strong aria-hidden="true">30.</strong> Commitment Schema</a></li><li class="chapter-item expanded "><a href="schemas/todo.html"><strong aria-hidden="true">31.</strong> Todo List Schema</a></li><li class="chapter-item expanded "><a href="schemas/conversation.html"><strong aria-hidden="true">32.</strong> Conversation Schema</a></li><li class="chapter-item expanded "><a href="schemas/configuration.html"><strong aria-hidden="true">33.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="advanced/security.html"><strong aria-hidden="true">34.</strong> Security Model</a></li><li class="chapter-item expanded "><a href="advanced/key-rotation.html"><strong aria-hidden="true">35.</strong> Key Rotation</a></li><li class="chapter-item expanded "><a href="advanced/crypto.html"><strong aria-hidden="true">36.</strong> Cryptographic Algorithms</a></li><li class="chapter-item expanded "><a href="advanced/storage.html"><strong aria-hidden="true">37.</strong> Storage Backends</a></li><li class="chapter-item expanded "><a href="advanced/custom-schemas.html"><strong aria-hidden="true">38.</strong> Custom Schemas</a></li><li class="chapter-item expanded "><a href="advanced/testing.html"><strong aria-hidden="true">39.</strong> Testing</a></li><li class="chapter-item expanded "><a href="integrations/mcp.html"><strong aria-hidden="true">40.</strong> Model Context Protocol (MCP)</a></li><li class="chapter-item expanded "><a href="integrations/a2a.html"><strong aria-hidden="true">41.</strong> A2A Interoperability</a></li><li class="chapter-item expanded "><a href="integrations/openclaw.html"><strong aria-hidden="true">42.</strong> OpenClaw</a></li><li class="chapter-item expanded "><a href="integrations/web-servers.html"><strong aria-hidden="true">43.</strong> Web Servers</a></li><li class="chapter-item expanded "><a href="integrations/databases.html"><strong aria-hidden="true">44.</strong> Databases</a></li><li class="chapter-item expanded "><a href="examples/cli.html"><strong aria-hidden="true">45.</strong> CLI Examples</a></li><li class="chapter-item expanded "><a href="examples/nodejs.html"><strong aria-hidden="true">46.</strong> Node.js Examples</a></li><li class="chapter-item expanded "><a href="examples/python.html"><strong aria-hidden="true">47.</strong> Python Examples</a></li><li class="chapter-item expanded "><a href="examples/integrations.html"><strong aria-hidden="true">48.</strong> Integration Examples</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli-commands.html"><strong aria-hidden="true">49.</strong> CLI Command Reference</a></li><li class="chapter-item expanded "><a href="reference/configuration.html"><strong aria-hidden="true">50.</strong> Configuration Reference</a></li><li class="chapter-item expanded "><a href="reference/errors.html"><strong aria-hidden="true">51.</strong> Error Codes</a></li><li class="chapter-item expanded "><a href="reference/migration.html"><strong aria-hidden="true">52.</strong> Migration Guide</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JACS Usage Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jacs-json-agent-communication-standard"><a class="header" href="#jacs-json-agent-communication-standard">JACS: JSON Agent Communication Standard</a></h1>
<p>Welcome to the <strong>JSON Agent Communication Standard (JACS)</strong> documentation! JACS is a comprehensive framework for creating, signing, and verifying JSON documents with cryptographic integrity, designed specifically for AI agent communication and task management.</p>
<h2 id="what-is-jacs"><a class="header" href="#what-is-jacs">What is JACS?</a></h2>
<p>JACS provides a standard way for AI agents to:</p>
<ul>
<li><strong>Create and sign</strong> JSON documents with cryptographic signatures</li>
<li><strong>Verify authenticity</strong> and integrity of documents</li>
<li><strong>Manage tasks and agreements</strong> between multiple agents</li>
<li><strong>Maintain audit trails</strong> of modifications and versioning</li>
<li><strong>Ensure trust</strong> in multi-agent systems</li>
</ul>
<p>As a developer, JACS gives you the tools to build trustworthy AI systems where agents can securely exchange tasks, agreements, and data with verifiable integrity.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>üîê <strong>Cryptographic Security</strong>: RSA, Ed25519, and post-quantum cryptographic algorithms</li>
<li>üìã <strong>JSON Schema Validation</strong>: Enforced document structure and validation</li>
<li>ü§ù <strong>Multi-Agent Agreements</strong>: Built-in support for agent collaboration and task agreements</li>
<li>üîç <strong>Full Audit Trail</strong>: Complete versioning and modification history</li>
<li>üåê <strong>Multiple Language Support</strong>: Rust, Node.js, and Python implementations</li>
<li>üîå <strong>MCP Integration</strong>: Native Model Context Protocol support</li>
<li>üìä <strong>Observability</strong>: Built-in logging and metrics for production systems</li>
</ul>
<h2 id="available-implementations"><a class="header" href="#available-implementations">Available Implementations</a></h2>
<p>JACS is available in three languages, each with its own strengths:</p>
<h3 id="-rust-core-library--cli"><a class="header" href="#-rust-core-library--cli">ü¶Ä Rust (Core Library + CLI)</a></h3>
<ul>
<li><strong>Performance</strong>: Fastest implementation with native performance</li>
<li><strong>CLI Tool</strong>: Complete command-line interface for agent and document management</li>
<li><strong>Library</strong>: Full-featured Rust library for embedded applications</li>
<li><strong>Observability</strong>: Advanced logging and metrics with OpenTelemetry support</li>
</ul>
<h3 id="-nodejs-haiaijacs"><a class="header" href="#-nodejs-haiaijacs">üü¢ Node.js (@hai.ai/jacs)</a></h3>
<ul>
<li><strong>Web Integration</strong>: Perfect for web servers and Express.js applications</li>
<li><strong>MCP Support</strong>: Native Model Context Protocol integration</li>
<li><strong>HTTP Server</strong>: Built-in HTTP server capabilities</li>
<li><strong>NPM Package</strong>: Easy installation and integration</li>
</ul>
<h3 id="-python-jacs"><a class="header" href="#-python-jacs">üêç Python (jacs)</a></h3>
<ul>
<li><strong>AI/ML Integration</strong>: Ideal for AI and machine learning workflows</li>
<li><strong>MCP Support</strong>: Authenticated MCP server patterns</li>
<li><strong>PyPI Package</strong>: Simple <code>pip install</code> integration</li>
<li><strong>Data Science</strong>: Perfect for Jupyter notebooks and data pipelines</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Choose your implementation and get started in minutes:</p>
<h3 id="rust-cli"><a class="header" href="#rust-cli">Rust CLI</a></h3>
<pre><code class="language-bash">cargo install jacs --features cli
# Upgrade to latest: cargo install jacs --features cli --force
jacs init  # Create config, keys, and agent
</code></pre>
<p>Or step by step:</p>
<pre><code class="language-bash">jacs config create
jacs agent create --create-keys true
</code></pre>
<h3 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h3>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./config.json');
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<pre><code class="language-python">import jacs

agent = jacs.JacsAgent()
agent.load("./config.json")
</code></pre>
<h2 id="when-to-use-jacs"><a class="header" href="#when-to-use-jacs">When to Use JACS</a></h2>
<p>JACS is ideal for scenarios where you need:</p>
<ul>
<li><strong>Multi-agent systems</strong> where agents need to trust each other</li>
<li><strong>Task delegation</strong> with verifiable completion and approval</li>
<li><strong>Audit trails</strong> for AI decision-making processes</li>
<li><strong>Secure data exchange</strong> between AI systems</li>
<li><strong>Compliance</strong> requirements for AI system interactions</li>
<li><strong>Version control</strong> for AI-generated content and decisions</li>
</ul>
<h2 id="why-jacs"><a class="header" href="#why-jacs">Why JACS?</a></h2>
<h3 id="-agent-focused-design"><a class="header" href="#-agent-focused-design">üéØ <strong>Agent-Focused Design</strong></a></h3>
<p>Unlike general-purpose signing frameworks, JACS is specifically designed for AI agent communication patterns - tasks, agreements, and collaborative workflows.</p>
<h3 id="-production-ready"><a class="header" href="#-production-ready">üöÄ <strong>Production Ready</strong></a></h3>
<p>With built-in observability, multiple storage backends, and comprehensive error handling, JACS is ready for production AI systems.</p>
<h3 id="-future-proof-security"><a class="header" href="#-future-proof-security">üîí <strong>Future-Proof Security</strong></a></h3>
<p>Support for both current (RSA, Ed25519) and post-quantum cryptographic algorithms ensures your system remains secure.</p>
<h3 id="-universal-compatibility"><a class="header" href="#-universal-compatibility">üåê <strong>Universal Compatibility</strong></a></h3>
<p>JSON-based documents work everywhere - store them in any database, transmit over any protocol, integrate with any system.</p>
<h3 id="-flexible-integration"><a class="header" href="#-flexible-integration">üß© <strong>Flexible Integration</strong></a></h3>
<p>Whether you're building a simple CLI tool or a complex multi-agent system, JACS adapts to your architecture.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li><strong><a href="getting-started/concepts.html">Core Concepts</a></strong> - Understand agents, documents, and agreements</li>
<li><strong><a href="getting-started/quick-start.html">Quick Start Guide</a></strong> - Get up and running in minutes</li>
<li><strong>Choose Your Implementation</strong>:
<ul>
<li><a href="rust/installation.html">Rust CLI &amp; Library</a></li>
<li><a href="nodejs/installation.html">Node.js Package</a></li>
<li><a href="python/installation.html">Python Package</a></li>
</ul>
</li>
</ol>
<h2 id="community-and-support"><a class="header" href="#community-and-support">Community and Support</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/HumanAssisted/JACS">HumanAssisted/JACS</a></li>
<li><strong>Issues</strong>: Report bugs and feature requests</li>
<li><strong>Examples</strong>: Complete examples for all implementations</li>
<li><strong>Documentation</strong>: This comprehensive guide</li>
</ul>
<hr />
<p><em>Ready to build trustworthy AI systems? Let's get started!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-jacs-1"><a class="header" href="#what-is-jacs-1">What is JACS?</a></h1>
<p><strong>JACS (JSON Agent Communication Standard)</strong> is a comprehensive framework designed to solve a critical problem in AI systems: <strong>How do agents communicate and collaborate securely with verifiable trust?</strong></p>
<h2 id="the-problem-jacs-solves"><a class="header" href="#the-problem-jacs-solves">The Problem JACS Solves</a></h2>
<p>As AI systems become more sophisticated, we're moving toward multi-agent architectures where different AI agents need to:</p>
<ul>
<li><strong>Exchange tasks</strong> and delegate work to each other</li>
<li><strong>Create agreements</strong> and verify their completion</li>
<li><strong>Share data</strong> with guaranteed authenticity</li>
<li><strong>Maintain audit trails</strong> of decisions and actions</li>
<li><strong>Establish trust</strong> without centralized authorities</li>
</ul>
<p>Traditional approaches fall short because they lack:</p>
<ul>
<li>Cryptographic integrity for agent communications</li>
<li>Standardized formats for agent interactions</li>
<li>Built-in versioning and audit trails</li>
<li>Support for multi-agent agreements and workflows</li>
</ul>
<h2 id="jacs-core-philosophy"><a class="header" href="#jacs-core-philosophy">JACS Core Philosophy</a></h2>
<h3 id="-agent-first-design"><a class="header" href="#-agent-first-design">üéØ <strong>Agent-First Design</strong></a></h3>
<p>JACS is built specifically for AI agent communication patterns, not as a general-purpose document signing system. It understands concepts like:</p>
<ul>
<li><strong>Agents</strong> with identities and capabilities</li>
<li><strong>Tasks</strong> that can be delegated and tracked</li>
<li><strong>Agreements</strong> between multiple parties</li>
<li><strong>Versioning</strong> for iterative improvements</li>
</ul>
<h3 id="-trust-through-cryptography"><a class="header" href="#-trust-through-cryptography">üîê <strong>Trust Through Cryptography</strong></a></h3>
<p>Every JACS document includes:</p>
<ul>
<li><strong>Digital signatures</strong> proving authenticity</li>
<li><strong>Hash verification</strong> ensuring integrity</li>
<li><strong>Public key cryptography</strong> for identity verification</li>
<li><strong>Timestamps</strong> for chronological ordering</li>
</ul>
<h3 id="-standards-based"><a class="header" href="#-standards-based">üìã <strong>Standards-Based</strong></a></h3>
<p>JACS builds on proven standards:</p>
<ul>
<li><strong>JSON</strong> for universal compatibility</li>
<li><strong>JSON Schema</strong> for structure validation</li>
<li><strong>RFC 3339</strong> timestamps for consistency</li>
<li><strong>Standard cryptographic algorithms</strong> (RSA, Ed25519, post-quantum)</li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="agents"><a class="header" href="#agents">Agents</a></h3>
<p>An <strong>Agent</strong> is an autonomous entity with:</p>
<ul>
<li>A unique identity (UUID)</li>
<li>Cryptographic keys for signing</li>
<li>Capabilities defined in services</li>
<li>The ability to create and verify documents</li>
</ul>
<h3 id="documents"><a class="header" href="#documents">Documents</a></h3>
<p>A <strong>Document</strong> is any JSON object that includes:</p>
<ul>
<li>JACS header fields (ID, version, creator, etc.)</li>
<li>A cryptographic signature</li>
<li>A hash for integrity verification</li>
<li>Business logic specific to the document type</li>
</ul>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p>A <strong>Task</strong> is a special document type representing:</p>
<ul>
<li>Work to be performed</li>
<li>Success/failure criteria</li>
<li>Input/output specifications</li>
<li>Delegation and completion tracking</li>
</ul>
<h3 id="agreements"><a class="header" href="#agreements">Agreements</a></h3>
<p>An <strong>Agreement</strong> is a mechanism for:</p>
<ul>
<li>Multiple agents to consent to terms</li>
<li>Tracking signatures from all required parties</li>
<li>Ensuring all participants have signed before proceeding</li>
<li>Creating binding commitments between agents</li>
</ul>
<h2 id="how-jacs-works"><a class="header" href="#how-jacs-works">How JACS Works</a></h2>
<pre><code class="language-mermaid">graph TD
    A[Agent A] --&gt;|Creates Task| T[JACS Task Document]
    T --&gt;|Contains| S[Digital Signature]
    T --&gt;|Contains| H[SHA256 Hash]
    T --&gt;|Contains| M[Metadata]
    
    A --&gt;|Sends to| B[Agent B]
    B --&gt;|Verifies| T
    B --&gt;|Signs Agreement| AG[Agreement Document]
    AG --&gt;|Returns to| A
</code></pre>
<ol>
<li><strong>Agent A</strong> creates a task document with their requirements</li>
<li>The document is <strong>signed</strong> with Agent A's private key</li>
<li>A <strong>hash</strong> is calculated for integrity verification</li>
<li><strong>Agent B</strong> receives and verifies the signature and hash</li>
<li>Agent B can <strong>create an agreement</strong> to accept the task</li>
<li>Both agents have a <strong>verifiable record</strong> of the interaction</li>
</ol>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="-ai-content-pipeline"><a class="header" href="#-ai-content-pipeline">ü§ñ <strong>AI Content Pipeline</strong></a></h3>
<pre><code>Content Agent ‚Üí Research Agent ‚Üí Review Agent ‚Üí Publishing Agent
</code></pre>
<p>Each handoff includes signed task documents with clear requirements and deliverables.</p>
<h3 id="-data-processing-workflow"><a class="header" href="#-data-processing-workflow">üìä <strong>Data Processing Workflow</strong></a></h3>
<pre><code>Data Ingestion Agent ‚Üí Processing Agent ‚Üí Validation Agent ‚Üí Storage Agent
</code></pre>
<p>Each step is tracked with verifiable completion certificates and quality metrics.</p>
<h3 id="-multi-agent-analysis"><a class="header" href="#-multi-agent-analysis">üîç <strong>Multi-Agent Analysis</strong></a></h3>
<pre><code>Query Agent ‚Üí Research Agent ‚Üí Analysis Agent ‚Üí Reporting Agent
</code></pre>
<p>Complex analysis tasks are broken down with clear accountability for each step.</p>
<h2 id="benefits-over-alternatives"><a class="header" href="#benefits-over-alternatives">Benefits Over Alternatives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>JACS</th><th>Traditional APIs</th><th>General Signing</th></tr></thead><tbody>
<tr><td><strong>Agent Identity</strong></td><td>‚úÖ Built-in</td><td>‚ùå Custom implementation</td><td>‚ùå Not agent-focused</td></tr>
<tr><td><strong>Task Management</strong></td><td>‚úÖ Native support</td><td>‚ùå Application-specific</td><td>‚ùå Not applicable</td></tr>
<tr><td><strong>Multi-Party Agreements</strong></td><td>‚úÖ Core feature</td><td>‚ùå Complex to implement</td><td>‚ö†Ô∏è Possible but difficult</td></tr>
<tr><td><strong>Audit Trails</strong></td><td>‚úÖ Automatic</td><td>‚ùå Manual logging</td><td>‚ö†Ô∏è Basic signing only</td></tr>
<tr><td><strong>Schema Validation</strong></td><td>‚úÖ JSON Schema</td><td>‚ùå Custom validation</td><td>‚ùå No structure</td></tr>
<tr><td><strong>Versioning</strong></td><td>‚úÖ Built-in</td><td>‚ùå Manual versioning</td><td>‚ùå Not supported</td></tr>
<tr><td><strong>Cross-Platform</strong></td><td>‚úÖ JSON everywhere</td><td>‚ö†Ô∏è Protocol dependent</td><td>‚ö†Ô∏è Format dependent</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use-jacs-1"><a class="header" href="#when-to-use-jacs-1">When to Use JACS</a></h2>
<p>‚úÖ <strong>Perfect for:</strong></p>
<ul>
<li>Multi-agent AI systems</li>
<li>Task delegation and tracking</li>
<li>Audit trail requirements</li>
<li>Cross-organization AI collaboration</li>
<li>Compliance-critical AI applications</li>
<li>Research environments with multiple AI models</li>
</ul>
<p>‚ö†Ô∏è <strong>Consider alternatives for:</strong></p>
<ul>
<li>Simple single-agent systems</li>
<li>Real-time streaming data</li>
<li>High-frequency micro-transactions</li>
<li>Systems where trust is not a concern</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Ready to dive deeper? Continue with:</p>
<ul>
<li><strong><a href="getting-started/concepts.html">Core Concepts</a></strong> - Learn about agents, documents, and agreements</li>
<li><strong><a href="getting-started/quick-start.html">Quick Start</a></strong> - Get hands-on experience</li>
<li><strong>Implementation guides</strong> for <a href="getting-started/../rust/installation.html">Rust</a>, <a href="getting-started/../nodejs/installation.html">Node.js</a>, or <a href="getting-started/../python/installation.html">Python</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Understanding JACS requires familiarity with several key concepts that work together to create a secure, verifiable communication framework for AI agents.</p>
<h2 id="agents-1"><a class="header" href="#agents-1">Agents</a></h2>
<p>An <strong>Agent</strong> is the fundamental entity in JACS - an autonomous participant that can create, sign, and verify documents.</p>
<h3 id="agent-identity"><a class="header" href="#agent-identity">Agent Identity</a></h3>
<pre><code class="language-json">{
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "123e4567-e89b-12d3-a456-426614174000",
  "jacsType": "agent",
  "name": "Content Creation Agent",
  "description": "Specialized in creating marketing content"
}
</code></pre>
<p><strong>Key Properties:</strong></p>
<ul>
<li><strong>jacsId</strong>: Permanent UUID identifying the agent</li>
<li><strong>jacsVersion</strong>: UUID that changes with each update</li>
<li><strong>Cryptographic Keys</strong>: Ed25519, RSA, or post-quantum key pairs</li>
<li><strong>Services</strong>: Capabilities the agent offers</li>
<li><strong>Contacts</strong>: How to reach the agent</li>
</ul>
<h3 id="agent-lifecycle"><a class="header" href="#agent-lifecycle">Agent Lifecycle</a></h3>
<ol>
<li><strong>Creation</strong>: Generate keys and initial agent document</li>
<li><strong>Registration</strong>: Store public keys for verification</li>
<li><strong>Operation</strong>: Create and sign documents</li>
<li><strong>Updates</strong>: Version changes while maintaining identity</li>
<li><strong>Verification</strong>: Other agents validate signatures</li>
</ol>
<h3 id="verification-load-vs-verify_standalone"><a class="header" href="#verification-load-vs-verify_standalone">Verification: load() vs verify_standalone()</a></h3>
<p>When <strong>consuming</strong> signed documents, you can verify in two ways:</p>
<ul>
<li>
<p><strong>With a loaded agent</strong> (<code>load(config)</code> first): Call <code>verify(signedDocument)</code>. The loaded agent uses its config (trust store, key resolution) to resolve the signer‚Äôs public key and verify the signature. Use this when your process already has a JACS config (e.g. it also signs) or when you want to use a specific key directory and resolution order.</p>
</li>
<li>
<p><strong>Without loading an agent</strong> (one-off verification): Call <code>verify_standalone(signedDocument, options)</code> (or the language equivalent: <code>verifyStandalone</code>, <code>VerifyStandalone</code>). This verifies the document using only the options you pass (e.g. <code>keyResolution</code>, <code>keyDirectory</code>). No config file or persistent agent state is required. Use this in lightweight services that only need to verify incoming documents.</p>
</li>
</ul>
<h2 id="documents-1"><a class="header" href="#documents-1">Documents</a></h2>
<p>A <strong>Document</strong> is any JSON object that follows JACS conventions for identity, versioning, and cryptographic integrity.</p>
<h3 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h3>
<pre><code class="language-json">{
  "jacsId": "doc-uuid-here",
  "jacsVersion": "version-uuid-here",
  "jacsType": "task",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsPreviousVersion": "previous-version-uuid",
  
  "title": "Analyze Q4 Sales Data",
  "description": "Generate insights from sales data",
  
  "jacsSha256": "hash-of-document-content",
  "jacsSignature": {
    "agentID": "agent-uuid",
    "agentVersion": "agent-version-uuid",
    "signature": "base64-signature",
    "signingAlgorithm": "ring-Ed25519",
    "publicKeyHash": "hash-of-public-key",
    "date": "2024-01-15T10:30:00Z",
    "fields": ["jacsId", "title", "description"]
  }
}
</code></pre>
<h3 id="required-jacs-fields"><a class="header" href="#required-jacs-fields">Required JACS Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Purpose</th><th>Example</th></tr></thead><tbody>
<tr><td><code>$schema</code></td><td>JSON Schema reference</td><td>URL to schema</td></tr>
<tr><td><code>jacsId</code></td><td>Permanent document identifier</td><td>UUID v4</td></tr>
<tr><td><code>jacsVersion</code></td><td>Version identifier (changes on update)</td><td>UUID v4</td></tr>
<tr><td><code>jacsType</code></td><td>Document type</td><td>"agent", "task", "message"</td></tr>
<tr><td><code>jacsVersionDate</code></td><td>When this version was created</td><td>RFC 3339 timestamp</td></tr>
<tr><td><code>jacsOriginalVersion</code></td><td>Original version UUID</td><td>UUID v4</td></tr>
<tr><td><code>jacsOriginalDate</code></td><td>Original creation timestamp</td><td>RFC 3339 timestamp</td></tr>
<tr><td><code>jacsLevel</code></td><td>Data level/intent</td><td>"raw", "config", "artifact", "derived"</td></tr>
<tr><td><code>jacsPreviousVersion</code></td><td>Previous version UUID (optional)</td><td>UUID v4 or null</td></tr>
<tr><td><code>jacsSha256</code></td><td>Hash of document content</td><td>SHA-256 hex string</td></tr>
<tr><td><code>jacsSignature</code></td><td>Cryptographic signature</td><td>Signature object</td></tr>
</tbody></table>
</div>
<h3 id="document-types"><a class="header" href="#document-types">Document Types</a></h3>
<p><strong>Agent Documents</strong></p>
<ul>
<li>Define agent identity and capabilities</li>
<li>Contain service definitions and contact information</li>
<li>Self-signed by the agent</li>
</ul>
<p><strong>Task Documents</strong></p>
<ul>
<li>Describe work to be performed</li>
<li>Include success/failure criteria</li>
<li>Can be delegated between agents</li>
</ul>
<p><strong>Message Documents</strong></p>
<ul>
<li>General communication between agents</li>
<li>Can include attachments and metadata</li>
<li>Support threaded conversations</li>
</ul>
<p><strong>Agreement Documents</strong></p>
<ul>
<li>Multi-party consent mechanisms</li>
<li>Track required and actual signatures</li>
<li>Enforce completion before proceeding</li>
</ul>
<h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<p>Tasks represent work that can be delegated, tracked, and verified between agents.</p>
<h3 id="task-structure"><a class="header" href="#task-structure">Task Structure</a></h3>
<pre><code class="language-json">{
  "jacsType": "task",
  "title": "Generate Marketing Copy",
  "description": "Create compelling copy for product launch",
  
  "actions": [
    {
      "id": "research",
      "name": "Research competitors",
      "description": "Analyze competitor messaging",
      "success": "Complete competitive analysis report",
      "failure": "Unable to access competitor data"
    }
  ],
  
  "jacsTaskCustomer": {
    "agentID": "customer-agent-uuid",
    "signature": "customer-signature"
  }
}
</code></pre>
<h3 id="task-lifecycle"><a class="header" href="#task-lifecycle">Task Lifecycle</a></h3>
<ol>
<li><strong>Creation</strong>: Customer agent creates task with requirements</li>
<li><strong>Delegation</strong>: Task sent to service provider agent</li>
<li><strong>Agreement</strong>: Provider signs agreement to accept task</li>
<li><strong>Execution</strong>: Provider performs the work</li>
<li><strong>Completion</strong>: Provider creates completion document</li>
<li><strong>Verification</strong>: Customer verifies and accepts results</li>
</ol>
<h3 id="task-components"><a class="header" href="#task-components">Task Components</a></h3>
<p><strong>Actions</strong>: Individual steps within a task</p>
<ul>
<li><strong>id</strong>: Unique identifier within the task</li>
<li><strong>name</strong>: Human-readable action name</li>
<li><strong>description</strong>: Detailed requirements</li>
<li><strong>success</strong>: Definition of successful completion</li>
<li><strong>failure</strong>: What constitutes failure</li>
</ul>
<p><strong>Services</strong>: Required capabilities</p>
<ul>
<li><strong>type</strong>: Service category</li>
<li><strong>requirements</strong>: Specific needs</li>
<li><strong>constraints</strong>: Limitations or restrictions</li>
</ul>
<h2 id="agreements-1"><a class="header" href="#agreements-1">Agreements</a></h2>
<p>Agreements enable multi-party consent and coordination between agents.</p>
<h3 id="agreement-structure"><a class="header" href="#agreement-structure">Agreement Structure</a></h3>
<pre><code class="language-json">{
  "jacsType": "agreement",
  "title": "Task Acceptance Agreement",
  "question": "Do you agree to complete the marketing copy task?",
  "context": "Task ID: abc123, Deadline: 2024-01-20",
  
  "agents": [
    "agent-1-uuid",
    "agent-2-uuid",
    "agent-3-uuid"
  ],
  
  "jacsAgreement": {
    "agent-1-uuid": {
      "agentID": "agent-1-uuid",
      "signature": "base64-signature",
      "date": "2024-01-15T10:30:00Z"
    },
    "agent-2-uuid": {
      "agentID": "agent-2-uuid", 
      "signature": "base64-signature",
      "date": "2024-01-15T11:15:00Z"
    }
    // agent-3-uuid has not signed yet
  },
  
  "jacsAgreementHash": "hash-of-agreement-content"
}
</code></pre>
<h3 id="agreement-process"><a class="header" href="#agreement-process">Agreement Process</a></h3>
<ol>
<li><strong>Creation</strong>: Initial agent creates agreement with required participants</li>
<li><strong>Distribution</strong>: Agreement sent to all required agents</li>
<li><strong>Review</strong>: Each agent reviews terms and conditions</li>
<li><strong>Signing</strong>: Agents add their signatures if they consent</li>
<li><strong>Completion</strong>: Agreement becomes binding when all parties have signed</li>
<li><strong>Verification</strong>: Any party can verify all signatures</li>
</ol>
<h3 id="agreement-types"><a class="header" href="#agreement-types">Agreement Types</a></h3>
<p><strong>Task Agreements</strong>: Consent to perform specific work
<strong>Service Agreements</strong>: Long-term service provision contracts<br />
<strong>Data Sharing Agreements</strong>: Permission to access or use data
<strong>Update Agreements</strong>: Consent to system or process changes</p>
<h2 id="cryptographic-security"><a class="header" href="#cryptographic-security">Cryptographic Security</a></h2>
<p>JACS uses industry-standard cryptographic primitives for security.</p>
<h3 id="supported-algorithms"><a class="header" href="#supported-algorithms">Supported Algorithms</a></h3>
<p><strong>Current Standards</strong></p>
<ul>
<li><strong>ring-Ed25519</strong>: Fast elliptic curve signatures using the ring library (recommended)</li>
<li><strong>RSA-PSS</strong>: Traditional RSA with probabilistic signature scheme</li>
</ul>
<p><strong>Post-Quantum</strong></p>
<ul>
<li><strong>pq-dilithium</strong>: NIST-standardized post-quantum signatures</li>
</ul>
<h3 id="signature-process"><a class="header" href="#signature-process">Signature Process</a></h3>
<ol>
<li><strong>Content Extraction</strong>: Specific fields are extracted for signing</li>
<li><strong>Canonicalization</strong>: Fields are sorted and formatted consistently</li>
<li><strong>Hashing</strong>: SHA-256 hash of the canonical content</li>
<li><strong>Signing</strong>: Private key signs the hash</li>
<li><strong>Verification</strong>: Public key verifies the signature</li>
</ol>
<h3 id="key-management"><a class="header" href="#key-management">Key Management</a></h3>
<ul>
<li><strong>Agent Keys</strong>: Each agent has a unique key pair</li>
<li><strong>Public Key Distribution</strong>: Public keys shared through secure channels</li>
<li><strong>Key Rotation</strong>: Agents can update keys while maintaining identity</li>
<li><strong>Key Verification</strong>: Public key hashes ensure integrity</li>
</ul>
<h2 id="versioning-and-audit-trails"><a class="header" href="#versioning-and-audit-trails">Versioning and Audit Trails</a></h2>
<p>JACS provides comprehensive versioning for tracking document evolution.</p>
<h3 id="version-management"><a class="header" href="#version-management">Version Management</a></h3>
<ul>
<li><strong>Immutable IDs</strong>: <code>jacsId</code> never changes for a document</li>
<li><strong>Version IDs</strong>: <code>jacsVersion</code> changes with each update</li>
<li><strong>Previous Versions</strong>: <code>jacsPreviousVersion</code> creates a chain</li>
<li><strong>Timestamps</strong>: <code>jacsVersionDate</code> provides chronological order</li>
</ul>
<h3 id="audit-trail-benefits"><a class="header" href="#audit-trail-benefits">Audit Trail Benefits</a></h3>
<ul>
<li><strong>Complete History</strong>: Track all changes to any document</li>
<li><strong>Attribution</strong>: Know exactly who made each change</li>
<li><strong>Verification</strong>: Cryptographic proof of authenticity</li>
<li><strong>Compliance</strong>: Meet regulatory audit requirements</li>
</ul>
<h2 id="storage-and-transport"><a class="header" href="#storage-and-transport">Storage and Transport</a></h2>
<p>JACS documents are designed to be storage and transport agnostic.</p>
<h3 id="storage-options"><a class="header" href="#storage-options">Storage Options</a></h3>
<ul>
<li><strong>File System</strong>: Simple JSON files</li>
<li><strong>Databases</strong>: Store as JSON/JSONB fields</li>
<li><strong>Object Storage</strong>: S3, Azure Blob, Google Cloud Storage</li>
<li><strong>Version Control</strong>: Git repositories for change tracking</li>
</ul>
<h3 id="transport-mechanisms"><a class="header" href="#transport-mechanisms">Transport Mechanisms</a></h3>
<ul>
<li><strong>HTTP APIs</strong>: RESTful or GraphQL endpoints</li>
<li><strong>Message Queues</strong>: RabbitMQ, Kafka, SQS</li>
<li><strong>Email</strong>: Documents as attachments</li>
<li><strong>Direct Transfer</strong>: USB drives, file sharing</li>
</ul>
<h3 id="format-compatibility"><a class="header" href="#format-compatibility">Format Compatibility</a></h3>
<ul>
<li><strong>JSON</strong>: Universal compatibility across all systems</li>
<li><strong>Schema Validation</strong>: Ensures consistent structure</li>
<li><strong>Self-Contained</strong>: All necessary information in the document</li>
<li><strong>Human Readable</strong>: Can be inspected and debugged easily</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand the core concepts:</p>
<ol>
<li><strong><a href="getting-started/quick-start.html">Quick Start</a></strong> - Try JACS hands-on</li>
<li><strong>Choose Implementation</strong>:
<ul>
<li><a href="getting-started/../rust/installation.html">Rust CLI</a> for command-line usage</li>
<li><a href="getting-started/../nodejs/installation.html">Node.js</a> for web applications</li>
<li><a href="getting-started/../python/installation.html">Python</a> for AI/ML workflows</li>
</ul>
</li>
<li><strong><a href="getting-started/../examples/cli.html">Examples</a></strong> - See real-world usage patterns</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<p>Get signing and verifying in under a minute. No config files, no setup.</p>
<h2 id="zero-config-quick-start"><a class="header" href="#zero-config-quick-start">Zero-Config Quick Start</a></h2>
<p><code>quickstart()</code> creates an ephemeral agent with keys in memory. One call and you're signing.</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="tab-python" name="tab-group" checked>
<label for="tab-python">Python</label>
<div class="content">
<pre><code class="language-bash">pip install jacs
</code></pre>
<pre><code class="language-python">import jacs.simple as jacs

jacs.quickstart()
signed = jacs.sign_message({"action": "approve", "amount": 100})
result = jacs.verify(signed.raw)
print(f"Valid: {result.valid}, Signer: {result.signer_id}")
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="tab-nodejs" name="tab-group">
<label for="tab-nodejs">Node.js</label>
<div class="content">
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

jacs.quickstart();
const signed = jacs.signMessage({ action: 'approve', amount: 100 });
const result = jacs.verify(signed.raw);
console.log(`Valid: ${result.valid}, Signer: ${result.signerId}`);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="tab-rust" name="tab-group">
<label for="tab-rust">Rust CLI</label>
<div class="content">
<pre><code class="language-bash">cargo install jacs --features cli
</code></pre>
<pre><code class="language-bash"># Info mode -- prints agent ID and algorithm
jacs quickstart

# Sign JSON from stdin
echo '{"action":"approve"}' | jacs quickstart --sign

# Sign a file
jacs quickstart --sign --file mydata.json
</code></pre>
</div>
</div>
</div>
<p>Pass <code>algorithm="ring-Ed25519"</code> (or <code>{ algorithm: 'ring-Ed25519' }</code> in JS, <code>--algorithm ring-Ed25519</code> in CLI) to override the default (<code>pq2025</code>).</p>
<h2 id="advanced-persistent-agent-setup"><a class="header" href="#advanced-persistent-agent-setup">Advanced: Persistent Agent Setup</a></h2>
<p>For production use, create a persistent agent with keys on disk. This requires a config file and <code>JACS_PRIVATE_KEY_PASSWORD</code> environment variable.</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="adv-rust" name="adv-group" checked>
<label for="adv-rust">Rust CLI</label>
<div class="content">
<h3 id="install"><a class="header" href="#install">Install</a></h3>
<pre><code class="language-bash">cargo install jacs --features cli
</code></pre>
<h3 id="initialize"><a class="header" href="#initialize">Initialize</a></h3>
<pre><code class="language-bash"># Create configuration and agent in one step
jacs init

# Or step by step:
# 1. Create config
jacs config create
# 2. Create agent with keys
jacs agent create --create-keys true
# 3. Verify
jacs agent verify
</code></pre>
<h3 id="sign-a-document"><a class="header" href="#sign-a-document">Sign a document</a></h3>
<pre><code class="language-bash">jacs document create -f mydata.json
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="adv-nodejs" name="adv-group">
<label for="adv-nodejs">Node.js</label>
<div class="content">
<h3 id="install-1"><a class="header" href="#install-1">Install</a></h3>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
<h3 id="load-and-use"><a class="header" href="#load-and-use">Load and use</a></h3>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

// Load from config file
jacs.load('./jacs.config.json');

const signed = jacs.signMessage({ action: 'approve', amount: 100 });
const result = jacs.verify(signed.raw);
console.log(`Valid: ${result.valid}`);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="adv-python" name="adv-group">
<label for="adv-python">Python</label>
<div class="content">
<h3 id="install-2"><a class="header" href="#install-2">Install</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<h3 id="load-and-use-1"><a class="header" href="#load-and-use-1">Load and use</a></h3>
<pre><code class="language-python">import jacs.simple as jacs

# Load from config file
jacs.load("./jacs.config.json")

signed = jacs.sign_message({"action": "approve", "amount": 100})
result = jacs.verify(signed.raw)
print(f"Valid: {result.valid}")
</code></pre>
</div>
</div>
</div>
<h2 id="programmatic-agent-creation-v060"><a class="header" href="#programmatic-agent-creation-v060">Programmatic Agent Creation (v0.6.0+)</a></h2>
<p>For scripts, CI/CD, and server environments where you need <strong>persistent</strong> agents created programmatically (without interactive prompts), use <code>create()</code>. If you don't need persistence, <code>quickstart()</code> above is simpler.</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="prog-python" name="prog-group" checked>
<label for="prog-python">Python</label>
<div class="content">
<pre><code class="language-python">import jacs.simple as jacs

agent = jacs.create(
    name="my-agent",
    password="Str0ng-P@ssw0rd!",  # or set JACS_PRIVATE_KEY_PASSWORD
    algorithm="pq2025",
)
print(f"Agent: {agent.agent_id}")
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="prog-nodejs" name="prog-group">
<label for="prog-nodejs">Node.js</label>
<div class="content">
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

const agent = jacs.create({
  name: 'my-agent',
  password: process.env.JACS_PRIVATE_KEY_PASSWORD,
  algorithm: 'pq2025',
});
console.log(`Agent: ${agent.agentId}`);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="prog-go" name="prog-group">
<label for="prog-go">Go</label>
<div class="content">
<pre><code class="language-go">info, err := jacs.Create("my-agent", &amp;jacs.CreateAgentOptions{
    Password:  os.Getenv("JACS_PRIVATE_KEY_PASSWORD"),
    Algorithm: "pq2025",
})
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="prog-rust" name="prog-group">
<label for="prog-rust">Rust</label>
<div class="content">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::simple::{CreateAgentParams, SimpleAgent};

let params = CreateAgentParams {
    name: "my-agent".into(),
    password: std::env::var("JACS_PRIVATE_KEY_PASSWORD").unwrap(),
    algorithm: "pq2025".into(),
    ..Default::default()
};
let (agent, info) = SimpleAgent::create_with_params(params)?;
<span class="boring">}</span></code></pre></pre>
</div>
</div>
</div>
<p><strong>Password requirements</strong>: At least 8 characters, with uppercase, lowercase, a digit, and a special character.</p>
<p><strong>Algorithm note</strong>: <code>pq-dilithium</code> is deprecated in v0.6.0. Use <code>pq2025</code> (ML-DSA-87, FIPS-204) instead.</p>
<h2 id="understanding-what-happened"><a class="header" href="#understanding-what-happened">Understanding What Happened</a></h2>
<p>When you completed the quick start, several important things occurred:</p>
<h3 id="1-agent-creation"><a class="header" href="#1-agent-creation">1. <strong>Agent Creation</strong></a></h3>
<ul>
<li>A unique identity (UUID) was generated for your agent</li>
<li>Cryptographic key pair was created for signing</li>
<li>Agent document was created and self-signed</li>
<li>Public key was stored for verification</li>
</ul>
<h3 id="2-configuration-setup"><a class="header" href="#2-configuration-setup">2. <strong>Configuration Setup</strong></a></h3>
<ul>
<li>Storage directories were configured</li>
<li>Cryptographic algorithm was selected</li>
<li>Agent identity was linked to configuration</li>
</ul>
<h3 id="3-task-creation"><a class="header" href="#3-task-creation">3. <strong>Task Creation</strong></a></h3>
<ul>
<li>Task document was structured according to JACS schema</li>
<li>Document was signed with your agent's private key</li>
<li>SHA-256 hash was calculated for integrity</li>
<li>Signature metadata was embedded in the document</li>
</ul>
<h2 id="verify-everything-works"><a class="header" href="#verify-everything-works">Verify Everything Works</a></h2>
<p>Let's verify that the documents are properly signed and can be validated:</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="verify-rust" name="verify-group" checked>
<label for="verify-rust">ü¶Ä Rust</label>
<div class="content">
<pre><code class="language-bash"># Verify agent signature
jacs agent verify

# Verify a specific document
jacs document verify -f ./jacs_data/[document-id].json

# Sign a document
jacs document sign -f ./jacs_data/[document-id].json
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="verify-nodejs" name="verify-group">
<label for="verify-nodejs">üü¢ Node.js</label>
<div class="content">
<pre><code class="language-javascript">// Verify agent signature
const isValid = await agent.verifyAgent();
console.log('Agent signature valid:', isValid);

// List all documents
const documents = await agent.listDocuments();
console.log('Documents:', documents.length);

// Verify task signature
const taskValid = await agent.verifyDocument(signedTask);
console.log('Task signature valid:', taskValid);

// Get document details
const taskDetails = await agent.getDocument(signedTask.jacsId);
console.log('Task details:', taskDetails);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="verify-python" name="verify-group">
<label for="verify-python">üêç Python</label>
<div class="content">
<pre><code class="language-python"># Verify agent signature
is_valid = agent.verify_agent()
print(f'Agent signature valid: {is_valid}')

# List all documents
documents = agent.list_documents()
print(f'Documents: {len(documents)}')

# Verify task signature  
task_valid = agent.verify_document(signed_task)
print(f'Task signature valid: {task_valid}')

# Get document details
task_details = agent.get_document(signed_task["jacsId"])
print(f'Task details: {task_details}')
</code></pre>
</div>
</div>
</div>
<h2 id="next-steps-multi-agent-workflow"><a class="header" href="#next-steps-multi-agent-workflow">Next Steps: Multi-Agent Workflow</a></h2>
<p>Now let's create a second agent and demonstrate inter-agent communication:</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="multi-rust" name="multi-group" checked>
<label for="multi-rust">ü¶Ä Rust</label>
<div class="content">
<pre><code class="language-bash"># Create a second agent configuration
cp jacs.config.json reviewer.config.json
# Edit reviewer.config.json to set jacs_agent_id_and_version to null

# Create reviewer agent (uses JACS_CONFIG_PATH environment variable)
JACS_CONFIG_PATH=./reviewer.config.json jacs agent create --create-keys true

# Create an agreement on a document
jacs agreement create -f ./document.json \
  --agents [agent-1-id],[agent-2-id] \
  --question "Do you agree to collaborate on this content task?"

# Sign the agreement as first agent
jacs agreement sign -f ./document.json

# Sign as second agent (using reviewer config)
JACS_CONFIG_PATH=./reviewer.config.json jacs agreement sign -f ./document.json

# Verify agreement is complete
jacs agreement check -f ./document.json
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="multi-nodejs" name="multi-group">
<label for="multi-nodejs">üü¢ Node.js</label>
<div class="content">
<pre><code class="language-javascript">// Create second agent with separate config file
const reviewerConfig = { ...config };
reviewerConfig.jacs_agent_id_and_version = null;

fs.writeFileSync('./reviewer.config.json', JSON.stringify(reviewerConfig, null, 2));

const reviewer = new JacsAgent();
reviewer.load('./reviewer.config.json');
await reviewer.generateKeys();

const reviewerDoc = await reviewer.createAgent({
  name: "Content Reviewer Bot",
  description: "AI agent specialized in content review"
});

// Create agreement between agents
const agreement = {
  title: "Content Collaboration Agreement",
  question: "Do you agree to collaborate on this content task?",
  context: `Task: ${signedTask.jacsId}`,
  agents: [agentDoc.jacsId, reviewerDoc.jacsId]
};

const signedAgreement = await agent.createAgreement(agreement);

// Both agents sign the agreement
await agent.signAgreement(signedAgreement.jacsId);
await reviewer.signAgreement(signedAgreement.jacsId);

// Verify all signatures
const agreementValid = await agent.verifyAgreement(signedAgreement.jacsId);
console.log('Agreement complete:', agreementValid);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="multi-python" name="multi-group">
<label for="multi-python">üêç Python</label>
<div class="content">
<pre><code class="language-python"># Create second agent with separate config file
reviewer_config = config.copy()
reviewer_config["jacs_agent_id_and_version"] = None

with open('reviewer.config.json', 'w') as f:
    json.dump(reviewer_config, f, indent=2)

reviewer = jacs.JacsAgent()
reviewer.load("./reviewer.config.json")
reviewer.generate_keys()

reviewer_doc = reviewer.create_agent({
    "name": "Content Reviewer Bot", 
    "description": "AI agent specialized in content review"
})

# Create agreement between agents
agreement = {
    "title": "Content Collaboration Agreement",
    "question": "Do you agree to collaborate on this content task?",
    "context": f"Task: {signed_task['jacsId']}",
    "agents": [agent_doc["jacsId"], reviewer_doc["jacsId"]]
}

signed_agreement = agent.create_agreement(agreement)

# Both agents sign the agreement
agent.sign_agreement(signed_agreement["jacsId"])
reviewer.sign_agreement(signed_agreement["jacsId"])

# Verify all signatures
agreement_valid = agent.verify_agreement(signed_agreement["jacsId"])
print(f'Agreement complete: {agreement_valid}')
</code></pre>
</div>
</div>
</div>
<h2 id="what-youve-accomplished"><a class="header" href="#what-youve-accomplished">What You've Accomplished</a></h2>
<p>Congratulations! You've successfully:</p>
<p>‚úÖ <strong>Created JACS agents</strong> with cryptographic identities
‚úÖ <strong>Generated and signed documents</strong> with verifiable integrity<br />
‚úÖ <strong>Established multi-agent agreements</strong> with cryptographic consent
‚úÖ <strong>Verified signatures</strong> and document authenticity
‚úÖ <strong>Created an audit trail</strong> of all interactions</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li><strong>Everything is verifiable</strong>: All documents have cryptographic signatures</li>
<li><strong>Agents are autonomous</strong>: Each has its own identity and keys</li>
<li><strong>Agreements enable trust</strong>: Multi-party consent before proceeding</li>
<li><strong>Audit trails are automatic</strong>: Complete history of all interactions</li>
<li><strong>JSON is universal</strong>: Documents work everywhere</li>
</ul>
<h2 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to Go Next</a></h2>
<p>Now that you have the basics working:</p>
<ol>
<li><strong><a href="getting-started/../rust/library.html">Rust Deep Dive</a></strong> - Learn the full Rust API</li>
<li><strong><a href="getting-started/../nodejs/mcp.html">Node.js Integration</a></strong> - Add MCP support</li>
<li><strong><a href="getting-started/../python/mcp.html">Python MCP</a></strong> - Build authenticated MCP servers</li>
<li><strong><a href="getting-started/../advanced/security.html">Production Security</a></strong> - Harden runtime settings and key management</li>
<li><strong><a href="getting-started/../examples/integrations.html">Real Examples</a></strong> - See production patterns</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p><strong>Agent creation fails</strong>: Check that the data and key directories exist and are writable
<strong>Signature verification fails</strong>: Ensure public keys are properly stored and accessible
<strong>Agreement signing fails</strong>: Verify all agent IDs are correct and agents exist
<strong>Documents not found</strong>: Check the data directory configuration</p>
<p>Need help? Check the <a href="https://github.com/HumanAssisted/JACS/issues">GitHub issues</a> or review the detailed implementation guides.</p>
<style>
.tabs {
  display: flex;
  flex-wrap: wrap;
  max-width: 100%;
  font-family: sans-serif;
}

.tab {
  order: 1;
  flex-grow: 1;
}

.tab input[type="radio"] {
  display: none;
}

.tab label {
  display: block;
  padding: 1em;
  background: #f0f0f0;
  color: #666;
  border: 1px solid #ddd;
  cursor: pointer;
  margin-bottom: -1px;
}

.tab label:hover {
  background: #e0e0e0;
}

.tab input:checked + label {
  background: #007acc;
  color: white;
}

.tab .content {
  order: 99;
  flex-grow: 1;
  width: 100%;
  display: none;
  padding: 1em;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
}

.tab input:checked ~ .content {
  display: block;
}
</style> 
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<p>JACS supports a wide range of workflows: proving where data came from, protecting who runs an agent, registering with a platform, enforcing provenance in your app, and proving that a specific agent sent a message. This page summarizes five common use cases; each links to the full fictional scenario and technical flow in the repository.</p>
<p>For detailed narratives (scenario, technical flow, outcome), see <strong><a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md">USECASES.md</a></strong> in the JACS repo.</p>
<hr />
<h2 id="1-verifying-that-json-came-from-a-specific-program"><a class="header" href="#1-verifying-that-json-came-from-a-specific-program">1. Verifying that JSON came from a specific program</a></h2>
<p><strong>Summary.</strong> You have a pipeline or service that emits JSON (configs, reports, compliance data). Consumers need to trust that a given file or payload was produced by that program and not modified. With JACS, the program has one agent identity: it signs each artifact with <code>sign_message</code> or <code>sign_file</code> at emission; consumers verify with <code>verify()</code> or <code>verify_by_id()</code> (local storage), or use <code>verify_standalone()</code> for one-off verification without loading an agent. No central server is required.</p>
<p>See <a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md#1-verifying-that-json-files-came-from-a-specific-program">USECASES.md ¬ß 1</a> for the full scenario.</p>
<hr />
<h2 id="2-protecting-your-agents-identity-on-the-internet"><a class="header" href="#2-protecting-your-agents-identity-on-the-internet">2. Protecting your agent's identity on the internet</a></h2>
<p><strong>Summary.</strong> You run a public-facing agent and want its messages to be verifiable (signed) without exposing who operates it. JACS supports this by keeping signing internal-only and publishing only the public key (via DNS and optionally HAI). Recipients use <code>verify()</code> (core JACS) or <code>jacs_verify_auto</code> (OpenClaw/moltyjacs) to confirm origin and integrity; they never learn who runs the agent.</p>
<p>See <a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md#2-protecting-your-agents-identity-on-the-internet">USECASES.md ¬ß 2</a> for the full scenario.</p>
<hr />
<h2 id="3-registering-and-testing-your-agent-on-haiai"><a class="header" href="#3-registering-and-testing-your-agent-on-haiai">3. Registering and testing your agent on HAI.ai</a></h2>
<p><strong>Summary.</strong> You want to register your JACS agent with HAI.ai for attestation and discoverability, and to test verification before going live. Use the HAI registration flow: from Node <code>registerWithHai()</code> (@hai.ai/jacs), from Go <code>RegisterWithHai()</code> (jacsgo), from Python <code>register_with_hai</code> / <code>register_new_agent()</code> (jacspy), or <code>openclaw jacs register</code> (moltyjacs). Set <code>HAI_API_KEY</code>, then check attestation and run verification with <code>JACS_KEY_RESOLUTION=local,hai</code>.</p>
<p>See <a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md#3-registering-and-testing-your-agent-on-haiai">USECASES.md ¬ß 3</a> for the full scenario.</p>
<hr />
<h2 id="4-a-go-node-or-python-agent-with-strong-data-provenance"><a class="header" href="#4-a-go-node-or-python-agent-with-strong-data-provenance">4. A Go, Node, or Python agent with strong data provenance</a></h2>
<p><strong>Summary.</strong> Your agent (in Go, Node, or Python) must prove the origin and integrity of every important output for compliance. Use the simple API in jacspy, jacsnpm, or jacsgo: <code>load(config)</code>, <code>sign_message(payload)</code> for each output, and <code>verify(signed.raw)</code> (or <code>verify_standalone()</code> for one-off verification without agent setup) wherever you consume signed data. Keys stay local; use <code>JACS_KEY_RESOLUTION</code> for external signers or air-gapped use.</p>
<p>See <a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md#4-a-go-node-or-python-agent-with-strong-data-provenance">USECASES.md ¬ß 4</a> for the full scenario.</p>
<hr />
<h2 id="5-openclaw-moltyjacs-proving-your-agent-sent-a-message"><a class="header" href="#5-openclaw-moltyjacs-proving-your-agent-sent-a-message">5. OpenClaw (moltyjacs): proving your agent sent a message</a></h2>
<p><strong>Summary.</strong> You use OpenClaw with the moltyjacs plugin and need cryptographic proof that a specific message came from your agent. The agent signs outbound messages with <code>jacs_sign</code>; the recipient verifies with <code>jacs_verify_auto</code>. The signature travels with the message; no custom PKI is required.</p>
<p>See <a href="https://github.com/HumanAssisted/JACS/blob/main/USECASES.md#5-openclaw-moltyjacs-proving-your-agent-actually-sent-a-message">USECASES.md ¬ß 5</a> for the full scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers installing the JACS Rust CLI and library.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Rust</strong>: Version 1.93 or later (Edition 2024)</li>
<li><strong>Cargo</strong>: Included with Rust installation</li>
</ul>
<h3 id="verify-rust-version"><a class="header" href="#verify-rust-version">Verify Rust Version</a></h3>
<pre><code class="language-bash">rustc --version
# Should show rustc 1.93.0 or later
</code></pre>
<p>If you need to update Rust:</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<h2 id="installing-the-cli"><a class="header" href="#installing-the-cli">Installing the CLI</a></h2>
<h3 id="from-cratesio-recommended"><a class="header" href="#from-cratesio-recommended">From crates.io (Recommended)</a></h3>
<pre><code class="language-bash">cargo install jacs --features cli
</code></pre>
<h3 id="from-source"><a class="header" href="#from-source">From Source</a></h3>
<pre><code class="language-bash">git clone https://github.com/HumanAssisted/JACS
cd JACS/jacs
cargo install --path . --features cli
</code></pre>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<pre><code class="language-bash">jacs --help
</code></pre>
<h2 id="using-as-a-library"><a class="header" href="#using-as-a-library">Using as a Library</a></h2>
<p>Add JACS to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
jacs = "0.3"
</code></pre>
<h3 id="with-optional-features"><a class="header" href="#with-optional-features">With Optional Features</a></h3>
<p>JACS supports several optional features for observability and integrations:</p>
<pre><code class="language-toml">[dependencies]
# Basic library usage
jacs = "0.3"

# With OpenTelemetry logging
jacs = { version = "0.3", features = ["otlp-logs"] }

# With OpenTelemetry metrics
jacs = { version = "0.3", features = ["otlp-metrics"] }

# With OpenTelemetry tracing
jacs = { version = "0.3", features = ["otlp-tracing"] }

# With all observability features
jacs = { version = "0.3", features = ["otlp-logs", "otlp-metrics", "otlp-tracing"] }
</code></pre>
<h3 id="available-features"><a class="header" href="#available-features">Available Features</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cli</code></td><td>Enables CLI binary build with clap and ratatui</td></tr>
<tr><td><code>otlp-logs</code></td><td>OpenTelemetry Protocol logging backend</td></tr>
<tr><td><code>otlp-metrics</code></td><td>OpenTelemetry Protocol metrics backend</td></tr>
<tr><td><code>otlp-tracing</code></td><td>OpenTelemetry Protocol distributed tracing</td></tr>
<tr><td><code>observability-convenience</code></td><td>Helper wrappers for metrics and logging</td></tr>
<tr><td><code>mcp-server</code></td><td>Model Context Protocol server integration surface</td></tr>
</tbody></table>
</div>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>JACS supports the following platforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Architecture</th><th>Support</th></tr></thead><tbody>
<tr><td>Linux</td><td>x86_64, aarch64</td><td>Full support</td></tr>
<tr><td>macOS</td><td>x86_64, aarch64</td><td>Full support</td></tr>
<tr><td>Windows</td><td>x86_64</td><td>Full support</td></tr>
<tr><td>WebAssembly</td><td>wasm32</td><td>Partial (no post-quantum crypto, limited storage)</td></tr>
</tbody></table>
</div>
<h3 id="webassembly-notes"><a class="header" href="#webassembly-notes">WebAssembly Notes</a></h3>
<p>When targeting WebAssembly, some features are unavailable:</p>
<ul>
<li>Post-quantum cryptographic algorithms (pq-dilithium)</li>
<li>File system storage backend</li>
<li>HTTP-based remote operations</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>After installation, initialize JACS:</p>
<pre><code class="language-bash"># Create configuration and agent in one step
jacs init
</code></pre>
<p>This creates:</p>
<ul>
<li><code>~/.jacs/jacs.config.json</code> - Configuration file</li>
<li>Cryptographic keys for your agent</li>
<li>Initial agent document</li>
</ul>
<h3 id="manual-configuration"><a class="header" href="#manual-configuration">Manual Configuration</a></h3>
<p>Alternatively, create configuration and agent separately:</p>
<pre><code class="language-bash"># Create configuration only
jacs config create

# Create agent with keys
jacs agent create --create-keys true
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>JACS respects the following environment variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>JACS_CONFIG_PATH</code></td><td>Path to configuration file</td><td><code>./jacs.config.json</code></td></tr>
<tr><td><code>JACS_USE_SECURITY</code></td><td>Enable/disable security features</td><td><code>true</code></td></tr>
<tr><td><code>JACS_DATA_DIRECTORY</code></td><td>Directory for document storage</td><td><code>./jacs_data</code></td></tr>
<tr><td><code>JACS_KEY_DIRECTORY</code></td><td>Directory for cryptographic keys</td><td><code>./jacs_keys</code></td></tr>
<tr><td><code>JACS_DEFAULT_STORAGE</code></td><td>Storage backend (<code>fs</code>, <code>memory</code>)</td><td><code>fs</code></td></tr>
<tr><td><code>JACS_AGENT_KEY_ALGORITHM</code></td><td>Key algorithm (<code>ring-Ed25519</code>, <code>RSA-PSS</code>, <code>pq-dilithium</code>)</td><td><code>ring-Ed25519</code></td></tr>
</tbody></table>
</div>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="build-errors"><a class="header" href="#build-errors">Build Errors</a></h3>
<p><strong>"edition 2024 is required"</strong>
Update Rust to version 1.93 or later:</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<p><strong>Missing dependencies on Linux</strong>
Install build essentials:</p>
<pre><code class="language-bash"># Debian/Ubuntu
sudo apt-get install build-essential pkg-config libssl-dev

# Fedora
sudo dnf install gcc openssl-devel
</code></pre>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<p><strong>"Configuration file not found"</strong>
Run <code>jacs init</code> or set <code>JACS_CONFIG_PATH</code> environment variable.</p>
<p><strong>"Key directory does not exist"</strong>
Create the key directory or run <code>jacs init</code>:</p>
<pre><code class="language-bash">mkdir -p ./jacs_keys
</code></pre>
<p><strong>"Permission denied"</strong>
Ensure you have write permissions to the data and key directories.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="rust/cli.html">CLI Usage</a> - Learn CLI commands</li>
<li><a href="rust/agent.html">Creating an Agent</a> - Create your first agent</li>
<li><a href="rust/library.html">Rust Library API</a> - Use JACS as a library</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h1>
<p>The JACS CLI provides a command-line interface for managing agents, documents, tasks, and agreements.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<pre><code class="language-bash"># General help
jacs --help

# Command-specific help
jacs agent --help
jacs document --help
jacs task --help
</code></pre>
<h2 id="commands-overview"><a class="header" href="#commands-overview">Commands Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs init</code></td><td>Initialize JACS (create config and agent with keys)</td></tr>
<tr><td><code>jacs version</code></td><td>Print version information</td></tr>
<tr><td><code>jacs config</code></td><td>Manage configuration</td></tr>
<tr><td><code>jacs agent</code></td><td>Manage agents</td></tr>
<tr><td><code>jacs document</code></td><td>Manage documents</td></tr>
<tr><td><code>jacs task</code></td><td>Manage tasks</td></tr>
</tbody></table>
</div>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<h3 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h3>
<pre><code class="language-bash"># Initialize everything in one step
jacs init
</code></pre>
<p>This command:</p>
<ol>
<li>Creates a configuration file (<code>jacs.config.json</code>)</li>
<li>Generates cryptographic keys</li>
<li>Creates an initial agent document</li>
</ol>
<h2 id="configuration-commands"><a class="header" href="#configuration-commands">Configuration Commands</a></h2>
<h3 id="create-configuration"><a class="header" href="#create-configuration">Create Configuration</a></h3>
<pre><code class="language-bash">jacs config create
</code></pre>
<p>Creates a new <code>jacs.config.json</code> file in the current directory with default settings.</p>
<h3 id="read-configuration"><a class="header" href="#read-configuration">Read Configuration</a></h3>
<pre><code class="language-bash">jacs config read
</code></pre>
<p>Displays the current configuration, including values from both the config file and environment variables.</p>
<h2 id="agent-commands"><a class="header" href="#agent-commands">Agent Commands</a></h2>
<h3 id="create-agent"><a class="header" href="#create-agent">Create Agent</a></h3>
<pre><code class="language-bash">jacs agent create --create-keys true

# With a custom agent definition file
jacs agent create --create-keys true -f my-agent.json

# Without creating new keys (use existing)
jacs agent create --create-keys false -f my-agent.json
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--create-keys</code></td><td></td><td>Yes</td><td>Whether to create new cryptographic keys</td></tr>
<tr><td><code>-f</code></td><td></td><td>No</td><td>Path to JSON file with agent definition</td></tr>
</tbody></table>
</div>
<h3 id="verify-agent"><a class="header" href="#verify-agent">Verify Agent</a></h3>
<pre><code class="language-bash"># Verify agent from config
jacs agent verify

# Verify specific agent file
jacs agent verify -a ./path/to/agent.json

# With DNS validation options
jacs agent verify --require-dns
jacs agent verify --require-strict-dns
jacs agent verify --no-dns
jacs agent verify --ignore-dns
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-a</code></td><td><code>--agent-file</code></td><td>Path to agent file (optional)</td></tr>
<tr><td><code>--no-dns</code></td><td></td><td>Disable DNS validation</td></tr>
<tr><td><code>--require-dns</code></td><td></td><td>Require DNS validation (not strict)</td></tr>
<tr><td><code>--require-strict-dns</code></td><td></td><td>Require DNSSEC validation</td></tr>
<tr><td><code>--ignore-dns</code></td><td></td><td>Ignore DNS validation entirely</td></tr>
</tbody></table>
</div>
<h3 id="dns-commands"><a class="header" href="#dns-commands">DNS Commands</a></h3>
<pre><code class="language-bash"># Generate DNS TXT record commands for agent publishing
jacs agent dns --domain example.com --agent-id [uuid]

# With different output formats
jacs agent dns --domain example.com --encoding hex
jacs agent dns --domain example.com --provider aws

# With custom TTL
jacs agent dns --domain example.com --ttl 7200
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--domain</code></td><td></td><td>Domain for DNS record</td></tr>
<tr><td><code>--agent-id</code></td><td></td><td>Agent UUID (optional, uses config if not provided)</td></tr>
<tr><td><code>--ttl</code></td><td>3600</td><td>Time-to-live in seconds</td></tr>
<tr><td><code>--encoding</code></td><td>base64</td><td>Encoding format (base64, hex)</td></tr>
<tr><td><code>--provider</code></td><td>plain</td><td>Output format (plain, aws, azure, cloudflare)</td></tr>
</tbody></table>
</div>
<h3 id="lookup-agent"><a class="header" href="#lookup-agent">Lookup Agent</a></h3>
<pre><code class="language-bash"># Look up another agent's public key from their domain
jacs agent lookup agent.example.com

# With strict DNSSEC validation
jacs agent lookup agent.example.com --strict

# Skip DNS lookup
jacs agent lookup agent.example.com --no-dns
</code></pre>
<h2 id="task-commands"><a class="header" href="#task-commands">Task Commands</a></h2>
<h3 id="create-task"><a class="header" href="#create-task">Create Task</a></h3>
<pre><code class="language-bash">jacs task create -n "Task Name" -d "Task description"

# With optional agent file
jacs task create -n "Task Name" -d "Description" -a ./agent.json

# With input file
jacs task create -n "Task Name" -d "Description" -f ./task-details.json
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-n</code></td><td><code>--name</code></td><td>Yes</td><td>Name of the task</td></tr>
<tr><td><code>-d</code></td><td><code>--description</code></td><td>Yes</td><td>Description of the task</td></tr>
<tr><td><code>-a</code></td><td><code>--agent-file</code></td><td>No</td><td>Path to agent file</td></tr>
<tr><td><code>-f</code></td><td><code>--filename</code></td><td>No</td><td>Path to JSON file with additional task data</td></tr>
</tbody></table>
</div>
<h2 id="document-commands"><a class="header" href="#document-commands">Document Commands</a></h2>
<h3 id="create-document"><a class="header" href="#create-document">Create Document</a></h3>
<pre><code class="language-bash"># Create from a JSON file
jacs document create -f ./document.json

# Create from a directory of files
jacs document create -d ./documents/

# With custom schema
jacs document create -f ./document.json -s ./custom-schema.json

# With file attachments
jacs document create -f ./document.json --attach ./attachment.pdf

# Embed attachments in document
jacs document create -f ./document.json --attach ./files/ --embed true

# Output to specific file
jacs document create -f ./document.json -o ./output.json

# Print to stdout instead of saving
jacs document create -f ./document.json --no-save
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-f</code></td><td><code>--filename</code></td><td>Path to input JSON file</td></tr>
<tr><td><code>-d</code></td><td><code>--directory</code></td><td>Path to directory of JSON files</td></tr>
<tr><td><code>-o</code></td><td><code>--output</code></td><td>Output filename</td></tr>
<tr><td><code>-s</code></td><td><code>--schema</code></td><td>Path to custom JSON schema</td></tr>
<tr><td><code>--attach</code></td><td></td><td>Path to file/directory for attachments</td></tr>
<tr><td><code>--embed</code></td><td><code>-e</code></td><td>Embed documents (true/false)</td></tr>
<tr><td><code>--no-save</code></td><td><code>-n</code></td><td>Print to stdout instead of saving</td></tr>
<tr><td><code>-v</code></td><td><code>--verbose</code></td><td>Enable verbose output</td></tr>
<tr><td><code>-a</code></td><td><code>--agent-file</code></td><td>Path to agent file</td></tr>
</tbody></table>
</div>
<h3 id="update-document"><a class="header" href="#update-document">Update Document</a></h3>
<pre><code class="language-bash"># Update an existing document with new content
jacs document update -f ./original.json -n ./updated.json

# With output file
jacs document update -f ./original.json -n ./updated.json -o ./result.json

# With file attachments
jacs document update -f ./original.json -n ./updated.json --attach ./new-file.pdf
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-f</code></td><td><code>--filename</code></td><td>Yes</td><td>Path to original document</td></tr>
<tr><td><code>-n</code></td><td><code>--new</code></td><td>Yes</td><td>Path to new version</td></tr>
<tr><td><code>-o</code></td><td><code>--output</code></td><td>No</td><td>Output filename</td></tr>
<tr><td><code>--attach</code></td><td></td><td>No</td><td>Path to file attachments</td></tr>
<tr><td><code>--embed</code></td><td><code>-e</code></td><td>No</td><td>Embed documents (true/false)</td></tr>
</tbody></table>
</div>
<h3 id="verify-document"><a class="header" href="#verify-document">Verify Document</a></h3>
<pre><code class="language-bash"># Verify a document
jacs document verify -f ./document.json

# Verify all documents in a directory
jacs document verify -d ./documents/

# With custom schema
jacs document verify -f ./document.json -s ./schema.json

# Verbose output
jacs document verify -f ./document.json -v
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-f</code></td><td><code>--filename</code></td><td>Path to document file</td></tr>
<tr><td><code>-d</code></td><td><code>--directory</code></td><td>Path to directory of documents</td></tr>
<tr><td><code>-s</code></td><td><code>--schema</code></td><td>Path to JSON schema for validation</td></tr>
<tr><td><code>-v</code></td><td><code>--verbose</code></td><td>Enable verbose output</td></tr>
<tr><td><code>-a</code></td><td><code>--agent-file</code></td><td>Path to agent file</td></tr>
</tbody></table>
</div>
<h3 id="extract-embedded-content"><a class="header" href="#extract-embedded-content">Extract Embedded Content</a></h3>
<pre><code class="language-bash"># Extract embedded content from a document
jacs document extract -f ./document.json

# Extract from all documents in directory
jacs document extract -d ./documents/
</code></pre>
<h3 id="agreement-commands"><a class="header" href="#agreement-commands">Agreement Commands</a></h3>
<pre><code class="language-bash"># Create an agreement requiring signatures from specified agents
jacs document create-agreement -f ./document.json -i agent1-uuid,agent2-uuid

# Check agreement status
jacs document check-agreement -f ./document.json

# Sign an agreement
jacs document sign-agreement -f ./document.json
</code></pre>
<p><strong>Create Agreement Options:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-f</code></td><td><code>--filename</code></td><td>Yes</td><td>Path to document</td></tr>
<tr><td><code>-i</code></td><td><code>--agentids</code></td><td>Yes</td><td>Comma-separated list of agent UUIDs</td></tr>
<tr><td><code>-o</code></td><td><code>--output</code></td><td>No</td><td>Output filename</td></tr>
<tr><td><code>--no-save</code></td><td><code>-n</code></td><td>No</td><td>Print to stdout</td></tr>
</tbody></table>
</div>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<p>The CLI respects the following environment variables:</p>
<pre><code class="language-bash"># Use a specific configuration file
JACS_CONFIG_PATH=./custom-config.json jacs agent verify

# Override settings
JACS_DATA_DIRECTORY=./data jacs document create -f ./doc.json
JACS_KEY_DIRECTORY=./keys jacs agent create --create-keys true
</code></pre>
<h2 id="common-workflows"><a class="header" href="#common-workflows">Common Workflows</a></h2>
<h3 id="create-and-sign-a-document"><a class="header" href="#create-and-sign-a-document">Create and Sign a Document</a></h3>
<pre><code class="language-bash"># 1. Initialize (if not done)
jacs init

# 2. Create document
jacs document create -f ./my-document.json

# 3. Verify the signed document
jacs document verify -f ./jacs_data/[document-id].json
</code></pre>
<h3 id="multi-agent-agreement"><a class="header" href="#multi-agent-agreement">Multi-Agent Agreement</a></h3>
<pre><code class="language-bash"># 1. Create agreement on a document
jacs document create-agreement -f ./document.json -i agent1-id,agent2-id

# 2. First agent signs
jacs document sign-agreement -f ./document.json

# 3. Second agent signs (using their config)
JACS_CONFIG_PATH=./agent2.config.json jacs document sign-agreement -f ./document.json

# 4. Check agreement is complete
jacs document check-agreement -f ./document.json
</code></pre>
<h3 id="verify-another-agent"><a class="header" href="#verify-another-agent">Verify Another Agent</a></h3>
<pre><code class="language-bash"># Look up agent by domain
jacs agent lookup other-agent.example.com

# Verify with strict DNS
jacs agent verify -a ./other-agent.json --require-strict-dns
</code></pre>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody>
<tr><td>0</td><td>Success</td></tr>
<tr><td>1</td><td>General error</td></tr>
<tr><td>2</td><td>Invalid arguments</td></tr>
<tr><td>3</td><td>File not found</td></tr>
<tr><td>4</td><td>Verification failed</td></tr>
<tr><td>5</td><td>Signature invalid</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="rust/agent.html">Creating an Agent</a> - Detailed agent creation guide</li>
<li><a href="rust/documents.html">Working with Documents</a> - Document operations in depth</li>
<li><a href="rust/agreements.html">Agreements</a> - Multi-agent agreements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-agent"><a class="header" href="#creating-an-agent">Creating an Agent</a></h1>
<p>An agent is the fundamental identity in JACS - an autonomous entity that can create, sign, and verify documents. This guide covers creating and managing agents.</p>
<h2 id="what-is-an-agent"><a class="header" href="#what-is-an-agent">What is an Agent?</a></h2>
<p>A JACS agent is:</p>
<ul>
<li>A unique identity with a UUID that never changes</li>
<li>A holder of cryptographic keys for signing</li>
<li>A provider of services defined in the agent document</li>
<li>Self-signed to prove authenticity</li>
</ul>
<h2 id="creating-your-first-agent"><a class="header" href="#creating-your-first-agent">Creating Your First Agent</a></h2>
<h3 id="quick-method-recommended"><a class="header" href="#quick-method-recommended">Quick Method (Recommended)</a></h3>
<pre><code class="language-bash"># Initialize JACS (creates config and agent)
jacs init
</code></pre>
<p>This creates:</p>
<ul>
<li>Configuration file</li>
<li>Cryptographic key pair</li>
<li>Initial agent document</li>
</ul>
<h3 id="manual-method"><a class="header" href="#manual-method">Manual Method</a></h3>
<pre><code class="language-bash"># 1. Create configuration
jacs config create

# 2. Create agent with new keys
jacs agent create --create-keys true
</code></pre>
<h3 id="with-custom-agent-definition"><a class="header" href="#with-custom-agent-definition">With Custom Agent Definition</a></h3>
<p>Create an agent definition file (<code>my-agent.json</code>):</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsAgentType": "ai",
  "jacsAgentDomain": "myagent.example.com",
  "name": "Content Creation Agent",
  "description": "AI agent specialized in content creation",
  "jacsServices": [
    {
      "jacsServiceName": "content-generation",
      "jacsServiceDescription": "Generate high-quality content",
      "jacsServiceSuccess": "Engaging, accurate content delivered",
      "jacsServiceFailure": "Unable to generate requested content"
    }
  ]
}
</code></pre>
<p>Then create the agent:</p>
<pre><code class="language-bash">jacs agent create --create-keys true -f my-agent.json
</code></pre>
<h2 id="agent-types"><a class="header" href="#agent-types">Agent Types</a></h2>
<p>JACS supports four agent types:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Contacts Required</th></tr></thead><tbody>
<tr><td><code>ai</code></td><td>Fully artificial intelligence</td><td>No</td></tr>
<tr><td><code>human</code></td><td>Individual person</td><td>Yes</td></tr>
<tr><td><code>human-org</code></td><td>Group of people (organization)</td><td>Yes</td></tr>
<tr><td><code>hybrid</code></td><td>Human-AI combination</td><td>Yes</td></tr>
</tbody></table>
</div>
<h3 id="ai-agent-example"><a class="header" href="#ai-agent-example">AI Agent Example</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsAgentType": "ai",
  "name": "DataBot",
  "description": "Data processing agent",
  "jacsServices": [
    {
      "jacsServiceName": "data-processing",
      "jacsServiceDescription": "Process and transform data"
    }
  ]
}
</code></pre>
<h3 id="human-agent-example"><a class="header" href="#human-agent-example">Human Agent Example</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsAgentType": "human",
  "name": "John Smith",
  "description": "Software engineer",
  "jacsContacts": [
    {
      "jacsContactType": "email",
      "jacsContactValue": "john@example.com"
    }
  ],
  "jacsServices": [
    {
      "jacsServiceName": "code-review",
      "jacsServiceDescription": "Review code for quality and security"
    }
  ]
}
</code></pre>
<h2 id="agent-services"><a class="header" href="#agent-services">Agent Services</a></h2>
<p>Services define what an agent can do. Each service has:</p>
<pre><code class="language-json">{
  "jacsServiceName": "service-identifier",
  "jacsServiceDescription": "What the service does",
  "jacsServiceSuccess": "Definition of successful completion",
  "jacsServiceFailure": "What constitutes failure",
  "jacsServiceActions": [
    {
      "jacsActionName": "action-1",
      "jacsActionDescription": "First action in this service"
    }
  ]
}
</code></pre>
<h3 id="service-with-actions"><a class="header" href="#service-with-actions">Service with Actions</a></h3>
<pre><code class="language-json">{
  "jacsServiceName": "document-processing",
  "jacsServiceDescription": "Process and analyze documents",
  "jacsServiceActions": [
    {
      "jacsActionName": "extract-text",
      "jacsActionDescription": "Extract text from PDF documents"
    },
    {
      "jacsActionName": "summarize",
      "jacsActionDescription": "Generate document summaries"
    },
    {
      "jacsActionName": "translate",
      "jacsActionDescription": "Translate documents between languages"
    }
  ]
}
</code></pre>
<h2 id="agent-contacts"><a class="header" href="#agent-contacts">Agent Contacts</a></h2>
<p>For human and hybrid agents, contacts are required:</p>
<pre><code class="language-json">{
  "jacsContacts": [
    {
      "jacsContactType": "email",
      "jacsContactValue": "agent@example.com"
    },
    {
      "jacsContactType": "website",
      "jacsContactValue": "https://example.com"
    },
    {
      "jacsContactType": "phone",
      "jacsContactValue": "+1-555-0123"
    }
  ]
}
</code></pre>
<h2 id="cryptographic-keys"><a class="header" href="#cryptographic-keys">Cryptographic Keys</a></h2>
<h3 id="key-algorithms"><a class="header" href="#key-algorithms">Key Algorithms</a></h3>
<p>JACS supports multiple cryptographic algorithms:</p>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Description</th><th>Recommended For</th></tr></thead><tbody>
<tr><td><code>ring-Ed25519</code></td><td>Fast elliptic curve signatures</td><td>General use (default)</td></tr>
<tr><td><code>RSA-PSS</code></td><td>Traditional RSA signatures</td><td>Legacy compatibility</td></tr>
<tr><td><code>pq-dilithium</code></td><td>Post-quantum signatures</td><td>Future-proof security</td></tr>
</tbody></table>
</div>
<h3 id="configure-key-algorithm"><a class="header" href="#configure-key-algorithm">Configure Key Algorithm</a></h3>
<p>In <code>jacs.config.json</code>:</p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p>Or via environment variable:</p>
<pre><code class="language-bash">JACS_AGENT_KEY_ALGORITHM=ring-Ed25519 jacs agent create --create-keys true
</code></pre>
<h3 id="key-storage"><a class="header" href="#key-storage">Key Storage</a></h3>
<p>Keys are stored in the key directory (default: <code>./jacs_keys</code>):</p>
<pre><code>jacs_keys/
‚îú‚îÄ‚îÄ private_key.pem    # Private key (keep secure!)
‚îî‚îÄ‚îÄ public_key.pem     # Public key (can be shared)
</code></pre>
<h2 id="verifying-agents"><a class="header" href="#verifying-agents">Verifying Agents</a></h2>
<h3 id="verify-your-own-agent"><a class="header" href="#verify-your-own-agent">Verify Your Own Agent</a></h3>
<pre><code class="language-bash">jacs agent verify
</code></pre>
<h3 id="verify-a-specific-agent-file"><a class="header" href="#verify-a-specific-agent-file">Verify a Specific Agent File</a></h3>
<pre><code class="language-bash">jacs agent verify -a ./path/to/agent.json
</code></pre>
<h3 id="with-dns-verification"><a class="header" href="#with-dns-verification">With DNS Verification</a></h3>
<pre><code class="language-bash"># Require DNS validation
jacs agent verify --require-dns

# Require strict DNSSEC
jacs agent verify --require-strict-dns
</code></pre>
<h2 id="updating-agents"><a class="header" href="#updating-agents">Updating Agents</a></h2>
<p>Agent updates create a new version while maintaining the same <code>jacsId</code>:</p>
<ol>
<li>Modify the agent document</li>
<li>Re-sign with the agent's keys</li>
</ol>
<p>The <code>jacsVersion</code> changes but <code>jacsId</code> remains constant.</p>
<h2 id="agent-document-structure"><a class="header" href="#agent-document-structure">Agent Document Structure</a></h2>
<p>A complete agent document looks like:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "123e4567-e89b-12d3-a456-426614174000",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsOriginalVersion": "123e4567-e89b-12d3-a456-426614174000",
  "jacsOriginalDate": "2024-01-15T10:30:00Z",
  "jacsType": "agent",
  "jacsLevel": "config",

  "jacsAgentType": "ai",
  "jacsAgentDomain": "myagent.example.com",
  "name": "Content Creation Agent",
  "description": "AI agent for content generation",

  "jacsServices": [
    {
      "jacsServiceName": "content-generation",
      "jacsServiceDescription": "Generate high-quality content"
    }
  ],

  "jacsSha256": "hash-of-document",
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "123e4567-e89b-12d3-a456-426614174000",
    "signature": "base64-encoded-signature",
    "signingAlgorithm": "ring-Ed25519",
    "publicKeyHash": "hash-of-public-key",
    "date": "2024-01-15T10:30:00Z",
    "fields": ["jacsId", "jacsVersion", "jacsAgentType", "name", "jacsServices"]
  }
}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ol>
<li><strong>Protect private keys</strong>: Never share or commit private keys</li>
<li><strong>Use strong algorithms</strong>: Prefer Ed25519 or post-quantum</li>
<li><strong>Enable DNS verification</strong>: For production agents</li>
<li><strong>Regular key rotation</strong>: Update keys periodically</li>
</ol>
<h3 id="agent-design"><a class="header" href="#agent-design">Agent Design</a></h3>
<ol>
<li><strong>Clear service definitions</strong>: Be specific about capabilities</li>
<li><strong>Meaningful names</strong>: Use descriptive agent names</li>
<li><strong>Contact information</strong>: Include for human agents</li>
<li><strong>Version control</strong>: Track agent document changes</li>
</ol>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<ol>
<li><strong>Backup keys</strong>: Keep secure backups of private keys</li>
<li><strong>Monitor signatures</strong>: Watch for unauthorized signing</li>
<li><strong>Document services</strong>: Keep service definitions current</li>
</ol>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="rust/documents.html">Working with Documents</a> - Create signed documents</li>
<li><a href="rust/agreements.html">Agreements</a> - Multi-agent coordination</li>
<li><a href="rust/dns.html">DNS Verification</a> - Publish agent identity</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-documents"><a class="header" href="#working-with-documents">Working with Documents</a></h1>
<p>Documents are the core data structure in JACS. Any JSON object can become a JACS document by adding the required header fields and a cryptographic signature.</p>
<h2 id="what-is-a-jacs-document"><a class="header" href="#what-is-a-jacs-document">What is a JACS Document?</a></h2>
<p>A JACS document is a JSON object that includes:</p>
<ul>
<li><strong>Identity</strong>: Unique ID and version tracking</li>
<li><strong>Metadata</strong>: Type, timestamps, and origin information</li>
<li><strong>Signature</strong>: Cryptographic proof of authenticity</li>
<li><strong>Hash</strong>: Integrity verification</li>
</ul>
<h2 id="creating-documents"><a class="header" href="#creating-documents">Creating Documents</a></h2>
<h3 id="from-a-json-file"><a class="header" href="#from-a-json-file">From a JSON File</a></h3>
<p>Create a simple JSON document (<code>my-document.json</code>):</p>
<pre><code class="language-json">{
  "title": "Project Proposal",
  "description": "Q1 development plan",
  "budget": 50000,
  "deadline": "2024-03-31"
}
</code></pre>
<p>Sign it with JACS:</p>
<pre><code class="language-bash">jacs document create -f my-document.json
</code></pre>
<p>This adds JACS headers and signature, producing a signed document.</p>
<h3 id="from-a-directory"><a class="header" href="#from-a-directory">From a Directory</a></h3>
<p>Process multiple documents at once:</p>
<pre><code class="language-bash">jacs document create -d ./documents/
</code></pre>
<h3 id="with-custom-schema"><a class="header" href="#with-custom-schema">With Custom Schema</a></h3>
<p>Validate against a custom JSON schema:</p>
<pre><code class="language-bash">jacs document create -f my-document.json -s ./schemas/proposal.schema.json
</code></pre>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<pre><code class="language-bash"># Save to specific file
jacs document create -f my-document.json -o ./output/signed-doc.json

# Print to stdout instead of saving
jacs document create -f my-document.json --no-save

# Verbose output
jacs document create -f my-document.json -v
</code></pre>
<h2 id="document-structure-1"><a class="header" href="#document-structure-1">Document Structure</a></h2>
<p>After signing, a document looks like:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/header/v1/header.schema.json",
  "jacsId": "doc-uuid-here",
  "jacsVersion": "version-uuid-here",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsOriginalVersion": "version-uuid-here",
  "jacsOriginalDate": "2024-01-15T10:30:00Z",
  "jacsType": "document",
  "jacsLevel": "artifact",

  "title": "Project Proposal",
  "description": "Q1 development plan",
  "budget": 50000,
  "deadline": "2024-03-31",

  "jacsSha256": "a1b2c3d4...",
  "jacsSignature": {
    "agentID": "agent-uuid",
    "agentVersion": "agent-version-uuid",
    "signature": "base64-signature",
    "signingAlgorithm": "ring-Ed25519",
    "publicKeyHash": "hash-of-public-key",
    "date": "2024-01-15T10:30:00Z",
    "fields": ["jacsId", "title", "description", "budget", "deadline"]
  }
}
</code></pre>
<h2 id="required-header-fields"><a class="header" href="#required-header-fields">Required Header Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th><th>Auto-generated</th></tr></thead><tbody>
<tr><td><code>$schema</code></td><td>JSON Schema reference</td><td>Yes</td></tr>
<tr><td><code>jacsId</code></td><td>Permanent document UUID</td><td>Yes</td></tr>
<tr><td><code>jacsVersion</code></td><td>Version UUID (changes on update)</td><td>Yes</td></tr>
<tr><td><code>jacsVersionDate</code></td><td>When this version was created</td><td>Yes</td></tr>
<tr><td><code>jacsOriginalVersion</code></td><td>First version UUID</td><td>Yes</td></tr>
<tr><td><code>jacsOriginalDate</code></td><td>Original creation timestamp</td><td>Yes</td></tr>
<tr><td><code>jacsType</code></td><td>Document type</td><td>Yes</td></tr>
<tr><td><code>jacsLevel</code></td><td>Data level (raw, config, artifact, derived)</td><td>Yes</td></tr>
</tbody></table>
</div>
<h2 id="document-levels"><a class="header" href="#document-levels">Document Levels</a></h2>
<p>The <code>jacsLevel</code> field indicates the document's purpose:</p>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>raw</code></td><td>Original data, should not change</td><td>Source documents</td></tr>
<tr><td><code>config</code></td><td>Configuration, meant to be updated</td><td>Agent definitions, settings</td></tr>
<tr><td><code>artifact</code></td><td>Generated output</td><td>Reports, summaries</td></tr>
<tr><td><code>derived</code></td><td>Computed from other documents</td><td>Analysis results</td></tr>
</tbody></table>
</div>
<h2 id="file-attachments"><a class="header" href="#file-attachments">File Attachments</a></h2>
<h3 id="attach-files"><a class="header" href="#attach-files">Attach Files</a></h3>
<pre><code class="language-bash"># Attach a single file
jacs document create -f my-document.json --attach ./report.pdf

# Attach a directory of files
jacs document create -f my-document.json --attach ./attachments/
</code></pre>
<h3 id="embed-vs-reference"><a class="header" href="#embed-vs-reference">Embed vs. Reference</a></h3>
<pre><code class="language-bash"># Embed files directly in the document (larger document, self-contained)
jacs document create -f my-document.json --attach ./files/ --embed true

# Reference files (smaller document, files stored separately)
jacs document create -f my-document.json --attach ./files/ --embed false
</code></pre>
<h3 id="attachment-structure"><a class="header" href="#attachment-structure">Attachment Structure</a></h3>
<p>Embedded attachments appear in the <code>jacsFiles</code> field:</p>
<pre><code class="language-json">{
  "jacsFiles": [
    {
      "jacsFileName": "report.pdf",
      "jacsFileMimeType": "application/pdf",
      "jacsFileSha256": "file-hash",
      "jacsFileContent": "base64-encoded-content"
    }
  ]
}
</code></pre>
<h2 id="verifying-documents"><a class="header" href="#verifying-documents">Verifying Documents</a></h2>
<h3 id="basic-verification"><a class="header" href="#basic-verification">Basic Verification</a></h3>
<pre><code class="language-bash">jacs document verify -f ./signed-document.json
</code></pre>
<p>Verification checks:</p>
<ol>
<li>Hash integrity (document hasn't been modified)</li>
<li>Signature validity (signature matches content)</li>
<li>Schema compliance (if schema specified)</li>
</ol>
<h3 id="verify-with-schema"><a class="header" href="#verify-with-schema">Verify with Schema</a></h3>
<pre><code class="language-bash">jacs document verify -f ./document.json -s ./schema.json
</code></pre>
<h3 id="verify-directory"><a class="header" href="#verify-directory">Verify Directory</a></h3>
<pre><code class="language-bash">jacs document verify -d ./documents/
</code></pre>
<h3 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h3>
<pre><code class="language-bash">jacs document verify -f ./document.json -v
</code></pre>
<h2 id="updating-documents"><a class="header" href="#updating-documents">Updating Documents</a></h2>
<p>Updates create a new version while maintaining the same <code>jacsId</code>:</p>
<pre><code class="language-bash">jacs document update -f ./original.json -n ./modified.json
</code></pre>
<p>The update process:</p>
<ol>
<li>Reads the original document</li>
<li>Applies changes from the modified file</li>
<li>Increments <code>jacsVersion</code></li>
<li>Links to previous version via <code>jacsPreviousVersion</code></li>
<li>Re-signs with agent's key</li>
</ol>
<h3 id="update-with-attachments"><a class="header" href="#update-with-attachments">Update with Attachments</a></h3>
<pre><code class="language-bash">jacs document update -f ./original.json -n ./modified.json --attach ./new-file.pdf
</code></pre>
<h2 id="extracting-embedded-content"><a class="header" href="#extracting-embedded-content">Extracting Embedded Content</a></h2>
<p>Extract attachments from a document:</p>
<pre><code class="language-bash">jacs document extract -f ./document-with-attachments.json
</code></pre>
<p>Extract from multiple documents:</p>
<pre><code class="language-bash">jacs document extract -d ./documents/
</code></pre>
<h2 id="document-types-1"><a class="header" href="#document-types-1">Document Types</a></h2>
<h3 id="task-documents"><a class="header" href="#task-documents">Task Documents</a></h3>
<p>Tasks are specialized documents for work tracking:</p>
<pre><code class="language-bash">jacs task create -n "Code Review" -d "Review PR #123"
</code></pre>
<p>See <a href="rust/../schemas/task.html">Task Schema</a> for details.</p>
<h3 id="message-documents"><a class="header" href="#message-documents">Message Documents</a></h3>
<p>Messages for agent communication:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/message/v1/message.schema.json",
  "jacsType": "message",
  "jacsMessageContent": "Hello, I've completed the task.",
  "jacsMessageReplyTo": "previous-message-uuid"
}
</code></pre>
<h3 id="custom-documents"><a class="header" href="#custom-documents">Custom Documents</a></h3>
<p>Any JSON can be a JACS document. Create custom schemas:</p>
<pre><code class="language-json">{
  "$schema": "https://example.com/schemas/invoice.schema.json",
  "jacsType": "invoice",
  "invoiceNumber": "INV-001",
  "amount": 1000,
  "currency": "USD"
}
</code></pre>
<h2 id="version-history"><a class="header" href="#version-history">Version History</a></h2>
<p>JACS tracks document history through version chains:</p>
<pre><code>Version 1 (jacsOriginalVersion)
    ‚Üì
Version 2 (jacsPreviousVersion ‚Üí Version 1)
    ‚Üì
Version 3 (jacsPreviousVersion ‚Üí Version 2)
    ‚Üì
Current Version
</code></pre>
<p>Each version is a complete document that can be independently verified.</p>
<h2 id="working-with-multiple-agents"><a class="header" href="#working-with-multiple-agents">Working with Multiple Agents</a></h2>
<h3 id="different-agent-signs-document"><a class="header" href="#different-agent-signs-document">Different Agent Signs Document</a></h3>
<pre><code class="language-bash"># Use a specific agent's keys
jacs document create -f ./document.json -a ./other-agent.json
</code></pre>
<h3 id="verify-document-from-unknown-agent"><a class="header" href="#verify-document-from-unknown-agent">Verify Document from Unknown Agent</a></h3>
<pre><code class="language-bash"># Verify with strict DNS requirement
jacs document verify -f ./document.json --require-strict-dns
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="document-design"><a class="header" href="#document-design">Document Design</a></h3>
<ol>
<li><strong>Use appropriate levels</strong>: Match <code>jacsLevel</code> to document purpose</li>
<li><strong>Include context</strong>: Add descriptive fields for human readability</li>
<li><strong>Version control</strong>: Keep source files in git alongside JACS documents</li>
</ol>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ol>
<li><strong>Verify before trusting</strong>: Always verify signatures</li>
<li><strong>Check agent identity</strong>: Verify the signing agent</li>
<li><strong>Validate schemas</strong>: Use custom schemas for strict validation</li>
</ol>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ol>
<li><strong>External attachments</strong>: Use <code>--embed false</code> for large files</li>
<li><strong>Batch processing</strong>: Use directory mode for multiple documents</li>
<li><strong>Selective verification</strong>: Verify only when needed</li>
</ol>
<h2 id="common-workflows-1"><a class="header" href="#common-workflows-1">Common Workflows</a></h2>
<h3 id="create-and-share-document"><a class="header" href="#create-and-share-document">Create and Share Document</a></h3>
<pre><code class="language-bash"># 1. Create document
jacs document create -f ./proposal.json -o ./signed-proposal.json

# 2. Share the signed document
# The recipient can verify it:
jacs document verify -f ./signed-proposal.json
</code></pre>
<h3 id="track-document-changes"><a class="header" href="#track-document-changes">Track Document Changes</a></h3>
<pre><code class="language-bash"># 1. Create initial version
jacs document create -f ./contract-v1.json

# 2. Make changes and update
jacs document update -f ./contract-v1.json -n ./contract-v2.json

# 3. Continue updating
jacs document update -f ./contract-v2.json -n ./contract-v3.json
</code></pre>
<h3 id="process-multiple-documents"><a class="header" href="#process-multiple-documents">Process Multiple Documents</a></h3>
<pre><code class="language-bash"># Create all documents in a directory
jacs document create -d ./input-docs/

# Verify all documents
jacs document verify -d ./signed-docs/
</code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="rust/agreements.html">Agreements</a> - Multi-agent consent</li>
<li><a href="rust/../schemas/task.html">Task Schema</a> - Task document structure</li>
<li><a href="rust/../advanced/custom-schemas.html">Custom Schemas</a> - Create your own schemas</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-using-agreements"><a class="header" href="#creating-and-using-agreements">Creating and Using Agreements</a></h1>
<p>Agreements enable multi-party consent in JACS. They allow multiple agents to cryptographically sign a document, creating binding commitments between parties.</p>
<h2 id="what-is-an-agreement"><a class="header" href="#what-is-an-agreement">What is an Agreement?</a></h2>
<p>An agreement is a mechanism for:</p>
<ul>
<li><strong>Collecting signatures</strong> from multiple agents</li>
<li><strong>Tracking consent</strong> from required parties</li>
<li><strong>Enforcing completion</strong> before proceeding</li>
<li><strong>Creating audit trails</strong> of who agreed and when</li>
</ul>
<h2 id="agreement-lifecycle"><a class="header" href="#agreement-lifecycle">Agreement Lifecycle</a></h2>
<pre><code>1. Create Agreement ‚Üí 2. Distribute ‚Üí 3. Agents Sign ‚Üí 4. Verify Complete
</code></pre>
<ol>
<li><strong>Create</strong>: Initial agent creates agreement with required participants</li>
<li><strong>Distribute</strong>: Agreement document shared with all parties</li>
<li><strong>Sign</strong>: Each agent reviews and adds their signature</li>
<li><strong>Verify</strong>: Check that all required parties have signed</li>
</ol>
<h2 id="creating-agreements"><a class="header" href="#creating-agreements">Creating Agreements</a></h2>
<h3 id="basic-agreement"><a class="header" href="#basic-agreement">Basic Agreement</a></h3>
<pre><code class="language-bash"># Create agreement requiring signatures from two agents
jacs document create-agreement \
  -f ./document.json \
  -i agent1-uuid,agent2-uuid
</code></pre>
<h3 id="with-context"><a class="header" href="#with-context">With Context</a></h3>
<p>Include a question and context for clarity:</p>
<pre><code class="language-json">{
  "jacsAgreement": {
    "jacsAgreementQuestion": "Do you agree to the terms of this contract?",
    "jacsAgreementContext": "Service agreement for Q1 2024",
    "jacsAgreementAgents": ["agent1-uuid", "agent2-uuid"]
  }
}
</code></pre>
<h2 id="signing-agreements"><a class="header" href="#signing-agreements">Signing Agreements</a></h2>
<h3 id="sign-as-current-agent"><a class="header" href="#sign-as-current-agent">Sign as Current Agent</a></h3>
<pre><code class="language-bash">jacs document sign-agreement -f ./document-with-agreement.json
</code></pre>
<h3 id="sign-as-different-agent"><a class="header" href="#sign-as-different-agent">Sign as Different Agent</a></h3>
<pre><code class="language-bash"># Use a different configuration/agent
JACS_CONFIG_PATH=./agent2.config.json jacs document sign-agreement -f ./document.json
</code></pre>
<h3 id="sign-with-response"><a class="header" href="#sign-with-response">Sign with Response</a></h3>
<p>When signing, agents can include a response:</p>
<pre><code class="language-json">{
  "jacsAgreement": {
    "signatures": {
      "agent1-uuid": {
        "agentID": "agent1-uuid",
        "signature": "base64-signature",
        "date": "2024-01-15T10:30:00Z",
        "response": "Agreed with minor reservation about timeline",
        "responseType": "agree"
      }
    }
  }
}
</code></pre>
<p>Response types:</p>
<ul>
<li><code>agree</code> - Agent consents</li>
<li><code>disagree</code> - Agent does not consent</li>
<li><code>reject</code> - Agent considers the question invalid or irrelevant</li>
</ul>
<h2 id="checking-agreement-status"><a class="header" href="#checking-agreement-status">Checking Agreement Status</a></h2>
<h3 id="check-if-complete"><a class="header" href="#check-if-complete">Check if Complete</a></h3>
<pre><code class="language-bash">jacs document check-agreement -f ./document.json
</code></pre>
<p>This shows:</p>
<ul>
<li>Which agents have signed</li>
<li>Which agents still need to sign</li>
<li>Whether the agreement is complete</li>
</ul>
<h2 id="agreement-structure-1"><a class="header" href="#agreement-structure-1">Agreement Structure</a></h2>
<p>A document with an agreement includes:</p>
<pre><code class="language-json">{
  "jacsId": "doc-uuid",
  "jacsType": "contract",

  "jacsAgreement": {
    "jacsAgreementQuestion": "Do you agree to these terms?",
    "jacsAgreementContext": "Annual service contract",
    "jacsAgreementAgents": [
      "550e8400-e29b-41d4-a716-446655440000",
      "123e4567-e89b-12d3-a456-426614174000"
    ],
    "signatures": {
      "550e8400-e29b-41d4-a716-446655440000": {
        "agentID": "550e8400-e29b-41d4-a716-446655440000",
        "agentVersion": "version-uuid",
        "signature": "base64-signature",
        "signingAlgorithm": "ring-Ed25519",
        "publicKeyHash": "hash",
        "date": "2024-01-15T10:30:00Z",
        "responseType": "agree",
        "fields": ["jacsId", "jacsAgreement"]
      }
    }
  },

  "jacsAgreementHash": "hash-of-agreement-content"
}
</code></pre>
<h2 id="task-agreements"><a class="header" href="#task-agreements">Task Agreements</a></h2>
<p>Tasks have built-in support for start and end agreements:</p>
<pre><code class="language-json">{
  "jacsType": "task",
  "jacsTaskName": "Code Review",

  "jacsStartAgreement": {
    "jacsAgreementQuestion": "Do you agree to start this task?",
    "jacsAgreementAgents": ["customer-uuid", "provider-uuid"]
  },

  "jacsEndAgreement": {
    "jacsAgreementQuestion": "Do you agree the task is complete?",
    "jacsAgreementAgents": ["customer-uuid", "provider-uuid"]
  }
}
</code></pre>
<h2 id="multi-agent-workflow-example"><a class="header" href="#multi-agent-workflow-example">Multi-Agent Workflow Example</a></h2>
<pre><code class="language-bash"># 1. Agent A creates a task
jacs task create -n "Write Report" -d "Quarterly sales report"

# 2. Agent A adds agreement requiring both agents
jacs document create-agreement \
  -f ./task.json \
  -i agent-a-uuid,agent-b-uuid

# 3. Agent A signs the agreement
jacs document sign-agreement -f ./task.json

# 4. Agent B signs the agreement
JACS_CONFIG_PATH=./agent-b.config.json \
  jacs document sign-agreement -f ./task.json

# 5. Check agreement is complete
jacs document check-agreement -f ./task.json
</code></pre>
<h2 id="agreement-hash"><a class="header" href="#agreement-hash">Agreement Hash</a></h2>
<p>The <code>jacsAgreementHash</code> ensures all agents agree to the same content:</p>
<ol>
<li>Hash is computed from the agreement content</li>
<li>Each signature includes the hash</li>
<li>If content changes, hash changes, invalidating existing signatures</li>
</ol>
<p>This prevents modifications after some parties have signed.</p>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Verify before signing</strong>: Always review documents before signing</li>
<li><strong>Check agent identities</strong>: Verify who you're agreeing with (use DNS)</li>
<li><strong>Include context</strong>: Make the agreement purpose clear</li>
<li><strong>Handle disagreement</strong>: Have a process for when agents disagree</li>
</ol>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="rust/dns.html">DNS Verification</a> - Verify agent identities</li>
<li><a href="rust/../schemas/task.html">Task Schema</a> - Task-specific agreements</li>
<li><a href="rust/../advanced/security.html">Security Model</a> - Agreement security</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dns-based-agent-verification"><a class="header" href="#dns-based-agent-verification">DNS-Based Agent Verification</a></h1>
<p>JACS supports DNS-based agent verification using DNS TXT records and DNSSEC. This allows agents to publish their identity in a decentralized, verifiable way that doesn't require a central authority.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>DNS verification in JACS works by:</p>
<ol>
<li>Publishing an agent's public key fingerprint as a DNS TXT record</li>
<li>Using DNSSEC to cryptographically verify the DNS response</li>
<li>Comparing the fingerprint from DNS with the agent's actual public key</li>
</ol>
<p>This provides a secure, decentralized way to verify agent identity across the internet.</p>
<h2 id="why-dns-verification"><a class="header" href="#why-dns-verification">Why DNS Verification?</a></h2>
<ul>
<li><strong>Decentralized</strong>: No central authority required</li>
<li><strong>Existing Infrastructure</strong>: Uses established DNS infrastructure</li>
<li><strong>DNSSEC Security</strong>: Cryptographic verification of DNS responses</li>
<li><strong>Human-Readable</strong>: Agents can be identified by domain names</li>
<li><strong>Widely Supported</strong>: Works with any DNS provider</li>
</ul>
<h2 id="publishing-agent-identity"><a class="header" href="#publishing-agent-identity">Publishing Agent Identity</a></h2>
<h3 id="generate-dns-commands"><a class="header" href="#generate-dns-commands">Generate DNS Commands</a></h3>
<pre><code class="language-bash"># Generate DNS TXT record commands for your agent
jacs agent dns --domain myagent.example.com

# Specify agent ID explicitly
jacs agent dns --domain myagent.example.com --agent-id 550e8400-e29b-41d4-a716-446655440000

# Use hex encoding instead of base64
jacs agent dns --domain myagent.example.com --encoding hex

# Set custom TTL (time-to-live)
jacs agent dns --domain myagent.example.com --ttl 7200
</code></pre>
<h3 id="provider-specific-formats"><a class="header" href="#provider-specific-formats">Provider-Specific Formats</a></h3>
<p>JACS can generate DNS commands for various providers:</p>
<pre><code class="language-bash"># Plain text format (default)
jacs agent dns --domain myagent.example.com --provider plain

# AWS Route 53 format
jacs agent dns --domain myagent.example.com --provider aws

# Azure DNS format
jacs agent dns --domain myagent.example.com --provider azure

# Cloudflare DNS format
jacs agent dns --domain myagent.example.com --provider cloudflare
</code></pre>
<h3 id="dns-record-structure"><a class="header" href="#dns-record-structure">DNS Record Structure</a></h3>
<p>The DNS TXT record follows this format:</p>
<pre><code>_v1.agent.jacs.myagent.example.com. 3600 IN TXT "jacs-agent-fingerprint=&lt;fingerprint&gt;"
</code></pre>
<p>Where:</p>
<ul>
<li><code>_v1.agent.jacs.</code> is the JACS-specific subdomain prefix</li>
<li><code>&lt;fingerprint&gt;</code> is the base64-encoded hash of the agent's public key</li>
</ul>
<h3 id="setting-up-with-route-53-aws"><a class="header" href="#setting-up-with-route-53-aws">Setting Up with Route 53 (AWS)</a></h3>
<ol>
<li>Generate the AWS-formatted command:</li>
</ol>
<pre><code class="language-bash">jacs agent dns --domain myagent.example.com --provider aws
</code></pre>
<ol start="2">
<li>The output will include an AWS CLI command like:</li>
</ol>
<pre><code class="language-bash">aws route53 change-resource-record-sets \
  --hosted-zone-id YOUR_ZONE_ID \
  --change-batch '{
    "Changes": [{
      "Action": "UPSERT",
      "ResourceRecordSet": {
        "Name": "_v1.agent.jacs.myagent.example.com",
        "Type": "TXT",
        "TTL": 3600,
        "ResourceRecords": [{"Value": "\"jacs-agent-fingerprint=...\""}]
      }
    }]
  }'
</code></pre>
<ol start="3">
<li>Replace <code>YOUR_ZONE_ID</code> with your actual Route 53 hosted zone ID.</li>
</ol>
<h3 id="setting-up-with-cloudflare"><a class="header" href="#setting-up-with-cloudflare">Setting Up with Cloudflare</a></h3>
<ol>
<li>Generate the Cloudflare-formatted command:</li>
</ol>
<pre><code class="language-bash">jacs agent dns --domain myagent.example.com --provider cloudflare
</code></pre>
<ol start="2">
<li>Or add manually in the Cloudflare dashboard:
<ul>
<li>Type: <code>TXT</code></li>
<li>Name: <code>_v1.agent.jacs</code></li>
<li>Content: <code>jacs-agent-fingerprint=&lt;your-fingerprint&gt;</code></li>
<li>TTL: 3600</li>
</ul>
</li>
</ol>
<h3 id="setting-up-with-azure-dns"><a class="header" href="#setting-up-with-azure-dns">Setting Up with Azure DNS</a></h3>
<ol>
<li>Generate the Azure-formatted command:</li>
</ol>
<pre><code class="language-bash">jacs agent dns --domain myagent.example.com --provider azure
</code></pre>
<ol start="2">
<li>The output will include an Azure CLI command that you can run directly.</li>
</ol>
<h2 id="verifying-agents-with-dns"><a class="header" href="#verifying-agents-with-dns">Verifying Agents with DNS</a></h2>
<h3 id="look-up-another-agent"><a class="header" href="#look-up-another-agent">Look Up Another Agent</a></h3>
<pre><code class="language-bash"># Look up an agent by their domain
jacs agent lookup other-agent.example.com

# With strict DNSSEC validation
jacs agent lookup other-agent.example.com --strict

# Skip DNS verification (not recommended)
jacs agent lookup other-agent.example.com --no-dns
</code></pre>
<h3 id="verify-agent-with-dns"><a class="header" href="#verify-agent-with-dns">Verify Agent with DNS</a></h3>
<p>When verifying an agent, you can specify DNS requirements:</p>
<pre><code class="language-bash"># Default: Use DNS if available, but don't require it
jacs agent verify -a ./agent.json

# Require DNS validation (non-strict)
jacs agent verify -a ./agent.json --require-dns

# Require strict DNSSEC validation
jacs agent verify -a ./agent.json --require-strict-dns

# Disable DNS validation entirely
jacs agent verify -a ./agent.json --no-dns

# Ignore DNS (won't fail if DNS unavailable)
jacs agent verify -a ./agent.json --ignore-dns
</code></pre>
<h2 id="dns-validation-modes"><a class="header" href="#dns-validation-modes">DNS Validation Modes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Flag</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Default</td><td>(none)</td><td>Use DNS if available, fall back to local verification</td></tr>
<tr><td>Require DNS</td><td><code>--require-dns</code></td><td>Fail if DNS record not found (DNSSEC not required)</td></tr>
<tr><td>Require Strict</td><td><code>--require-strict-dns</code></td><td>Fail if DNSSEC validation fails</td></tr>
<tr><td>No DNS</td><td><code>--no-dns</code></td><td>Skip DNS validation entirely</td></tr>
<tr><td>Ignore DNS</td><td><code>--ignore-dns</code></td><td>Don't fail on DNS errors, just warn</td></tr>
</tbody></table>
</div>
<h2 id="agent-domain-configuration"><a class="header" href="#agent-domain-configuration">Agent Domain Configuration</a></h2>
<p>Agents can specify their domain in their agent document:</p>
<pre><code class="language-json">{
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsAgentType": "ai",
  "jacsAgentDomain": "myagent.example.com",
  "jacsServices": [...]
}
</code></pre>
<p>The <code>jacsAgentDomain</code> field is optional but enables DNS-based verification.</p>
<h2 id="dnssec-requirements"><a class="header" href="#dnssec-requirements">DNSSEC Requirements</a></h2>
<p>For maximum security, enable DNSSEC on your domain:</p>
<ol>
<li><strong>Enable DNSSEC at your registrar</strong>: Most registrars support DNSSEC</li>
<li><strong>Configure your DNS provider</strong>: Ensure your DNS provider signs zones</li>
<li><strong>Use <code>--require-strict-dns</code></strong>: Enforce DNSSEC validation</li>
</ol>
<h3 id="checking-dnssec-status"><a class="header" href="#checking-dnssec-status">Checking DNSSEC Status</a></h3>
<p>You can verify DNSSEC is working using standard tools:</p>
<pre><code class="language-bash"># Check if DNSSEC is enabled
dig +dnssec _v1.agent.jacs.myagent.example.com TXT

# Verify DNSSEC validation
delv @8.8.8.8 _v1.agent.jacs.myagent.example.com TXT
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="trust-model"><a class="header" href="#trust-model">Trust Model</a></h3>
<ul>
<li><strong>With DNSSEC</strong>: Full cryptographic chain of trust from root DNS servers</li>
<li><strong>Without DNSSEC</strong>: Trust depends on DNS infrastructure security</li>
<li><strong>Local Only</strong>: Trust is limited to having the correct public key</li>
</ul>
<h3 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h3>
<ol>
<li><strong>Always enable DNSSEC</strong> for production agents</li>
<li><strong>Use strict validation</strong> when verifying unknown agents</li>
<li><strong>Rotate keys carefully</strong> - update DNS records before key changes</li>
<li><strong>Monitor DNS records</strong> for unauthorized changes</li>
<li><strong>Use short TTLs during transitions</strong> then increase for stability</li>
</ol>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<p>DNS responses are cached based on TTL. Consider:</p>
<ul>
<li><strong>Short TTL (300-600s)</strong>: Better for development or key rotation</li>
<li><strong>Long TTL (3600-86400s)</strong>: Better for production stability</li>
</ul>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="dns-record-not-found"><a class="header" href="#dns-record-not-found">"DNS record not found"</a></h3>
<ol>
<li>Verify the record exists:</li>
</ol>
<pre><code class="language-bash">dig _v1.agent.jacs.myagent.example.com TXT
</code></pre>
<ol start="2">
<li>
<p>Check DNS propagation (may take up to 48 hours for new records)</p>
</li>
<li>
<p>Verify the domain in the agent document matches</p>
</li>
</ol>
<h3 id="dnssec-validation-failed"><a class="header" href="#dnssec-validation-failed">"DNSSEC validation failed"</a></h3>
<ol>
<li>Check DNSSEC is enabled:</li>
</ol>
<pre><code class="language-bash">dig +dnssec myagent.example.com
</code></pre>
<ol start="2">
<li>
<p>Verify DS records at registrar</p>
</li>
<li>
<p>Use <code>--require-dns</code> instead of <code>--require-strict-dns</code> if DNSSEC isn't available</p>
</li>
</ol>
<h3 id="fingerprint-mismatch"><a class="header" href="#fingerprint-mismatch">"Fingerprint mismatch"</a></h3>
<ol>
<li>The public key may have changed - regenerate DNS record:</li>
</ol>
<pre><code class="language-bash">jacs agent dns --domain myagent.example.com
</code></pre>
<ol start="2">
<li>
<p>Update the DNS TXT record with the new fingerprint</p>
</li>
<li>
<p>Wait for DNS propagation</p>
</li>
</ol>
<h2 id="integration-with-cicd"><a class="header" href="#integration-with-cicd">Integration with CI/CD</a></h2>
<p>Automate DNS updates in your deployment pipeline:</p>
<pre><code class="language-bash">#!/bin/bash
# deploy-agent.sh

# 1. Create new agent keys
jacs agent create --create-keys true

# 2. Generate DNS update command
DNS_CMD=$(jacs agent dns --domain $AGENT_DOMAIN --provider aws)

# 3. Execute DNS update
eval $DNS_CMD

# 4. Wait for propagation
sleep 60

# 5. Verify DNS is working
jacs agent verify --require-dns
</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="rust/agent.html">Creating an Agent</a> - Set up agents with DNS domains</li>
<li><a href="rust/../advanced/security.html">Security Model</a> - Deep dive into JACS security</li>
<li><a href="rust/agreements.html">Agreements</a> - Use DNS-verified agents in agreements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-library-api"><a class="header" href="#rust-library-api">Rust Library API</a></h1>
<p>JACS provides a Rust library for programmatic agent and document management. This chapter covers how to use the JACS library in your Rust applications.</p>
<h2 id="adding-jacs-as-a-dependency"><a class="header" href="#adding-jacs-as-a-dependency">Adding JACS as a Dependency</a></h2>
<p>Add JACS to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
jacs = "0.3"
</code></pre>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<pre><code class="language-toml">[dependencies]
jacs = { version = "0.3", features = ["cli", "observability"] }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cli</code></td><td>CLI utilities and helpers</td></tr>
<tr><td><code>observability</code></td><td>OpenTelemetry logging and metrics</td></tr>
<tr><td><code>observability-convenience</code></td><td>Helper functions for observability</td></tr>
<tr><td><code>full</code></td><td>All features enabled</td></tr>
</tbody></table>
</div>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="agent"><a class="header" href="#agent">Agent</a></h3>
<p>The <code>Agent</code> struct is the central type in JACS. It holds:</p>
<ul>
<li>Schema validators</li>
<li>Agent identity and keys</li>
<li>Document storage</li>
<li>Configuration</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use jacs::{get_empty_agent, load_agent};
use std::error::Error;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Create a new empty agent
    let agent = get_empty_agent();

    // Or load an existing agent
    let agent = load_agent(Some("path/to/agent.json".to_string()))?;

    Ok(())
}</code></pre></pre>
<h3 id="jacsdocument"><a class="header" href="#jacsdocument">JACSDocument</a></h3>
<p>Documents in JACS are represented by the <code>JACSDocument</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct JACSDocument {
    pub id: String,
    pub version: String,
    pub value: serde_json::Value,
    pub jacs_type: String,
}
<span class="boring">}</span></code></pre></pre>
<p>Key methods:</p>
<ul>
<li><code>getkey()</code> - Returns <code>"id:version"</code> identifier</li>
<li><code>getvalue()</code> - Returns reference to the JSON value</li>
<li><code>getschema()</code> - Returns the document's schema URL</li>
<li><code>signing_agent()</code> - Returns the ID of the signing agent</li>
</ul>
<h2 id="creating-an-agent-1"><a class="header" href="#creating-an-agent-1">Creating an Agent</a></h2>
<h3 id="minimal-agent"><a class="header" href="#minimal-agent">Minimal Agent</a></h3>
<pre><pre class="playground"><code class="language-rust">use jacs::{get_empty_agent, create_minimal_blank_agent};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create agent JSON
    let agent_json = create_minimal_blank_agent(
        "ai".to_string(),                    // agent type
        Some("My service".to_string()),      // service description
        Some("Task completed".to_string()),  // success description
        Some("Task failed".to_string()),     // failure description
    )?;

    // Initialize and load the agent
    let mut agent = get_empty_agent();
    agent.create_agent_and_load(&amp;agent_json, true, None)?;

    // Save the agent
    agent.save()?;

    Ok(())
}</code></pre></pre>
<h3 id="loading-by-configuration"><a class="header" href="#loading-by-configuration">Loading by Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust">use jacs::get_empty_agent;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut agent = get_empty_agent();

    // Load from config file
    agent.load_by_config("./jacs.config.json".to_string())?;

    // Or load by agent ID
    agent.load_by_id("agent-id:version-id".to_string())?;

    Ok(())
}</code></pre></pre>
<h3 id="dns-strict-mode"><a class="header" href="#dns-strict-mode">DNS Strict Mode</a></h3>
<pre><pre class="playground"><code class="language-rust">use jacs::load_agent_with_dns_strict;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load agent with strict DNS verification
    let agent = load_agent_with_dns_strict(
        "path/to/agent.json".to_string(),
        true  // strict mode
    )?;

    Ok(())
}</code></pre></pre>
<h2 id="working-with-documents-1"><a class="header" href="#working-with-documents-1">Working with Documents</a></h2>
<h3 id="creating-documents-1"><a class="header" href="#creating-documents-1">Creating Documents</a></h3>
<p>The <code>DocumentTraits</code> trait provides document operations:</p>
<pre><pre class="playground"><code class="language-rust">use jacs::agent::document::DocumentTraits;
use jacs::get_empty_agent;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut agent = get_empty_agent();
    agent.load_by_config("./jacs.config.json".to_string())?;

    // Create a document from JSON
    let json = r#"{"title": "My Document", "content": "Hello, World!"}"#;
    let doc = agent.create_document_and_load(json, None, None)?;

    println!("Document created: {}", doc.getkey());

    Ok(())
}</code></pre></pre>
<h3 id="creating-documents-with-attachments"><a class="header" href="#creating-documents-with-attachments">Creating Documents with Attachments</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::agent::document::DocumentTraits;

// With file attachments
let attachments = Some(vec!["./report.pdf".to_string()]);
let embed = Some(true);  // Embed files in document

let doc = agent.create_document_and_load(
    json,
    attachments,
    embed
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-documents"><a class="header" href="#loading-documents">Loading Documents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::agent::document::DocumentTraits;

// Load a document from JSON string
let doc = agent.load_document(&amp;document_json_string)?;

// Get a stored document by key
let doc = agent.get_document("doc-id:version-id")?;

// List all document keys
let keys = agent.get_document_keys();
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-documents-1"><a class="header" href="#updating-documents-1">Updating Documents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::agent::document::DocumentTraits;

// Update creates a new version
let updated_doc = agent.update_document(
    "doc-id:version-id",    // original document key
    &amp;modified_json_string,  // new content
    None,                   // optional attachments
    None,                   // embed flag
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="verifying-documents-1"><a class="header" href="#verifying-documents-1">Verifying Documents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::agent::document::DocumentTraits;

// Verify document signature with agent's public key
agent.verify_document_signature(
    "doc-id:version-id",
    None,  // signature key (uses default)
    None,  // fields to verify
    None,  // public key (uses agent's)
    None,  // key encoding type
)?;

// Verify using external public key
agent.verify_external_document_signature("doc-id:version-id")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="saving-documents"><a class="header" href="#saving-documents">Saving Documents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::agent::document::DocumentTraits;

// Save document to filesystem
agent.save_document(
    "doc-id:version-id",
    Some("output.json".to_string()),  // output filename
    Some(true),                       // export embedded files
    None,                             // extract only
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-tasks"><a class="header" href="#creating-tasks">Creating Tasks</a></h2>
<pre><pre class="playground"><code class="language-rust">use jacs::{get_empty_agent, create_task};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut agent = get_empty_agent();
    agent.load_by_config("./jacs.config.json".to_string())?;

    // Create a task
    let task_json = create_task(
        &amp;mut agent,
        "Review Code".to_string(),
        "Review pull request #123".to_string(),
    )?;

    println!("Task created: {}", task_json);

    Ok(())
}</code></pre></pre>
<h2 id="signing-and-verification"><a class="header" href="#signing-and-verification">Signing and Verification</a></h2>
<h3 id="signing-documents"><a class="header" href="#signing-documents">Signing Documents</a></h3>
<p>The agent's <code>signing_procedure</code> method creates cryptographic signatures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::json;

let document = json!({
    "title": "Contract",
    "terms": "..."
});

// Sign the document
let signature = agent.signing_procedure(
    &amp;document,
    None,           // fields to sign (None = all)
    "jacsSignature" // placement key
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify self-signature (agent document)
agent.verify_self_signature()?;

// Verify hash integrity
agent.verify_hash(&amp;document)?;

// Full signature verification
agent.signature_verification_procedure(
    &amp;document,
    None,                    // fields
    "jacsSignature",         // signature key
    public_key,              // public key bytes
    Some("ring-Ed25519".to_string()),  // algorithm
    None,                    // original public key hash
    None,                    // signature override
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-schema-validation"><a class="header" href="#custom-schema-validation">Custom Schema Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load custom schemas
agent.load_custom_schemas(&amp;[
    "./schemas/invoice.schema.json".to_string(),
    "https://example.com/schemas/contract.schema.json".to_string(),
])?;

// Validate document against custom schema
agent.validate_document_with_custom_schema(
    "./schemas/invoice.schema.json",
    &amp;document_value,
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="loading-configuration"><a class="header" href="#loading-configuration">Loading Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::config::{load_config, find_config, Config};

// Load from specific path
let config = load_config("./jacs.config.json")?;

// Find config in directory
let config = find_config("./".to_string())?;

// Create programmatically
let config = Config::new(
    Some("false".to_string()),           // use_security
    Some("./jacs_data".to_string()),     // data_directory
    Some("./jacs_keys".to_string()),     // key_directory
    Some("private_key.pem".to_string()), // private key filename
    Some("public_key.pem".to_string()),  // public key filename
    Some("ring-Ed25519".to_string()),    // key algorithm
    Some("password".to_string()),        // private key password
    None,                                // agent ID and version
    Some("fs".to_string()),              // storage type
);
<span class="boring">}</span></code></pre></pre>
<h3 id="accessing-configuration"><a class="header" href="#accessing-configuration">Accessing Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get key algorithm
let algorithm = config.get_key_algorithm()?;

// Access config fields
let data_dir = config.jacs_data_directory();
let key_dir = config.jacs_key_directory();
let storage_type = config.jacs_default_storage();
<span class="boring">}</span></code></pre></pre>
<h2 id="observability"><a class="header" href="#observability">Observability</a></h2>
<h3 id="initialize-default-observability"><a class="header" href="#initialize-default-observability">Initialize Default Observability</a></h3>
<pre><pre class="playground"><code class="language-rust">use jacs::init_default_observability;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Set up file-based logging
    init_default_observability()?;

    // Your application code...

    Ok(())
}</code></pre></pre>
<h3 id="custom-observability-configuration"><a class="header" href="#custom-observability-configuration">Custom Observability Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust">use jacs::{
    init_custom_observability,
    ObservabilityConfig,
    LogConfig,
    LogDestination,
    MetricsConfig,
    MetricsDestination,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config = ObservabilityConfig {
        logs: LogConfig {
            enabled: true,
            level: "debug".to_string(),
            destination: LogDestination::Otlp {
                endpoint: "http://localhost:4317".to_string(),
                headers: None,
            },
            headers: None,
        },
        metrics: MetricsConfig {
            enabled: true,
            destination: MetricsDestination::Prometheus {
                endpoint: "http://localhost:9090".to_string(),
                headers: None,
            },
            export_interval_seconds: Some(30),
            headers: None,
        },
        tracing: None,
    };

    init_custom_observability(config)?;

    Ok(())
}</code></pre></pre>
<h2 id="storage-backends"><a class="header" href="#storage-backends">Storage Backends</a></h2>
<p>JACS supports multiple storage backends:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::storage::MultiStorage;

// Filesystem storage (default)
let storage = MultiStorage::new("fs".to_string())?;

// In-memory storage
let storage = MultiStorage::new("memory".to_string())?;

// S3 storage
let storage = MultiStorage::new("s3".to_string())?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>JACS functions return <code>Result&lt;T, Box&lt;dyn Error&gt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use jacs::get_empty_agent;

fn main() {
    match get_empty_agent().load_by_config("./jacs.config.json".to_string()) {
        Ok(()) =&gt; println!("Agent loaded successfully"),
        Err(e) =&gt; eprintln!("Failed to load agent: {}", e),
    }
}</code></pre></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>The <code>Agent</code> struct uses internal mutexes for thread-safe access to:</p>
<ul>
<li>Document schemas (<code>Arc&lt;Mutex&lt;HashMap&lt;String, Validator&gt;&gt;&gt;</code>)</li>
<li>Storage operations</li>
</ul>
<p>For concurrent usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use jacs::get_empty_agent;

let agent = Arc::new(Mutex::new(get_empty_agent()));

// Clone Arc for threads
let agent_clone = Arc::clone(&amp;agent);
std::thread::spawn(move || {
    let mut agent = agent_clone.lock().unwrap();
    // Use agent...
});
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use jacs::{get_empty_agent, create_task};
use jacs::agent::document::DocumentTraits;
use serde_json::json;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize agent
    let mut agent = get_empty_agent();
    agent.load_by_config("./jacs.config.json".to_string())?;

    // Create a document
    let doc_json = json!({
        "title": "Project Proposal",
        "description": "Q1 development plan",
        "budget": 50000
    });

    let doc = agent.create_document_and_load(
        &amp;doc_json.to_string(),
        None,
        None
    )?;

    println!("Created document: {}", doc.getkey());

    // Verify the document
    agent.verify_document_signature(&amp;doc.getkey(), None, None, None, None)?;
    println!("Document verified successfully");

    // Save to file
    agent.save_document(&amp;doc.getkey(), Some("proposal.json".to_string()), None, None)?;

    // Create a task
    let task = create_task(
        &amp;mut agent,
        "Review Proposal".to_string(),
        "Review and approve the project proposal".to_string(),
    )?;

    println!("Task created");

    Ok(())
}</code></pre></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="rust/observability.html">Observability</a> - Logging and metrics setup</li>
<li><a href="rust/../advanced/storage.html">Storage Backends</a> - Configure different storage</li>
<li><a href="rust/../advanced/custom-schemas.html">Custom Schemas</a> - Define custom document types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability-1"><a class="header" href="#observability-1">Observability</a></h1>
<p>JACS provides comprehensive observability features including logging, metrics, and distributed tracing. This chapter covers configuring and using these features in your applications.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>JACS observability is built on the OpenTelemetry standard, providing:</p>
<ul>
<li><strong>Logging</strong>: Structured logging with multiple destinations</li>
<li><strong>Metrics</strong>: Counters, gauges, and histograms for monitoring</li>
<li><strong>Tracing</strong>: Distributed tracing for request flows</li>
</ul>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<p>Enable observability features in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
jacs = { version = "0.3", features = ["observability"] }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>observability</code></td><td>Core observability support</td></tr>
<tr><td><code>observability-convenience</code></td><td>Helper functions for recording operations</td></tr>
<tr><td><code>otlp-logs</code></td><td>OTLP log export support</td></tr>
<tr><td><code>otlp-metrics</code></td><td>OTLP metrics export support</td></tr>
<tr><td><code>otlp-tracing</code></td><td>OTLP distributed tracing support</td></tr>
</tbody></table>
</div>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<h3 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h3>
<p>The simplest way to enable observability:</p>
<pre><pre class="playground"><code class="language-rust">use jacs::init_default_observability;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    init_default_observability()?;

    // Your application code...

    Ok(())
}</code></pre></pre>
<p>This sets up:</p>
<ul>
<li>File-based logging to <code>./logs/</code> with daily rotation</li>
<li>Metrics disabled by default</li>
<li>Tracing disabled by default</li>
</ul>
<h3 id="custom-configuration"><a class="header" href="#custom-configuration">Custom Configuration</a></h3>
<p>For more control, use <code>init_custom_observability</code>:</p>
<pre><pre class="playground"><code class="language-rust">use jacs::{
    init_custom_observability,
    ObservabilityConfig,
    LogConfig,
    LogDestination,
    MetricsConfig,
    MetricsDestination,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config = ObservabilityConfig {
        logs: LogConfig {
            enabled: true,
            level: "info".to_string(),
            destination: LogDestination::Stderr,
            headers: None,
        },
        metrics: MetricsConfig {
            enabled: false,
            destination: MetricsDestination::Stdout,
            export_interval_seconds: None,
            headers: None,
        },
        tracing: None,
    };

    init_custom_observability(config)?;
    Ok(())
}</code></pre></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<p>Supported log levels (from most to least verbose):</p>
<ul>
<li><code>trace</code></li>
<li><code>debug</code></li>
<li><code>info</code></li>
<li><code>warn</code></li>
<li><code>error</code></li>
</ul>
<h3 id="log-destinations"><a class="header" href="#log-destinations">Log Destinations</a></h3>
<h4 id="stderr-default"><a class="header" href="#stderr-default">Stderr (Default)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LogDestination::Stderr
<span class="boring">}</span></code></pre></pre>
<p>Logs to standard error. Useful for development and containerized environments.</p>
<h4 id="file"><a class="header" href="#file">File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LogDestination::File {
    path: "./logs".to_string(),
}
<span class="boring">}</span></code></pre></pre>
<p>Logs to rotating files with daily rotation. Creates files like <code>app.log.2024-01-15</code>.</p>
<h4 id="otlp"><a class="header" href="#otlp">OTLP</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LogDestination::Otlp {
    endpoint: "http://localhost:4318".to_string(),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<p>Exports logs via OpenTelemetry Protocol. Requires <code>otlp-logs</code> feature.</p>
<h4 id="null"><a class="header" href="#null">Null</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LogDestination::Null
<span class="boring">}</span></code></pre></pre>
<p>Disables logging completely.</p>
<h3 id="using-logs"><a class="header" href="#using-logs">Using Logs</a></h3>
<p>JACS uses the <code>tracing</code> crate for logging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, debug, warn, error};

fn process_document() {
    info!("Processing document");
    debug!("Document details: {:?}", doc);

    if let Err(e) = verify() {
        error!("Verification failed: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<h3 id="enabling-metrics"><a class="header" href="#enabling-metrics">Enabling Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetricsConfig {
    enabled: true,
    destination: MetricsDestination::Otlp {
        endpoint: "http://localhost:4318".to_string(),
        headers: None,
    },
    export_interval_seconds: Some(30),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-destinations"><a class="header" href="#metrics-destinations">Metrics Destinations</a></h3>
<h4 id="otlp-1"><a class="header" href="#otlp-1">OTLP</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetricsDestination::Otlp {
    endpoint: "http://localhost:4318".to_string(),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<p>Exports to an OpenTelemetry collector. Requires <code>otlp-metrics</code> feature.</p>
<h4 id="prometheus-via-collector"><a class="header" href="#prometheus-via-collector">Prometheus (via Collector)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetricsDestination::Prometheus {
    endpoint: "http://localhost:9090".to_string(),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<p>Note: Direct Prometheus export requires routing through an OTLP collector.</p>
<h4 id="file-1"><a class="header" href="#file-1">File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetricsDestination::File {
    path: "./metrics.txt".to_string(),
}
<span class="boring">}</span></code></pre></pre>
<p>Writes metrics to a file.</p>
<h4 id="stdout"><a class="header" href="#stdout">Stdout</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetricsDestination::Stdout
<span class="boring">}</span></code></pre></pre>
<p>Prints metrics to standard output. Useful for testing.</p>
<h3 id="recording-metrics"><a class="header" href="#recording-metrics">Recording Metrics</a></h3>
<p>JACS provides convenience functions for common metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::observability::metrics::{increment_counter, set_gauge, record_histogram};
use std::collections::HashMap;

// Increment a counter
let mut tags = HashMap::new();
tags.insert("operation".to_string(), "sign".to_string());
increment_counter("jacs_operations_total", 1, Some(tags));

// Set a gauge value
set_gauge("jacs_documents_active", 42.0, None);

// Record a histogram value (e.g., latency)
let mut tags = HashMap::new();
tags.insert("method".to_string(), "verify".to_string());
record_histogram("jacs_operation_duration_ms", 150.0, Some(tags));
<span class="boring">}</span></code></pre></pre>
<h3 id="built-in-metrics"><a class="header" href="#built-in-metrics">Built-in Metrics</a></h3>
<p>When <code>observability-convenience</code> feature is enabled, JACS automatically records:</p>
<ul>
<li><code>jacs_agent_operations</code> - Count of agent operations</li>
<li><code>jacs_signature_verifications</code> - Signature verification results</li>
<li><code>jacs_document_operations</code> - Document create/update/verify counts</li>
</ul>
<h2 id="distributed-tracing"><a class="header" href="#distributed-tracing">Distributed Tracing</a></h2>
<h3 id="enabling-tracing"><a class="header" href="#enabling-tracing">Enabling Tracing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::{TracingConfig, TracingDestination, SamplingConfig, ResourceConfig};
use std::collections::HashMap;

let config = ObservabilityConfig {
    // ... logs and metrics config ...
    tracing: Some(TracingConfig {
        enabled: true,
        sampling: SamplingConfig {
            ratio: 1.0,           // Sample all traces
            parent_based: true,
            rate_limit: None,
        },
        resource: Some(ResourceConfig {
            service_name: "my-jacs-app".to_string(),
            service_version: Some("1.0.0".to_string()),
            environment: Some("production".to_string()),
            attributes: HashMap::new(),
        }),
        destination: Some(TracingDestination::Otlp {
            endpoint: "http://localhost:4318".to_string(),
            headers: None,
        }),
    }),
};
<span class="boring">}</span></code></pre></pre>
<h3 id="tracing-destinations"><a class="header" href="#tracing-destinations">Tracing Destinations</a></h3>
<h4 id="otlp-2"><a class="header" href="#otlp-2">OTLP</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TracingDestination::Otlp {
    endpoint: "http://localhost:4318".to_string(),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="jaeger"><a class="header" href="#jaeger">Jaeger</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TracingDestination::Jaeger {
    endpoint: "http://localhost:14268/api/traces".to_string(),
    headers: None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sampling-configuration"><a class="header" href="#sampling-configuration">Sampling Configuration</a></h3>
<p>Control how many traces are captured:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SamplingConfig {
    ratio: 0.1,          // Sample 10% of traces
    parent_based: true,  // Inherit parent sampling decision
    rate_limit: Some(100), // Max 100 samples per second
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-tracing-spans"><a class="header" href="#using-tracing-spans">Using Tracing Spans</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{instrument, info_span};

#[instrument]
fn sign_document(doc: &amp;Document) -&gt; Result&lt;(), Error&gt; {
    // Automatically creates a span named "sign_document"
    // with doc as a field
}

fn manual_span() {
    let span = info_span!("verify_chain", doc_count = 5);
    let _guard = span.enter();

    // Operations within this span
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h2>
<p>You can configure observability via <code>jacs.config.json</code>:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "observability": {
    "logs": {
      "enabled": true,
      "level": "info",
      "destination": {
        "file": {
          "path": "./logs"
        }
      }
    },
    "metrics": {
      "enabled": true,
      "destination": {
        "otlp": {
          "endpoint": "http://localhost:4318"
        }
      },
      "export_interval_seconds": 30
    },
    "tracing": {
      "enabled": true,
      "sampling": {
        "ratio": 1.0,
        "parent_based": true
      },
      "resource": {
        "service_name": "jacs-service",
        "service_version": "1.0.0",
        "environment": "production"
      },
      "destination": {
        "otlp": {
          "endpoint": "http://localhost:4318"
        }
      }
    }
  }
}
</code></pre>
<h2 id="opentelemetry-collector-setup"><a class="header" href="#opentelemetry-collector-setup">OpenTelemetry Collector Setup</a></h2>
<p>For production use, route telemetry through an OpenTelemetry Collector:</p>
<pre><code class="language-yaml"># otel-collector-config.yaml
receivers:
  otlp:
    protocols:
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  prometheus:
    endpoint: "0.0.0.0:9090"
  jaeger:
    endpoint: jaeger:14250

service:
  pipelines:
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus]
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger]
</code></pre>
<h2 id="reset-and-cleanup"><a class="header" href="#reset-and-cleanup">Reset and Cleanup</a></h2>
<p>For testing or reinitialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::observability::{reset_observability, flush_observability, force_reset_for_tests};

// Flush pending data
flush_observability();

// Reset configuration
reset_observability();

// Force reset for tests (clears all state)
force_reset_for_tests();
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = ObservabilityConfig {
    logs: LogConfig {
        enabled: true,
        level: "debug".to_string(),
        destination: LogDestination::Stderr,
        headers: None,
    },
    metrics: MetricsConfig {
        enabled: false,
        destination: MetricsDestination::Stdout,
        export_interval_seconds: None,
        headers: None,
    },
    tracing: None,
};
<span class="boring">}</span></code></pre></pre>
<h3 id="production"><a class="header" href="#production">Production</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = ObservabilityConfig {
    logs: LogConfig {
        enabled: true,
        level: "info".to_string(),
        destination: LogDestination::Otlp {
            endpoint: "http://collector:4318".to_string(),
            headers: Some(auth_headers()),
        },
        headers: None,
    },
    metrics: MetricsConfig {
        enabled: true,
        destination: MetricsDestination::Otlp {
            endpoint: "http://collector:4318".to_string(),
            headers: Some(auth_headers()),
        },
        export_interval_seconds: Some(30),
        headers: None,
    },
    tracing: Some(TracingConfig {
        enabled: true,
        sampling: SamplingConfig {
            ratio: 0.1,  // Sample 10% in production
            parent_based: true,
            rate_limit: Some(1000),
        },
        resource: Some(ResourceConfig {
            service_name: "jacs-production".to_string(),
            service_version: Some(env!("CARGO_PKG_VERSION").to_string()),
            environment: Some("production".to_string()),
            attributes: HashMap::new(),
        }),
        destination: Some(TracingDestination::Otlp {
            endpoint: "http://collector:4318".to_string(),
            headers: Some(auth_headers()),
        }),
    }),
};
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="logs-not-appearing"><a class="header" href="#logs-not-appearing">Logs Not Appearing</a></h3>
<ol>
<li>Check that logging is enabled: <code>logs.enabled: true</code></li>
<li>Verify log level includes your log statements</li>
<li>For file logging, ensure the directory is writable</li>
</ol>
<h3 id="metrics-not-exporting"><a class="header" href="#metrics-not-exporting">Metrics Not Exporting</a></h3>
<ol>
<li>Verify <code>otlp-metrics</code> feature is enabled</li>
<li>Check endpoint connectivity</li>
<li>Confirm metrics are enabled: <code>metrics.enabled: true</code></li>
</ol>
<h3 id="traces-missing"><a class="header" href="#traces-missing">Traces Missing</a></h3>
<ol>
<li>Verify <code>otlp-tracing</code> feature is enabled</li>
<li>Check sampling ratio isn't filtering all traces</li>
<li>Ensure spans are properly instrumented</li>
</ol>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="rust/library.html">Rust Library API</a> - Use observability in your code</li>
<li><a href="rust/../reference/configuration.html">Configuration Reference</a> - Full config options</li>
<li><a href="rust/../advanced/security.html">Advanced Topics</a> - Security considerations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-installation"><a class="header" href="#nodejs-installation">Node.js Installation</a></h1>
<p>The JACS Node.js package (<code>@hai.ai/jacs</code>) provides JavaScript/TypeScript bindings to the JACS Rust library, making it easy to integrate JACS into web applications, servers, and Node.js projects.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li><strong>Node.js</strong>: Version 16.0 or higher</li>
<li><strong>npm</strong> or <strong>yarn</strong>: For package management</li>
<li><strong>Operating System</strong>: macOS, Linux, or Windows with WSL</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="using-npm"><a class="header" href="#using-npm">Using npm</a></h3>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
<h3 id="using-yarn"><a class="header" href="#using-yarn">Using yarn</a></h3>
<pre><code class="language-bash">yarn add @hai.ai/jacs
</code></pre>
<h3 id="using-pnpm"><a class="header" href="#using-pnpm">Using pnpm</a></h3>
<pre><code class="language-bash">pnpm add @hai.ai/jacs
</code></pre>
<h2 id="verify-installation-1"><a class="header" href="#verify-installation-1">Verify Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre><code class="language-javascript">// test.js
import { JacsAgent } from '@hai.ai/jacs';

console.log('JACS Node.js bindings loaded successfully!');

// Test basic functionality
try {
  const agent = new JacsAgent();
  agent.load('./jacs.config.json');
  console.log('Agent loaded successfully!');
} catch (error) {
  console.error('Error loading agent:', error);
}
</code></pre>
<p>Run the test:</p>
<pre><code class="language-bash">node test.js
</code></pre>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<p>The <code>@hai.ai/jacs</code> package includes several modules:</p>
<h3 id="core-module-haiaijacs"><a class="header" href="#core-module-haiaijacs">Core Module (<code>@hai.ai/jacs</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsAgent,
  JacsConfig,
  JacsDocument,
  JacsError
} from '@hai.ai/jacs';
</code></pre>
<h3 id="mcp-integration-haiaijacsmcp"><a class="header" href="#mcp-integration-haiaijacsmcp">MCP Integration (<code>@hai.ai/jacs/mcp</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsMcpServer,
  createJacsMiddleware 
} from '@hai.ai/jacs/mcp';
</code></pre>
<h3 id="http-server-haiaijacshttp"><a class="header" href="#http-server-haiaijacshttp">HTTP Server (<code>@hai.ai/jacs/http</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsHttpServer,
  createJacsRouter 
} from '@hai.ai/jacs/http';
</code></pre>
<h2 id="typescript-support"><a class="header" href="#typescript-support">TypeScript Support</a></h2>
<p>The package includes full TypeScript definitions:</p>
<pre><code class="language-typescript">import { JacsAgent, createConfig, hashString } from '@hai.ai/jacs';

// Create an agent instance
const agent: JacsAgent = new JacsAgent();

// Load configuration from file
agent.load('./jacs.config.json');

// Use utility functions
const hash: string = hashString('some data');

// Create a configuration string
const configJson: string = createConfig(
  undefined,           // jacs_use_security
  './jacs_data',       // jacs_data_directory
  './jacs_keys',       // jacs_key_directory
  undefined,           // jacs_agent_private_key_filename
  undefined,           // jacs_agent_public_key_filename
  'ring-Ed25519',      // jacs_agent_key_algorithm
  undefined,           // jacs_private_key_password
  undefined,           // jacs_agent_id_and_version
  'fs'                 // jacs_default_storage
);
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h3>
<pre><code class="language-javascript">const config = {
  // Required fields
  jacs_data_directory: "./jacs_data",      // Where documents are stored
  jacs_key_directory: "./jacs_keys",       // Where keys are stored
  jacs_default_storage: "fs",              // Storage backend
  jacs_agent_key_algorithm: "ring-Ed25519",     // Signing algorithm
  
  // Optional fields
  jacs_agent_id_and_version: null,         // Existing agent to load
  jacs_agent_private_key_filename: "private.pem",
  jacs_agent_public_key_filename: "public.pem"
};
</code></pre>
<h3 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration File</a></h3>
<p>Create a <code>jacs.config.json</code> file:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p>Load the configuration:</p>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');
</code></pre>
<h3 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h3>
<p>JACS reads environment variables that override configuration file settings:</p>
<pre><code class="language-bash">export JACS_DATA_DIRECTORY="./production_data"
export JACS_KEY_DIRECTORY="./production_keys"
export JACS_AGENT_KEY_ALGORITHM="ring-Ed25519"
export JACS_DEFAULT_STORAGE="fs"
</code></pre>
<h2 id="storage-backends-1"><a class="header" href="#storage-backends-1">Storage Backends</a></h2>
<p>Configure storage in <code>jacs.config.json</code>:</p>
<h3 id="file-system-default"><a class="header" href="#file-system-default">File System (Default)</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<h3 id="s3-storage"><a class="header" href="#s3-storage">S3 Storage</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "s3"
}
</code></pre>
<p>S3 credentials are read from standard AWS environment variables.</p>
<h3 id="memory-storage-testing"><a class="header" href="#memory-storage-testing">Memory Storage (Testing)</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "memory"
}
</code></pre>
<h2 id="cryptographic-algorithms"><a class="header" href="#cryptographic-algorithms">Cryptographic Algorithms</a></h2>
<h3 id="ring-ed25519-recommended"><a class="header" href="#ring-ed25519-recommended">ring-Ed25519 (Recommended)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p><strong>Pros</strong>: Fast, secure, small signatures
<strong>Cons</strong>: Requires elliptic curve support</p>
<h3 id="rsa-pss"><a class="header" href="#rsa-pss">RSA-PSS</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "RSA-PSS"
}
</code></pre>
<p><strong>Pros</strong>: Widely supported, proven security
<strong>Cons</strong>: Larger signatures, slower</p>
<h3 id="pq-dilithium-post-quantum"><a class="header" href="#pq-dilithium-post-quantum">pq-dilithium (Post-Quantum)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
<p><strong>Pros</strong>: Quantum-resistant
<strong>Cons</strong>: Experimental, large signatures</p>
<h3 id="pq2025-post-quantum-hybrid"><a class="header" href="#pq2025-post-quantum-hybrid">pq2025 (Post-Quantum Hybrid)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq2025"
}
</code></pre>
<p><strong>Pros</strong>: Combines ML-DSA-87 with hybrid approach
<strong>Cons</strong>: Newest algorithm, largest signatures</p>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code>my-jacs-project/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ jacs.config.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ agent.js
‚îÇ   ‚îú‚îÄ‚îÄ tasks.js
‚îÇ   ‚îî‚îÄ‚îÄ agreements.js
‚îú‚îÄ‚îÄ jacs_data/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îî‚îÄ‚îÄ documents/
‚îî‚îÄ‚îÄ jacs_keys/
    ‚îú‚îÄ‚îÄ private.pem
    ‚îî‚îÄ‚îÄ public.pem
</code></pre>
<h3 id="packagejson-setup"><a class="header" href="#packagejson-setup">Package.json Setup</a></h3>
<pre><code class="language-json">{
  "name": "my-jacs-app",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@hai.ai/jacs": "^0.6.0",
    "express": "^4.18.0"
  },
  "scripts": {
    "start": "node src/app.js",
    "test": "node test/test.js",
    "dev": "nodemon src/app.js"
  }
}
</code></pre>
<h3 id="basic-application"><a class="header" href="#basic-application">Basic Application</a></h3>
<pre><code class="language-javascript">// src/app.js
import { JacsAgent } from '@hai.ai/jacs';

// Create and load agent
const agent = new JacsAgent();
agent.load('./jacs.config.json');

// Create a document
const documentJson = JSON.stringify({
  title: "My First Document",
  content: "Hello from Node.js!"
});

const signedDoc = agent.createDocument(documentJson);
console.log('Document created:', signedDoc);

// Verify the document
const isValid = agent.verifyDocument(signedDoc);
console.log('Document valid:', isValid);

console.log('JACS agent ready!');
</code></pre>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h3 id="module-not-found"><a class="header" href="#module-not-found">Module Not Found</a></h3>
<p>If you get <code>Module not found</code> errors:</p>
<pre><code class="language-bash"># Check Node.js version
node --version  # Should be 16+

# Clear node_modules and reinstall
rm -rf node_modules package-lock.json
npm install
</code></pre>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<p>If you get permission errors accessing files:</p>
<pre><code class="language-bash"># Check directory permissions
ls -la jacs_data/ jacs_keys/

# Fix permissions
chmod 755 jacs_data/ jacs_keys/
chmod 600 jacs_keys/*.pem
</code></pre>
<h3 id="binary-compatibility"><a class="header" href="#binary-compatibility">Binary Compatibility</a></h3>
<p>If you get binary compatibility errors:</p>
<pre><code class="language-bash"># Rebuild native modules
npm rebuild

# Or reinstall
npm uninstall @hai.ai/jacs
npm install @hai.ai/jacs
</code></pre>
<h3 id="typescript-issues"><a class="header" href="#typescript-issues">TypeScript Issues</a></h3>
<p>If TypeScript can't find definitions:</p>
<pre><code class="language-json">// tsconfig.json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>Now that you have JACS installed:</p>
<ol>
<li><strong><a href="nodejs/basic-usage.html">Basic Usage</a></strong> - Learn core JACS operations</li>
<li><strong><a href="nodejs/mcp.html">MCP Integration</a></strong> - Add Model Context Protocol support</li>
<li><strong><a href="nodejs/http.html">HTTP Server</a></strong> - Create JACS HTTP APIs</li>
<li><strong><a href="nodejs/express.html">Express Middleware</a></strong> - Integrate with Express.js</li>
<li><strong><a href="nodejs/api.html">API Reference</a></strong> - Complete API documentation</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Check out the complete examples in the <a href="nodejs/../examples/nodejs.html">examples directory</a>:</p>
<ul>
<li>Basic agent creation and task management</li>
<li>Express.js middleware integration</li>
<li>MCP server implementation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplified-api"><a class="header" href="#simplified-api">Simplified API</a></h1>
<p>The simplified API (<code>@hai.ai/jacs/simple</code>) provides a streamlined, module-level interface for common JACS operations. It's designed to get you signing and verifying in under 2 minutes.</p>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<p>Zero-config -- one call to start signing:</p>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

jacs.quickstart();
const signed = jacs.signMessage({ action: 'approve', amount: 100 });
const result = jacs.verify(signed.raw);
console.log(`Valid: ${result.valid}, Signer: ${result.signerId}`);
</code></pre>
<p><code>quickstart()</code> creates an ephemeral agent with keys in memory. No config file, no setup. Pass <code>{ algorithm: 'ring-Ed25519' }</code> to override the default (<code>pq2025</code>).</p>
<p>For production use with persistent keys, load from a config file instead:</p>
<pre><code class="language-javascript">const agent = jacs.load('./jacs.config.json');
const signed = jacs.signMessage({ action: 'approve', amount: 100 });
</code></pre>
<h2 id="when-to-use-the-simplified-api"><a class="header" href="#when-to-use-the-simplified-api">When to Use the Simplified API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Simplified API</th><th>JacsAgent Class</th></tr></thead><tbody>
<tr><td>Quick prototyping</td><td>Multiple agents in one process</td></tr>
<tr><td>Scripts and CLI tools</td><td>Complex multi-document workflows</td></tr>
<tr><td>MCP tool implementations</td><td>Fine-grained control</td></tr>
<tr><td>Single-agent applications</td><td>Custom error handling</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<h3 id="quickstartoptions"><a class="header" href="#quickstartoptions">quickstart(options?)</a></h3>
<p>Create an ephemeral agent with keys in memory. No config file, no directories, no setup. Call this once before <code>signMessage()</code> or <code>verify()</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (object, optional): <code>{ algorithm?: string }</code>. Default algorithm: <code>"pq2025"</code>. Also: <code>"ring-Ed25519"</code>, <code>"RSA-PSS"</code>.</li>
</ul>
<p><strong>Returns:</strong> <code>AgentInfo</code> object</p>
<pre><code class="language-javascript">const info = jacs.quickstart();
console.log(`Agent ID: ${info.agentId}`);

// Or with a specific algorithm
const info = jacs.quickstart({ algorithm: 'ring-Ed25519' });
</code></pre>
<hr />
<h3 id="loadconfigpath"><a class="header" href="#loadconfigpath">load(configPath?)</a></h3>
<p>Load a persistent agent from a configuration file. Use this instead of <code>quickstart()</code> when you need keys on disk.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>configPath</code> (string, optional): Path to jacs.config.json (default: "./jacs.config.json")</li>
</ul>
<p><strong>Returns:</strong> <code>AgentInfo</code> object</p>
<pre><code class="language-javascript">const info = jacs.load('./jacs.config.json');
console.log(`Agent ID: ${info.agentId}`);
console.log(`Config: ${info.configPath}`);
</code></pre>
<hr />
<h3 id="isloaded"><a class="header" href="#isloaded">isLoaded()</a></h3>
<p>Check if an agent is currently loaded.</p>
<p><strong>Returns:</strong> boolean</p>
<pre><code class="language-javascript">if (!jacs.isLoaded()) {
  jacs.load('./jacs.config.json');
}
</code></pre>
<hr />
<h3 id="getagentinfo"><a class="header" href="#getagentinfo">getAgentInfo()</a></h3>
<p>Get information about the currently loaded agent.</p>
<p><strong>Returns:</strong> <code>AgentInfo</code> or null if no agent is loaded</p>
<pre><code class="language-javascript">const info = jacs.getAgentInfo();
if (info) {
  console.log(`Agent: ${info.agentId}`);
}
</code></pre>
<hr />
<h3 id="verifyself"><a class="header" href="#verifyself">verifySelf()</a></h3>
<p>Verify the loaded agent's own integrity (signature and hash).</p>
<p><strong>Returns:</strong> <code>VerificationResult</code></p>
<p><strong>Throws:</strong> Error if no agent is loaded</p>
<pre><code class="language-javascript">const result = jacs.verifySelf();
if (result.valid) {
  console.log('Agent integrity verified');
} else {
  console.log('Errors:', result.errors);
}
</code></pre>
<hr />
<h3 id="signmessagedata"><a class="header" href="#signmessagedata">signMessage(data)</a></h3>
<p>Sign arbitrary data as a JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (any): Object, array, string, or any JSON-serializable value</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code></p>
<p><strong>Throws:</strong> Error if no agent is loaded</p>
<pre><code class="language-javascript">// Sign an object
const signed = jacs.signMessage({
  action: 'transfer',
  amount: 500,
  recipient: 'agent-123'
});

console.log(`Document ID: ${signed.documentId}`);
console.log(`Signed by: ${signed.agentId}`);
console.log(`Timestamp: ${signed.timestamp}`);
console.log(`Raw JSON: ${signed.raw}`);
</code></pre>
<hr />
<h3 id="signfilefilepath-embed"><a class="header" href="#signfilefilepath-embed">signFile(filePath, embed?)</a></h3>
<p>Sign a file with optional content embedding.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>filePath</code> (string): Path to the file to sign</li>
<li><code>embed</code> (boolean, optional): If true, embed file content in the document (default: false)</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code></p>
<p><strong>Throws:</strong> Error if file not found or no agent loaded</p>
<pre><code class="language-javascript">// Reference only (stores hash)
const signed = jacs.signFile('contract.pdf', false);

// Embed content (creates portable document)
const embedded = jacs.signFile('contract.pdf', true);
</code></pre>
<hr />
<h3 id="verifysigneddocument"><a class="header" href="#verifysigneddocument">verify(signedDocument)</a></h3>
<p>Verify a signed document and extract its content.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>signedDocument</code> (string): The JSON string of the signed document</li>
</ul>
<p><strong>Returns:</strong> <code>VerificationResult</code></p>
<p><strong>Throws:</strong> Error if no agent is loaded</p>
<pre><code class="language-javascript">const result = jacs.verify(signedJson);

if (result.valid) {
  console.log(`Signed by: ${result.signerId}`);
  console.log(`Timestamp: ${result.timestamp}`);
  console.log(`Data: ${JSON.stringify(result.data)}`);
} else {
  console.log(`Invalid: ${result.errors.join(', ')}`);
}
</code></pre>
<hr />
<h3 id="verifystandalonesigneddocument-options"><a class="header" href="#verifystandalonesigneddocument-options">verifyStandalone(signedDocument, options?)</a></h3>
<p>Verify a signed document <strong>without</strong> loading an agent. Use when you only need to verify (e.g. a lightweight API). Does not use the global agent.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>signedDocument</code> (string): The signed JACS document JSON</li>
<li><code>options</code> (object, optional): <code>{ keyResolution?, dataDirectory?, keyDirectory? }</code></li>
</ul>
<p><strong>Returns:</strong> <code>VerificationResult</code> (same shape as <code>verify()</code>)</p>
<pre><code class="language-javascript">const result = jacs.verifyStandalone(signedJson, { keyResolution: 'local', keyDirectory: './keys' });
console.log(result.valid, result.signerId);
</code></pre>
<hr />
<h3 id="auditoptions"><a class="header" href="#auditoptions">audit(options?)</a></h3>
<p>Run a read-only security audit and health checks. Returns an object with <code>risks</code>, <code>health_checks</code>, <code>summary</code>, and <code>overall_status</code>. Does not require a loaded agent; does not modify state.</p>
<p><strong>Parameters:</strong> <code>options</code> (object, optional): <code>{ configPath?, recentN? }</code></p>
<p><strong>Returns:</strong> Object with <code>risks</code>, <code>health_checks</code>, <code>summary</code>, <code>overall_status</code>, etc.</p>
<p>See <a href="nodejs/../advanced/security.html#security-audit-audit">Security Model ‚Äî Security Audit</a> for full details and options.</p>
<pre><code class="language-javascript">const result = jacs.audit();
console.log(`Risks: ${result.risks.length}, Status: ${result.overall_status}`);
</code></pre>
<hr />
<h3 id="updateagentnewagentdata"><a class="header" href="#updateagentnewagentdata">updateAgent(newAgentData)</a></h3>
<p>Update the agent document with new data and re-sign it.</p>
<p>This function expects a <strong>complete agent document</strong> (not partial updates). Use <code>exportAgent()</code> to get the current document, modify it, then pass it here.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>newAgentData</code> (object|string): Complete agent document as JSON string or object</li>
</ul>
<p><strong>Returns:</strong> string - The updated and re-signed agent document</p>
<p><strong>Throws:</strong> Error if no agent loaded or validation fails</p>
<pre><code class="language-javascript">// Get current agent document
const agentDoc = JSON.parse(jacs.exportAgent());

// Modify fields
agentDoc.jacsAgentType = 'hybrid';
agentDoc.jacsContacts = [{ contactFirstName: 'Jane', contactLastName: 'Doe' }];

// Update (creates new version, re-signs, re-hashes)
const updated = jacs.updateAgent(agentDoc);
const newDoc = JSON.parse(updated);

console.log(`New version: ${newDoc.jacsVersion}`);
console.log(`Previous: ${newDoc.jacsPreviousVersion}`);
</code></pre>
<p><strong>Valid <code>jacsAgentType</code> values:</strong> <code>"human"</code>, <code>"human-org"</code>, <code>"hybrid"</code>, <code>"ai"</code></p>
<hr />
<h3 id="updatedocumentdocumentid-newdocumentdata-attachments-embed"><a class="header" href="#updatedocumentdocumentid-newdocumentdata-attachments-embed">updateDocument(documentId, newDocumentData, attachments?, embed?)</a></h3>
<p>Update an existing document with new data and re-sign it.</p>
<p><strong>Note:</strong> The original document must have been saved to disk (created without <code>noSave: true</code>).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentId</code> (string): The document ID (jacsId) to update</li>
<li><code>newDocumentData</code> (object|string): Updated document as JSON string or object</li>
<li><code>attachments</code> (string[], optional): Array of file paths to attach</li>
<li><code>embed</code> (boolean, optional): If true, embed attachment contents</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code> with the updated document</p>
<p><strong>Throws:</strong> Error if document not found, no agent loaded, or validation fails</p>
<pre><code class="language-javascript">// Create a document (must be saved to disk)
const original = jacs.signMessage({ status: 'pending', amount: 100 });

// Later, update it
const doc = JSON.parse(original.raw);
doc.content.status = 'approved';

const updated = jacs.updateDocument(original.documentId, doc);
const newDoc = JSON.parse(updated.raw);

console.log(`New version: ${newDoc.jacsVersion}`);
console.log(`Previous: ${newDoc.jacsPreviousVersion}`);
</code></pre>
<hr />
<h3 id="exportagent"><a class="header" href="#exportagent">exportAgent()</a></h3>
<p>Export the current agent document for sharing or inspection.</p>
<p><strong>Returns:</strong> string - The agent JSON document</p>
<p><strong>Throws:</strong> Error if no agent loaded</p>
<pre><code class="language-javascript">const agentDoc = jacs.exportAgent();
console.log(agentDoc);

// Parse to inspect
const agent = JSON.parse(agentDoc);
console.log(`Agent type: ${agent.jacsAgentType}`);
</code></pre>
<hr />
<h3 id="registerwithhaioptions"><a class="header" href="#registerwithhaioptions">registerWithHai(options?)</a></h3>
<p>Register the loaded agent with HAI.ai. Requires a loaded agent and an API key (<code>options.apiKey</code> or <code>HAI_API_KEY</code>).</p>
<p><strong>Parameters:</strong> <code>options</code> (object, optional): <code>{ apiKey?, haiUrl?, preview? }</code></p>
<p><strong>Returns:</strong> <code>Promise&lt;HaiRegistrationResult&gt;</code> with <code>agentId</code>, <code>jacsId</code>, <code>dnsVerified</code>, <code>signatures</code></p>
<hr />
<h3 id="getdnsrecorddomain-ttl"><a class="header" href="#getdnsrecorddomain-ttl">getDnsRecord(domain, ttl?)</a></h3>
<p>Return the DNS TXT record line for the loaded agent (for DNS-based discovery). Format: <code>_v1.agent.jacs.{domain}. TTL IN TXT "v=hai.ai; ..."</code>.</p>
<p><strong>Parameters:</strong> <code>domain</code> (string), <code>ttl</code> (number, optional, default 3600)</p>
<p><strong>Returns:</strong> string</p>
<hr />
<h3 id="getwellknownjson"><a class="header" href="#getwellknownjson">getWellKnownJson()</a></h3>
<p>Return the well-known JSON object for the loaded agent (e.g. for <code>/.well-known/jacs-pubkey.json</code>). Keys: <code>publicKey</code>, <code>publicKeyHash</code>, <code>algorithm</code>, <code>agentId</code>.</p>
<p><strong>Returns:</strong> object</p>
<hr />
<h3 id="getpublickey"><a class="header" href="#getpublickey">getPublicKey()</a></h3>
<p>Get the loaded agent's public key in PEM format for sharing with others.</p>
<p><strong>Returns:</strong> string - PEM-encoded public key</p>
<p><strong>Throws:</strong> Error if no agent loaded</p>
<pre><code class="language-javascript">const pem = jacs.getPublicKey();
console.log(pem);
// -----BEGIN PUBLIC KEY-----
// ...
// -----END PUBLIC KEY-----
</code></pre>
<hr />
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<h3 id="agentinfo"><a class="header" href="#agentinfo">AgentInfo</a></h3>
<pre><code class="language-typescript">interface AgentInfo {
  agentId: string;      // Agent's UUID
  name: string;         // Agent name from config
  publicKeyPath: string; // Path to public key file
  configPath: string;   // Path to loaded config
}
</code></pre>
<h3 id="signeddocument"><a class="header" href="#signeddocument">SignedDocument</a></h3>
<pre><code class="language-typescript">interface SignedDocument {
  raw: string;          // Full JSON document with signature
  documentId: string;   // Document's UUID (jacsId)
  agentId: string;      // Signing agent's ID
  timestamp: string;    // ISO 8601 timestamp
}
</code></pre>
<h3 id="verificationresult"><a class="header" href="#verificationresult">VerificationResult</a></h3>
<pre><code class="language-typescript">interface VerificationResult {
  valid: boolean;       // True if signature verified
  data?: any;           // Extracted document content
  signerId: string;     // Agent who signed
  timestamp: string;    // When it was signed
  attachments: Attachment[];  // File attachments
  errors: string[];     // Error messages if invalid
}
</code></pre>
<h3 id="attachment"><a class="header" href="#attachment">Attachment</a></h3>
<pre><code class="language-typescript">interface Attachment {
  filename: string;     // Original filename
  mimeType: string;     // MIME type
  hash: string;         // SHA-256 hash
  embedded: boolean;    // True if content is embedded
  content?: Buffer;     // Embedded content (if available)
}
</code></pre>
<hr />
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

// Load agent
const agent = jacs.load('./jacs.config.json');
console.log(`Loaded agent: ${agent.agentId}`);

// Verify agent integrity
const selfCheck = jacs.verifySelf();
if (!selfCheck.valid) {
  throw new Error('Agent integrity check failed');
}

// Sign a transaction
const transaction = {
  type: 'payment',
  from: agent.agentId,
  to: 'recipient-agent-uuid',
  amount: 250.00,
  currency: 'USD',
  memo: 'Q1 Service Payment'
};

const signed = jacs.signMessage(transaction);
console.log(`Transaction signed: ${signed.documentId}`);

// Verify the transaction (simulating recipient)
const verification = jacs.verify(signed.raw);

if (verification.valid) {
  console.log(`Payment verified from: ${verification.signerId}`);
  console.log(`Amount: ${verification.data.amount} ${verification.data.currency}`);
} else {
  console.log(`Verification failed: ${verification.errors.join(', ')}`);
}

// Sign a file
const contractSigned = jacs.signFile('./contract.pdf', true);
console.log(`Contract signed: ${contractSigned.documentId}`);

// Update agent metadata
const agentDoc = JSON.parse(jacs.exportAgent());
agentDoc.jacsAgentType = 'ai';
if (!agentDoc.jacsContacts || agentDoc.jacsContacts.length === 0) {
  agentDoc.jacsContacts = [{ contactFirstName: 'AI', contactLastName: 'Agent' }];
}
const updatedAgent = jacs.updateAgent(agentDoc);
console.log('Agent metadata updated');

// Share public key
const publicKey = jacs.getPublicKey();
console.log('Share this public key for verification:');
console.log(publicKey);
</code></pre>
<hr />
<h2 id="mcp-integration"><a class="header" href="#mcp-integration">MCP Integration</a></h2>
<p>The simplified API works well with MCP tool implementations:</p>
<pre><code class="language-javascript">const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const jacs = require('@hai.ai/jacs/simple');

// Load agent once at startup
jacs.load('./jacs.config.json');

// Define a signed tool
server.setRequestHandler('tools/call', async (request) =&gt; {
  const { name, arguments: args } = request.params;

  if (name === 'approve_request') {
    const signed = jacs.signMessage({
      action: 'approve',
      requestId: args.requestId,
      approvedBy: jacs.getAgentInfo().agentId
    });

    return {
      content: [{ type: 'text', text: signed.raw }]
    };
  }
});
</code></pre>
<hr />
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');

try {
  jacs.load('./missing-config.json');
} catch (e) {
  console.error('Config not found:', e.message);
}

try {
  // Will fail if no agent loaded
  jacs.signMessage({ data: 'test' });
} catch (e) {
  console.error('No agent:', e.message);
}

try {
  jacs.signFile('/nonexistent/file.pdf');
} catch (e) {
  console.error('File not found:', e.message);
}

// Verification doesn't throw - check result.valid
const result = jacs.verify('invalid json');
if (!result.valid) {
  console.error('Verification errors:', result.errors);
}
</code></pre>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="nodejs/basic-usage.html">Basic Usage</a> - JacsAgent class usage</li>
<li><a href="nodejs/api.html">API Reference</a> - Complete JacsAgent API</li>
<li><a href="nodejs/mcp.html">MCP Integration</a> - Model Context Protocol</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<p>This chapter covers fundamental JACS operations in Node.js, including agent initialization, document creation, signing, and verification.</p>
<h2 id="initializing-an-agent"><a class="header" href="#initializing-an-agent">Initializing an Agent</a></h2>
<h3 id="create-and-load-agent"><a class="header" href="#create-and-load-agent">Create and Load Agent</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

// Create a new agent instance
const agent = new JacsAgent();

// Load configuration from file
agent.load('./jacs.config.json');
</code></pre>
<h3 id="configuration-file-2"><a class="header" href="#configuration-file-2">Configuration File</a></h3>
<p>Create <code>jacs.config.json</code>:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "agent-uuid:version-uuid"
}
</code></pre>
<h2 id="creating-documents-2"><a class="header" href="#creating-documents-2">Creating Documents</a></h2>
<h3 id="basic-document-creation"><a class="header" href="#basic-document-creation">Basic Document Creation</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');

// Create a document from JSON
const documentData = {
  title: "Project Proposal",
  content: "Quarterly development plan",
  budget: 50000
};

const signedDocument = agent.createDocument(JSON.stringify(documentData));
console.log('Signed document:', signedDocument);
</code></pre>
<h3 id="with-custom-schema-1"><a class="header" href="#with-custom-schema-1">With Custom Schema</a></h3>
<p>Validate against a custom JSON Schema:</p>
<pre><code class="language-javascript">const signedDocument = agent.createDocument(
  JSON.stringify(documentData),
  './schemas/proposal.schema.json'  // custom schema path
);
</code></pre>
<h3 id="with-output-file"><a class="header" href="#with-output-file">With Output File</a></h3>
<pre><code class="language-javascript">const signedDocument = agent.createDocument(
  JSON.stringify(documentData),
  null,                    // no custom schema
  './output/proposal.json' // output filename
);
</code></pre>
<h3 id="without-saving"><a class="header" href="#without-saving">Without Saving</a></h3>
<pre><code class="language-javascript">const signedDocument = agent.createDocument(
  JSON.stringify(documentData),
  null,   // no custom schema
  null,   // no output filename
  true    // noSave = true
);
</code></pre>
<h3 id="with-attachments"><a class="header" href="#with-attachments">With Attachments</a></h3>
<pre><code class="language-javascript">const signedDocument = agent.createDocument(
  JSON.stringify(documentData),
  null,                      // no custom schema
  null,                      // no output filename
  false,                     // save the document
  './attachments/report.pdf', // attachment path
  true                       // embed files
);
</code></pre>
<h2 id="verifying-documents-2"><a class="header" href="#verifying-documents-2">Verifying Documents</a></h2>
<h3 id="verify-document-signature"><a class="header" href="#verify-document-signature">Verify Document Signature</a></h3>
<pre><code class="language-javascript">// Verify a document's signature and hash
const isValid = agent.verifyDocument(signedDocumentJson);
console.log('Document valid:', isValid);
</code></pre>
<h3 id="verify-specific-signature-field"><a class="header" href="#verify-specific-signature-field">Verify Specific Signature Field</a></h3>
<pre><code class="language-javascript">// Verify with a custom signature field
const isValid = agent.verifySignature(
  signedDocumentJson,
  'jacsSignature'  // signature field name
);
</code></pre>
<h2 id="updating-documents-2"><a class="header" href="#updating-documents-2">Updating Documents</a></h2>
<h3 id="update-existing-document"><a class="header" href="#update-existing-document">Update Existing Document</a></h3>
<pre><code class="language-javascript">// Original document key format: "id:version"
const documentKey = 'doc-uuid:version-uuid';

// Modified document content
const updatedData = {
  jacsId: 'doc-uuid',
  jacsVersion: 'version-uuid',
  title: "Updated Proposal",
  content: "Revised quarterly plan",
  budget: 75000
};

const updatedDocument = agent.updateDocument(
  documentKey,
  JSON.stringify(updatedData)
);

console.log('Updated document:', updatedDocument);
</code></pre>
<h3 id="update-with-new-attachments"><a class="header" href="#update-with-new-attachments">Update with New Attachments</a></h3>
<pre><code class="language-javascript">const updatedDocument = agent.updateDocument(
  documentKey,
  JSON.stringify(updatedData),
  ['./new-report.pdf'],  // new attachments
  true                   // embed files
);
</code></pre>
<h2 id="signing-and-verification-1"><a class="header" href="#signing-and-verification-1">Signing and Verification</a></h2>
<h3 id="sign-arbitrary-data"><a class="header" href="#sign-arbitrary-data">Sign Arbitrary Data</a></h3>
<pre><code class="language-javascript">// Sign any string data
const signature = agent.signString('Important message to sign');
console.log('Signature:', signature);
</code></pre>
<h3 id="verify-arbitrary-data"><a class="header" href="#verify-arbitrary-data">Verify Arbitrary Data</a></h3>
<pre><code class="language-javascript">// Verify a signature on string data
const isValid = agent.verifyString(
  'Important message to sign',  // original data
  signatureBase64,              // base64 signature
  publicKeyBuffer,              // public key as Buffer
  'ring-Ed25519'                // algorithm
);
</code></pre>
<h2 id="working-with-agreements"><a class="header" href="#working-with-agreements">Working with Agreements</a></h2>
<h3 id="create-an-agreement"><a class="header" href="#create-an-agreement">Create an Agreement</a></h3>
<pre><code class="language-javascript">// Add agreement requiring multiple agent signatures
const documentWithAgreement = agent.createAgreement(
  signedDocumentJson,
  ['agent1-uuid', 'agent2-uuid'],           // required signers
  'Do you agree to these terms?',            // question
  'Q1 2024 service contract',                // context
  'jacsAgreement'                            // field name
);
</code></pre>
<h3 id="sign-an-agreement"><a class="header" href="#sign-an-agreement">Sign an Agreement</a></h3>
<pre><code class="language-javascript">// Sign the agreement as the current agent
const signedAgreement = agent.signAgreement(
  documentWithAgreementJson,
  'jacsAgreement'  // agreement field name
);
</code></pre>
<h3 id="check-agreement-status"><a class="header" href="#check-agreement-status">Check Agreement Status</a></h3>
<pre><code class="language-javascript">// Check which agents have signed
const status = agent.checkAgreement(
  documentWithAgreementJson,
  'jacsAgreement'
);

console.log('Agreement status:', JSON.parse(status));
</code></pre>
<h2 id="agent-operations"><a class="header" href="#agent-operations">Agent Operations</a></h2>
<h3 id="verify-agent-1"><a class="header" href="#verify-agent-1">Verify Agent</a></h3>
<pre><code class="language-javascript">// Verify the loaded agent's signature
const isValid = agent.verifyAgent();
console.log('Agent valid:', isValid);

// Verify a specific agent file
const isValidOther = agent.verifyAgent('./other-agent.json');
</code></pre>
<h3 id="update-agent"><a class="header" href="#update-agent">Update Agent</a></h3>
<pre><code class="language-javascript">// Update agent document
const updatedAgentJson = agent.updateAgent(JSON.stringify({
  jacsId: 'agent-uuid',
  jacsVersion: 'version-uuid',
  name: 'Updated Agent Name',
  description: 'Updated description'
}));
</code></pre>
<h3 id="sign-external-agent"><a class="header" href="#sign-external-agent">Sign External Agent</a></h3>
<pre><code class="language-javascript">// Sign another agent's document with registration signature
const signedAgentJson = agent.signAgent(
  externalAgentJson,
  publicKeyBuffer,
  'ring-Ed25519'
);
</code></pre>
<h2 id="requestresponse-signing"><a class="header" href="#requestresponse-signing">Request/Response Signing</a></h2>
<h3 id="sign-a-request"><a class="header" href="#sign-a-request">Sign a Request</a></h3>
<pre><code class="language-javascript">// Sign request parameters as a JACS document
const signedRequest = agent.signRequest({
  method: 'GET',
  path: '/api/resource',
  timestamp: new Date().toISOString(),
  body: { query: 'data' }
});
</code></pre>
<h3 id="verify-a-response"><a class="header" href="#verify-a-response">Verify a Response</a></h3>
<pre><code class="language-javascript">// Verify a signed response
const result = agent.verifyResponse(signedResponseJson);
console.log('Response valid:', result);

// Verify and get signer's agent ID
const resultWithId = agent.verifyResponseWithAgentId(signedResponseJson);
console.log('Signer ID:', resultWithId);
</code></pre>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<h3 id="hash-string"><a class="header" href="#hash-string">Hash String</a></h3>
<pre><code class="language-javascript">import { hashString } from '@hai.ai/jacs';

// SHA-256 hash of a string
const hash = hashString('data to hash');
console.log('Hash:', hash);
</code></pre>
<h3 id="create-configuration-1"><a class="header" href="#create-configuration-1">Create Configuration</a></h3>
<pre><code class="language-javascript">import { createConfig } from '@hai.ai/jacs';

// Programmatically create a config JSON string
const configJson = createConfig(
  undefined,            // jacs_use_security
  './jacs_data',        // jacs_data_directory
  './jacs_keys',        // jacs_key_directory
  undefined,            // private key filename
  undefined,            // public key filename
  'ring-Ed25519',       // key algorithm
  undefined,            // private key password
  undefined,            // agent id and version
  'fs'                  // default storage
);

console.log('Config:', configJson);
</code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();

try {
  agent.load('./jacs.config.json');
} catch (error) {
  console.error('Failed to load agent:', error.message);
}

try {
  const doc = agent.createDocument(JSON.stringify({ data: 'test' }));
  console.log('Document created');
} catch (error) {
  console.error('Failed to create document:', error.message);
}

try {
  const isValid = agent.verifyDocument(invalidJson);
} catch (error) {
  console.error('Verification failed:', error.message);
}
</code></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><code class="language-javascript">import { JacsAgent, hashString } from '@hai.ai/jacs';

async function main() {
  // Initialize agent
  const agent = new JacsAgent();
  agent.load('./jacs.config.json');

  // Create a task document
  const task = {
    title: 'Code Review',
    description: 'Review pull request #123',
    assignee: 'developer-uuid',
    deadline: '2024-02-01'
  };

  const signedTask = agent.createDocument(JSON.stringify(task));
  console.log('Task created');

  // Verify the task
  if (agent.verifyDocument(signedTask)) {
    console.log('Task signature valid');
  }

  // Create agreement for task acceptance
  const taskWithAgreement = agent.createAgreement(
    signedTask,
    ['manager-uuid', 'developer-uuid'],
    'Do you accept this task assignment?'
  );

  // Sign the agreement
  const signedAgreement = agent.signAgreement(taskWithAgreement);
  console.log('Agreement signed');

  // Check agreement status
  const status = agent.checkAgreement(signedAgreement);
  console.log('Status:', status);

  // Hash some data for reference
  const taskHash = hashString(signedTask);
  console.log('Task hash:', taskHash);
}

main().catch(console.error);
</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><a href="nodejs/mcp.html">MCP Integration</a> - Model Context Protocol support</li>
<li><a href="nodejs/http.html">HTTP Server</a> - Create HTTP APIs</li>
<li><a href="nodejs/express.html">Express Middleware</a> - Express.js integration</li>
<li><a href="nodejs/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-context-protocol-mcp-integration"><a class="header" href="#model-context-protocol-mcp-integration">Model Context Protocol (MCP) Integration</a></h1>
<p>JACS provides native integration with the <a href="https://modelcontextprotocol.io/">Model Context Protocol (MCP)</a>, enabling secure agent communication within AI systems. JACS uses a transport proxy pattern that wraps any MCP transport with cryptographic signing and verification.</p>
<h2 id="what-is-mcp"><a class="header" href="#what-is-mcp">What is MCP?</a></h2>
<p>Model Context Protocol is a standard for AI models to securely access external tools, data, and services. JACS enhances MCP by adding:</p>
<ul>
<li><strong>Cryptographic verification</strong> of all messages</li>
<li><strong>Agent identity</strong> for all operations</li>
<li><strong>Transparent encryption</strong> of MCP JSON-RPC traffic</li>
<li><strong>Audit trails</strong> of all MCP interactions</li>
</ul>
<h2 id="how-jacs-mcp-works"><a class="header" href="#how-jacs-mcp-works">How JACS MCP Works</a></h2>
<p>JACS provides a <strong>transport proxy</strong> that sits between your MCP server/client and the underlying transport (STDIO, SSE, WebSocket). The proxy:</p>
<ol>
<li><strong>Outgoing messages</strong>: Signs JSON-RPC messages with the JACS agent's key using <code>signRequest()</code></li>
<li><strong>Incoming messages</strong>: Verifies signatures using <code>verifyResponse()</code> and extracts the payload</li>
<li><strong>Fallback</strong>: If verification fails, passes messages through as plain JSON (graceful degradation)</li>
</ol>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick Start</a></h2>
<h3 id="basic-mcp-server-with-jacs"><a class="header" href="#basic-mcp-server-with-jacs">Basic MCP Server with JACS</a></h3>
<pre><code class="language-javascript">import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { z } from 'zod';

const JACS_CONFIG_PATH = "./jacs.config.json";

async function main() {
  // Create the base STDIO transport
  const baseTransport = new StdioServerTransport();

  // Wrap with JACS encryption
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    JACS_CONFIG_PATH,
    "server"
  );

  // Create MCP server
  const server = new McpServer({
    name: "my-jacs-server",
    version: "1.0.0"
  });

  // Register tools
  server.tool("add", {
    a: z.number().describe("First number"),
    b: z.number().describe("Second number")
  }, async ({ a, b }) =&gt; {
    return { content: [{ type: "text", text: `${a} + ${b} = ${a + b}` }] };
  });

  // Connect with JACS encryption
  await server.connect(secureTransport);
  console.error("JACS MCP Server running with encryption enabled");
}

main();
</code></pre>
<h3 id="mcp-client-with-jacs"><a class="header" href="#mcp-client-with-jacs">MCP Client with JACS</a></h3>
<pre><code class="language-javascript">import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

const JACS_CONFIG_PATH = "./jacs.config.json";

async function main() {
  // Create base transport to connect to MCP server
  const baseTransport = new StdioClientTransport({
    command: 'node',
    args: ['my-jacs-server.js']
  });

  // Wrap with JACS encryption
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    JACS_CONFIG_PATH,
    "client"
  );

  // Create MCP client
  const client = new Client({
    name: "my-jacs-client",
    version: "1.0.0"
  }, {
    capabilities: {
      tools: {}
    }
  });

  // Connect with JACS encryption
  await client.connect(secureTransport);

  // List available tools
  const tools = await client.listTools();
  console.log('Available tools:', tools.tools.map(t =&gt; t.name));

  // Call a tool (message will be JACS-signed)
  const result = await client.callTool({
    name: "add",
    arguments: { a: 5, b: 3 }
  });

  console.log('Result:', result.content);
}

main();
</code></pre>
<h2 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h2>
<h3 id="jacstransportproxy"><a class="header" href="#jacstransportproxy">JACSTransportProxy</a></h3>
<p>The main class that wraps MCP transports with JACS encryption.</p>
<pre><code class="language-javascript">import { JACSTransportProxy } from '@hai.ai/jacs/mcp';

const proxy = new JACSTransportProxy(
  transport,      // Any MCP transport (Stdio, SSE, WebSocket)
  role,           // "server" or "client"
  jacsConfigPath  // Path to jacs.config.json
);
</code></pre>
<h3 id="createjacstransportproxy"><a class="header" href="#createjacstransportproxy">createJACSTransportProxy</a></h3>
<p>Factory function for creating a transport proxy.</p>
<pre><code class="language-javascript">import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

const secureTransport = createJACSTransportProxy(
  baseTransport,    // The underlying MCP transport
  configPath,       // Path to jacs.config.json
  role              // "server" or "client"
);
</code></pre>
<h3 id="createjacstransportproxyasync"><a class="header" href="#createjacstransportproxyasync">createJACSTransportProxyAsync</a></h3>
<p>Async factory that waits for JACS to be fully loaded before returning.</p>
<pre><code class="language-javascript">import { createJACSTransportProxyAsync } from '@hai.ai/jacs/mcp';

const secureTransport = await createJACSTransportProxyAsync(
  baseTransport,
  configPath,
  role
);
</code></pre>
<h2 id="transport-options"><a class="header" href="#transport-options">Transport Options</a></h2>
<h3 id="stdio-transport"><a class="header" href="#stdio-transport">STDIO Transport</a></h3>
<p>Best for CLI tools and subprocess communication:</p>
<pre><code class="language-javascript">import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

const baseTransport = new StdioServerTransport();
const secureTransport = createJACSTransportProxy(
  baseTransport,
  "./jacs.config.json",
  "server"
);
</code></pre>
<p><strong>Important</strong>: When using STDIO transport, all debug logging goes to <code>stderr</code> to keep <code>stdout</code> clean for JSON-RPC messages.</p>
<h3 id="sse-transport-http"><a class="header" href="#sse-transport-http">SSE Transport (HTTP)</a></h3>
<p>For web-based MCP servers:</p>
<pre><code class="language-javascript">import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import express from 'express';

const app = express();

app.get('/sse', (req, res) =&gt; {
  const baseTransport = new SSEServerTransport('/messages', res);
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    "./jacs.config.json",
    "server"
  );

  // Connect your MCP server to secureTransport
  server.connect(secureTransport);
});

// Handle POST messages with JACS decryption
app.post('/messages', express.text(), async (req, res) =&gt; {
  await secureTransport.handlePostMessage(req, res, req.body);
});

app.listen(3000);
</code></pre>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<h3 id="jacs-config-file"><a class="header" href="#jacs-config-file">JACS Config File</a></h3>
<p>Create a <code>jacs.config.json</code> for your MCP server/client:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "agent-uuid:version-uuid"
}
</code></pre>
<h3 id="environment-variables-3"><a class="header" href="#environment-variables-3">Environment Variables</a></h3>
<p>Enable debug logging (not recommended for STDIO):</p>
<pre><code class="language-bash">export JACS_MCP_DEBUG=true
</code></pre>
<h2 id="how-messages-are-signed"><a class="header" href="#how-messages-are-signed">How Messages Are Signed</a></h2>
<h3 id="outgoing-messages"><a class="header" href="#outgoing-messages">Outgoing Messages</a></h3>
<p>When the MCP SDK sends a message, the proxy intercepts it and:</p>
<ol>
<li>Serializes the JSON-RPC message</li>
<li>Calls <code>jacs.signRequest(message)</code> to create a JACS artifact</li>
<li>Sends the signed artifact to the transport</li>
</ol>
<pre><code class="language-javascript">// Original MCP message
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": { "name": "add", "arguments": { "a": 5, "b": 3 } }
}

// Becomes a JACS-signed artifact with jacsId, jacsSignature, etc.
</code></pre>
<h3 id="incoming-messages"><a class="header" href="#incoming-messages">Incoming Messages</a></h3>
<p>When the transport receives a message, the proxy:</p>
<ol>
<li>Attempts to verify it as a JACS artifact using <code>jacs.verifyResponse()</code></li>
<li>If valid, extracts the original JSON-RPC payload</li>
<li>If not valid JACS, parses as plain JSON (fallback mode)</li>
<li>Passes the clean message to the MCP SDK</li>
</ol>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<h3 id="server-mcpserverjs"><a class="header" href="#server-mcpserverjs">Server (mcp.server.js)</a></h3>
<pre><code class="language-javascript">#!/usr/bin/env node
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { z } from 'zod';

async function main() {
  console.error("JACS MCP Server starting...");

  // Create transport with JACS encryption
  const baseTransport = new StdioServerTransport();
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    "./jacs.server.config.json",
    "server"
  );

  // Create MCP server
  const server = new McpServer({
    name: "jacs-demo-server",
    version: "1.0.0"
  });

  // Register tools
  server.tool("echo", {
    message: z.string().describe("Message to echo")
  }, async ({ message }) =&gt; {
    console.error(`Echo called with: ${message}`);
    return { content: [{ type: "text", text: `Echo: ${message}` }] };
  });

  server.tool("add", {
    a: z.number().describe("First number"),
    b: z.number().describe("Second number")
  }, async ({ a, b }) =&gt; {
    console.error(`Add called with: ${a}, ${b}`);
    return { content: [{ type: "text", text: `Result: ${a + b}` }] };
  });

  // Register resources
  server.resource(
    "server-info",
    "info://server",
    async (uri) =&gt; ({
      contents: [{
        uri: uri.href,
        text: "JACS-secured MCP Server",
        mimeType: "text/plain"
      }]
    })
  );

  // Connect
  await server.connect(secureTransport);
  console.error("Server running with JACS encryption");
}

main().catch(err =&gt; {
  console.error("Fatal error:", err);
  process.exit(1);
});
</code></pre>
<h3 id="client-mcpclientjs"><a class="header" href="#client-mcpclientjs">Client (mcp.client.js)</a></h3>
<pre><code class="language-javascript">#!/usr/bin/env node
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

async function main() {
  console.log("JACS MCP Client starting...");

  // Connect to the server
  const baseTransport = new StdioClientTransport({
    command: 'node',
    args: ['mcp.server.js']
  });

  const secureTransport = createJACSTransportProxy(
    baseTransport,
    "./jacs.client.config.json",
    "client"
  );

  const client = new Client({
    name: "jacs-demo-client",
    version: "1.0.0"
  }, {
    capabilities: { tools: {} }
  });

  await client.connect(secureTransport);
  console.log("Connected to JACS MCP Server");

  // List tools
  const tools = await client.listTools();
  console.log("Available tools:", tools.tools.map(t =&gt; t.name));

  // Call echo tool
  const echoResult = await client.callTool({
    name: "echo",
    arguments: { message: "Hello, JACS!" }
  });
  console.log("Echo result:", echoResult.content[0].text);

  // Call add tool
  const addResult = await client.callTool({
    name: "add",
    arguments: { a: 10, b: 20 }
  });
  console.log("Add result:", addResult.content[0].text);

  await client.close();
}

main().catch(console.error);
</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="message-verification"><a class="header" href="#message-verification">Message Verification</a></h3>
<p>All JACS-signed messages include:</p>
<ul>
<li><code>jacsId</code> - Unique document identifier</li>
<li><code>jacsVersion</code> - Version tracking</li>
<li><code>jacsSignature</code> - Cryptographic signature</li>
<li><code>jacsHash</code> - Content hash for integrity</li>
</ul>
<h3 id="passthrough-mode"><a class="header" href="#passthrough-mode">Passthrough Mode</a></h3>
<p>If JACS cannot verify an incoming message, it falls back to plain JSON parsing. This allows:</p>
<ul>
<li>Gradual migration to JACS-secured communication</li>
<li>Interoperability with non-JACS MCP clients/servers</li>
</ul>
<p>To require JACS verification (no fallback), implement custom validation in your tools.</p>
<h3 id="key-management-1"><a class="header" href="#key-management-1">Key Management</a></h3>
<p>Each MCP server and client needs its own JACS agent with:</p>
<ul>
<li>Unique agent ID</li>
<li>Private/public key pair</li>
<li>Configuration file</li>
</ul>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><code class="language-bash">export JACS_MCP_DEBUG=true
</code></pre>
<p>This outputs detailed logs about message signing and verification.</p>
<h3 id="stdio-debug-note"><a class="header" href="#stdio-debug-note">STDIO Debug Note</a></h3>
<p>For STDIO transports, debug logs go to <code>stderr</code> to prevent contaminating the JSON-RPC stream on <code>stdout</code>.</p>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>"JACS not operational"</strong>: Check that your config file path is correct and the agent is properly initialized.</p>
<p><strong>Verification failures</strong>: Ensure both server and client are using compatible JACS versions and valid keys.</p>
<p><strong>Empty responses</strong>: The proxy removes null values from messages to prevent MCP schema validation issues.</p>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="nodejs/http.html">HTTP Server</a> - Create HTTP APIs with JACS</li>
<li><a href="nodejs/express.html">Express Middleware</a> - Integrate with Express.js</li>
<li><a href="nodejs/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server"><a class="header" href="#http-server">HTTP Server</a></h1>
<p>JACS provides middleware and utilities for building HTTP servers with cryptographic request/response signing. This enables secure communication between JACS agents over HTTP.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>JACS HTTP integration provides:</p>
<ul>
<li><strong>Request signing</strong>: Sign outgoing HTTP requests with your agent's key</li>
<li><strong>Request verification</strong>: Verify incoming requests were signed by a valid agent</li>
<li><strong>Response signing</strong>: Automatically sign responses before sending</li>
<li><strong>Response verification</strong>: Verify server responses on the client side</li>
<li><strong>Framework middleware</strong>: Ready-to-use middleware for Express and Koa</li>
</ul>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="requestresponse-flow"><a class="header" href="#requestresponse-flow">Request/Response Flow</a></h3>
<pre><code>Client                          Server
  |                               |
  |-- signRequest(payload) -----&gt; |
  |                               |-- verifyResponse() --&gt; payload
  |                               |-- process payload
  |                               |-- signResponse(result)
  |&lt;-- verifyResponse(result) ---|
  |
</code></pre>
<p>All messages are cryptographically signed, ensuring:</p>
<ul>
<li>Message integrity (no tampering)</li>
<li>Agent identity (verified sender)</li>
<li>Non-repudiation (proof of origin)</li>
</ul>
<h2 id="http-client"><a class="header" href="#http-client">HTTP Client</a></h2>
<h3 id="basic-client-usage"><a class="header" href="#basic-client-usage">Basic Client Usage</a></h3>
<pre><code class="language-javascript">import jacs from '@hai.ai/jacs';
import http from 'http';

async function main() {
  // Load JACS agent
  await jacs.load('./jacs.config.json');

  // Prepare payload
  const payload = {
    message: "Hello, secure server!",
    data: { id: 123, value: "some data" },
    timestamp: new Date().toISOString()
  };

  // Sign the request
  const signedRequest = await jacs.signRequest(payload);

  // Send HTTP request
  const response = await sendRequest(signedRequest, 'localhost', 3000, '/api/echo');

  // Verify the response
  const verifiedResponse = await jacs.verifyResponse(response);
  console.log('Verified payload:', verifiedResponse.payload);
}

function sendRequest(body, host, port, path) {
  return new Promise((resolve, reject) =&gt; {
    const options = {
      hostname: host,
      port: port,
      path: path,
      method: 'POST',
      headers: {
        'Content-Type': 'text/plain',
        'Content-Length': Buffer.byteLength(body),
      },
    };

    const req = http.request(options, (res) =&gt; {
      let data = '';
      res.on('data', chunk =&gt; data += chunk);
      res.on('end', () =&gt; {
        if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) {
          resolve(data);
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', reject);
    req.write(body);
    req.end();
  });
}

main();
</code></pre>
<h3 id="using-fetch"><a class="header" href="#using-fetch">Using Fetch</a></h3>
<pre><code class="language-javascript">import jacs from '@hai.ai/jacs';

async function sendJacsRequest(url, payload) {
  await jacs.load('./jacs.config.json');

  // Sign the payload
  const signedRequest = await jacs.signRequest(payload);

  // Send request
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: signedRequest
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }

  // Verify response
  const responseText = await response.text();
  const verified = await jacs.verifyResponse(responseText);

  return verified.payload;
}

// Usage
const result = await sendJacsRequest('http://localhost:3000/api/data', {
  action: 'fetch',
  query: { id: 42 }
});
</code></pre>
<h2 id="express-server"><a class="header" href="#express-server">Express Server</a></h2>
<h3 id="using-express-middleware"><a class="header" href="#using-express-middleware">Using Express Middleware</a></h3>
<p>JACS provides <code>JACSExpressMiddleware</code> that automatically:</p>
<ul>
<li>Verifies incoming JACS requests</li>
<li>Attaches the verified payload to <code>req.jacsPayload</code></li>
<li>Signs outgoing responses when you call <code>res.send()</code> with an object</li>
</ul>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();
const PORT = 3000;

// IMPORTANT: Use express.text() BEFORE JACS middleware
// This ensures req.body is a string for JACS verification
app.use('/api', express.text({ type: '*/*' }));

// Apply JACS middleware to API routes
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.server.config.json'
}));

// Route handler
app.post('/api/echo', (req, res) =&gt; {
  // Access verified payload from req.jacsPayload
  const payload = req.jacsPayload;

  if (!payload) {
    return res.status(400).send('JACS payload missing');
  }

  console.log('Received verified payload:', payload);

  // Send response object - middleware will sign it automatically
  res.send({
    echo: "Server says hello!",
    received: payload,
    timestamp: new Date().toISOString()
  });
});

app.listen(PORT, () =&gt; {
  console.log(`JACS Express server listening on port ${PORT}`);
});
</code></pre>
<h3 id="middleware-configuration"><a class="header" href="#middleware-configuration">Middleware Configuration</a></h3>
<pre><code class="language-javascript">JACSExpressMiddleware({
  configPath: './jacs.config.json'  // Required: path to JACS config
})
</code></pre>
<h3 id="manual-requestresponse-handling"><a class="header" href="#manual-requestresponse-handling">Manual Request/Response Handling</a></h3>
<p>For more control, you can handle signing manually:</p>
<pre><code class="language-javascript">import express from 'express';
import jacs from '@hai.ai/jacs';

const app = express();

// Initialize JACS once at startup
await jacs.load('./jacs.config.json');

app.use(express.text({ type: '*/*' }));

app.post('/api/process', async (req, res) =&gt; {
  try {
    // Manually verify incoming request
    const verified = await jacs.verifyResponse(req.body);
    const payload = verified.payload;

    // Process the request
    const result = {
      success: true,
      data: processData(payload),
      timestamp: new Date().toISOString()
    };

    // Manually sign the response
    const signedResponse = await jacs.signResponse(result);
    res.type('text/plain').send(signedResponse);

  } catch (error) {
    console.error('JACS verification failed:', error);
    res.status(400).send('Invalid JACS request');
  }
});
</code></pre>
<h2 id="koa-server"><a class="header" href="#koa-server">Koa Server</a></h2>
<h3 id="using-koa-middleware"><a class="header" href="#using-koa-middleware">Using Koa Middleware</a></h3>
<pre><code class="language-javascript">import Koa from 'koa';
import { JACSKoaMiddleware } from '@hai.ai/jacs/http';

const app = new Koa();
const PORT = 3000;

// Apply JACS Koa middleware
// Handles raw body reading, verification, and response signing
app.use(JACSKoaMiddleware({
  configPath: './jacs.server.config.json'
}));

// Route handler
app.use(async (ctx) =&gt; {
  if (ctx.path === '/api/echo' &amp;&amp; ctx.method === 'POST') {
    // Access verified payload from ctx.state.jacsPayload or ctx.jacsPayload
    const payload = ctx.state.jacsPayload || ctx.jacsPayload;

    if (!payload) {
      ctx.status = 400;
      ctx.body = 'JACS payload missing';
      return;
    }

    console.log('Received verified payload:', payload);

    // Set response object - middleware will sign it automatically
    ctx.body = {
      echo: "Koa server says hello!",
      received: payload,
      timestamp: new Date().toISOString()
    };
  } else {
    ctx.status = 404;
    ctx.body = 'Not Found. Try POST to /api/echo';
  }
});

app.listen(PORT, () =&gt; {
  console.log(`JACS Koa server listening on port ${PORT}`);
});
</code></pre>
<h2 id="api-reference-2"><a class="header" href="#api-reference-2">API Reference</a></h2>
<h3 id="jacssignrequestpayload"><a class="header" href="#jacssignrequestpayload">jacs.signRequest(payload)</a></h3>
<p>Sign an object as a JACS request.</p>
<pre><code class="language-javascript">const signedRequest = await jacs.signRequest({
  method: 'getData',
  params: { id: 123 }
});
// Returns: JACS-signed JSON string
</code></pre>
<h3 id="jacsverifyresponseresponsestring"><a class="header" href="#jacsverifyresponseresponsestring">jacs.verifyResponse(responseString)</a></h3>
<p>Verify a JACS-signed response and extract the payload.</p>
<pre><code class="language-javascript">const result = await jacs.verifyResponse(jacsResponseString);
// Returns: { payload: {...}, jacsId: '...', ... }

const payload = result.payload;
</code></pre>
<h3 id="jacssignresponsepayload"><a class="header" href="#jacssignresponsepayload">jacs.signResponse(payload)</a></h3>
<p>Sign an object as a JACS response.</p>
<pre><code class="language-javascript">const signedResponse = await jacs.signResponse({
  success: true,
  data: { result: 42 }
});
// Returns: JACS-signed JSON string
</code></pre>
<h3 id="jacsexpressmiddlewareoptions"><a class="header" href="#jacsexpressmiddlewareoptions">JACSExpressMiddleware(options)</a></h3>
<p>Express middleware for JACS request/response handling.</p>
<pre><code class="language-javascript">import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

app.use(JACSExpressMiddleware({
  configPath: './jacs.config.json'  // Required
}));
</code></pre>
<p><strong>Request Processing:</strong></p>
<ul>
<li>Reads <code>req.body</code> as a JACS string</li>
<li>Verifies the signature</li>
<li>Attaches payload to <code>req.jacsPayload</code></li>
<li>On failure, sends 400 response</li>
</ul>
<p><strong>Response Processing:</strong></p>
<ul>
<li>Intercepts <code>res.send()</code> calls</li>
<li>If body is an object, signs it as JACS</li>
<li>Sends signed string to client</li>
</ul>
<h3 id="jacskoamiddlewareoptions"><a class="header" href="#jacskoamiddlewareoptions">JACSKoaMiddleware(options)</a></h3>
<p>Koa middleware for JACS request/response handling.</p>
<pre><code class="language-javascript">import { JACSKoaMiddleware } from '@hai.ai/jacs/http';

app.use(JACSKoaMiddleware({
  configPath: './jacs.config.json'  // Required
}));
</code></pre>
<p><strong>Request Processing:</strong></p>
<ul>
<li>Reads raw request body</li>
<li>Verifies JACS signature</li>
<li>Attaches payload to <code>ctx.state.jacsPayload</code> and <code>ctx.jacsPayload</code></li>
</ul>
<p><strong>Response Processing:</strong></p>
<ul>
<li>Signs <code>ctx.body</code> if it's an object</li>
<li>Converts to JACS string before sending</li>
</ul>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<h3 id="server-serverjs"><a class="header" href="#server-serverjs">Server (server.js)</a></h3>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();

// JACS middleware for /api routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.server.config.json'
}));

// Echo endpoint
app.post('/api/echo', (req, res) =&gt; {
  const payload = req.jacsPayload;
  res.send({
    echo: payload,
    serverTime: new Date().toISOString()
  });
});

// Calculate endpoint
app.post('/api/calculate', (req, res) =&gt; {
  const { operation, a, b } = req.jacsPayload;

  let result;
  switch (operation) {
    case 'add': result = a + b; break;
    case 'subtract': result = a - b; break;
    case 'multiply': result = a * b; break;
    case 'divide': result = a / b; break;
    default: return res.status(400).send({ error: 'Unknown operation' });
  }

  res.send({ operation, a, b, result });
});

app.listen(3000, () =&gt; console.log('Server running on port 3000'));
</code></pre>
<h3 id="client-clientjs"><a class="header" href="#client-clientjs">Client (client.js)</a></h3>
<pre><code class="language-javascript">import jacs from '@hai.ai/jacs';

async function main() {
  await jacs.load('./jacs.client.config.json');

  // Call echo endpoint
  const echoResult = await callApi('/api/echo', {
    message: 'Hello, server!'
  });
  console.log('Echo result:', echoResult);

  // Call calculate endpoint
  const calcResult = await callApi('/api/calculate', {
    operation: 'multiply',
    a: 7,
    b: 6
  });
  console.log('Calculate result:', calcResult);
}

async function callApi(path, payload) {
  const signedRequest = await jacs.signRequest(payload);

  const response = await fetch(`http://localhost:3000${path}`, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: signedRequest
  });

  const responseText = await response.text();
  const verified = await jacs.verifyResponse(responseText);
  return verified.payload;
}

main().catch(console.error);
</code></pre>
<h2 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h2>
<h3 id="content-type"><a class="header" href="#content-type">Content-Type</a></h3>
<p>JACS requests should use <code>text/plain</code> content type since they are signed JSON strings, not raw JSON.</p>
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<p>Always handle verification failures gracefully:</p>
<pre><code class="language-javascript">try {
  const verified = await jacs.verifyResponse(responseText);
  return verified.payload;
} catch (error) {
  console.error('JACS verification failed:', error.message);
  // Handle invalid/tampered response
}
</code></pre>
<h3 id="agent-keys"><a class="header" href="#agent-keys">Agent Keys</a></h3>
<p>Each server and client needs its own JACS agent with:</p>
<ul>
<li>Unique agent ID</li>
<li>Private/public key pair</li>
<li>Configuration file pointing to the keys</li>
</ul>
<h3 id="middleware-order"><a class="header" href="#middleware-order">Middleware Order</a></h3>
<p>For Express, ensure <code>express.text()</code> comes <strong>before</strong> <code>JACSExpressMiddleware</code>:</p>
<pre><code class="language-javascript">// Correct order
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: '...' }));

// Wrong - JACS middleware won't receive string body
app.use('/api', JACSExpressMiddleware({ configPath: '...' }));
app.use('/api', express.text({ type: '*/*' }));
</code></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><a href="nodejs/express.html">Express Middleware</a> - More Express integration patterns</li>
<li><a href="nodejs/mcp.html">MCP Integration</a> - Model Context Protocol support</li>
<li><a href="nodejs/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-middleware"><a class="header" href="#express-middleware">Express Middleware</a></h1>
<p>This chapter covers advanced Express.js integration patterns with JACS, building on the basics covered in <a href="nodejs/http.html">HTTP Server</a>.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>JACS provides <code>JACSExpressMiddleware</code> for seamless integration with Express.js applications:</p>
<ul>
<li>Automatic request verification</li>
<li>Automatic response signing</li>
<li>Access to verified payloads via <code>req.jacsPayload</code></li>
<li>Error handling for invalid requests</li>
</ul>
<h2 id="quick-start-5"><a class="header" href="#quick-start-5">Quick Start</a></h2>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();

// Required: Parse body as text before JACS middleware
app.use('/api', express.text({ type: '*/*' }));

// Apply JACS middleware
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Routes automatically get verified payloads and signed responses
app.post('/api/data', (req, res) =&gt; {
  const payload = req.jacsPayload;
  res.send({ received: payload, status: 'ok' });
});

app.listen(3000);
</code></pre>
<h2 id="middleware-configuration-1"><a class="header" href="#middleware-configuration-1">Middleware Configuration</a></h2>
<h3 id="basic-configuration-1"><a class="header" href="#basic-configuration-1">Basic Configuration</a></h3>
<pre><code class="language-javascript">JACSExpressMiddleware({
  configPath: './jacs.config.json'  // Required: path to JACS config
})
</code></pre>
<h3 id="per-route-configuration"><a class="header" href="#per-route-configuration">Per-Route Configuration</a></h3>
<p>Apply JACS to specific routes:</p>
<pre><code class="language-javascript">const app = express();

// Non-JACS routes (public endpoints)
app.get('/health', (req, res) =&gt; res.send({ status: 'ok' }));
app.get('/public/info', (req, res) =&gt; res.send({ name: 'My API' }));

// JACS-protected routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));

app.post('/api/secure', (req, res) =&gt; {
  // Only JACS-signed requests reach here
  res.send({ data: 'secure response' });
});
</code></pre>
<h3 id="multiple-jacs-agents"><a class="header" href="#multiple-jacs-agents">Multiple JACS Agents</a></h3>
<p>Use different JACS agents for different routes:</p>
<pre><code class="language-javascript">// Admin routes with admin agent
app.use('/admin', express.text({ type: '*/*' }));
app.use('/admin', JACSExpressMiddleware({
  configPath: './jacs.admin.config.json'
}));

// User routes with user agent
app.use('/user', express.text({ type: '*/*' }));
app.use('/user', JACSExpressMiddleware({
  configPath: './jacs.user.config.json'
}));
</code></pre>
<h2 id="request-handling"><a class="header" href="#request-handling">Request Handling</a></h2>
<h3 id="accessing-verified-payload"><a class="header" href="#accessing-verified-payload">Accessing Verified Payload</a></h3>
<p>The middleware attaches the verified payload to <code>req.jacsPayload</code>:</p>
<pre><code class="language-javascript">app.post('/api/process', (req, res) =&gt; {
  // req.jacsPayload contains the verified, decrypted payload
  const { action, data, timestamp } = req.jacsPayload;

  console.log('Action:', action);
  console.log('Data:', data);
  console.log('Request timestamp:', timestamp);

  res.send({ processed: true });
});
</code></pre>
<h3 id="handling-missing-payload"><a class="header" href="#handling-missing-payload">Handling Missing Payload</a></h3>
<p>If JACS verification fails, <code>req.jacsPayload</code> will be undefined:</p>
<pre><code class="language-javascript">app.post('/api/secure', (req, res) =&gt; {
  if (!req.jacsPayload) {
    return res.status(400).json({ error: 'Invalid JACS request' });
  }

  // Process verified payload
  res.send({ success: true });
});
</code></pre>
<h3 id="validation-helper"><a class="header" href="#validation-helper">Validation Helper</a></h3>
<p>Create a reusable validation middleware:</p>
<pre><code class="language-javascript">function requireJacsPayload(req, res, next) {
  if (!req.jacsPayload) {
    return res.status(400).json({
      error: 'JACS verification failed',
      message: 'Request must be signed with valid JACS credentials'
    });
  }
  next();
}

// Apply to routes
app.post('/api/secure', requireJacsPayload, (req, res) =&gt; {
  // Guaranteed to have valid req.jacsPayload
  res.send({ data: req.jacsPayload });
});
</code></pre>
<h2 id="response-handling"><a class="header" href="#response-handling">Response Handling</a></h2>
<h3 id="automatic-signing"><a class="header" href="#automatic-signing">Automatic Signing</a></h3>
<p>When you call <code>res.send()</code> with an object, the middleware automatically signs it:</p>
<pre><code class="language-javascript">app.post('/api/data', (req, res) =&gt; {
  // This object will be automatically JACS-signed
  res.send({
    result: 'success',
    data: { value: 42 },
    timestamp: new Date().toISOString()
  });
});
</code></pre>
<h3 id="sending-unsigned-responses"><a class="header" href="#sending-unsigned-responses">Sending Unsigned Responses</a></h3>
<p>To bypass automatic signing, send a string directly:</p>
<pre><code class="language-javascript">app.post('/api/raw', (req, res) =&gt; {
  // String responses are not signed
  res.type('text/plain').send('Raw text response');
});
</code></pre>
<h3 id="custom-response-format"><a class="header" href="#custom-response-format">Custom Response Format</a></h3>
<pre><code class="language-javascript">app.post('/api/custom', (req, res) =&gt; {
  const response = {
    success: true,
    payload: {
      action: 'completed',
      result: processRequest(req.jacsPayload)
    },
    metadata: {
      serverTime: new Date().toISOString(),
      requestId: generateRequestId()
    }
  };

  // Automatically signed before sending
  res.send(response);
});
</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="global-error-handler"><a class="header" href="#global-error-handler">Global Error Handler</a></h3>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();

app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));

app.post('/api/process', (req, res, next) =&gt; {
  try {
    if (!req.jacsPayload) {
      throw new Error('Missing JACS payload');
    }

    const result = processData(req.jacsPayload);
    res.send({ result });
  } catch (error) {
    next(error);
  }
});

// Global error handler
app.use((error, req, res, next) =&gt; {
  console.error('Error:', error.message);

  res.status(500).send({
    error: 'Internal server error',
    message: error.message
  });
});
</code></pre>
<h3 id="typed-errors"><a class="header" href="#typed-errors">Typed Errors</a></h3>
<pre><code class="language-javascript">class JacsValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'JacsValidationError';
    this.statusCode = 400;
  }
}

app.post('/api/validate', (req, res, next) =&gt; {
  try {
    if (!req.jacsPayload) {
      throw new JacsValidationError('Invalid JACS request');
    }

    const { requiredField } = req.jacsPayload;
    if (!requiredField) {
      throw new JacsValidationError('Missing required field');
    }

    res.send({ valid: true });
  } catch (error) {
    next(error);
  }
});

// Error handler
app.use((error, req, res, next) =&gt; {
  const statusCode = error.statusCode || 500;
  res.status(statusCode).send({
    error: error.name,
    message: error.message
  });
});
</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="router-level-middleware"><a class="header" href="#router-level-middleware">Router-Level Middleware</a></h3>
<pre><code class="language-javascript">import { Router } from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

// Create a JACS-enabled router
function createJacsRouter(configPath) {
  const router = Router();

  router.use(express.text({ type: '*/*' }));
  router.use(JACSExpressMiddleware({ configPath }));

  return router;
}

// Usage
const apiRouter = createJacsRouter('./jacs.config.json');

apiRouter.post('/users', (req, res) =&gt; {
  res.send({ users: getUserList() });
});

apiRouter.post('/orders', (req, res) =&gt; {
  res.send({ orders: getOrders(req.jacsPayload.userId) });
});

app.use('/api', apiRouter);
</code></pre>
<h3 id="middleware-composition"><a class="header" href="#middleware-composition">Middleware Composition</a></h3>
<p>Combine JACS with other middleware:</p>
<pre><code class="language-javascript">import rateLimit from 'express-rate-limit';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});

// Apply multiple middleware in order
app.use('/api',
  limiter,                              // Rate limiting first
  express.text({ type: '*/*' }),        // Parse body as text
  JACSExpressMiddleware({ configPath: './jacs.config.json' })  // JACS verification
);
</code></pre>
<h3 id="logging-middleware"><a class="header" href="#logging-middleware">Logging Middleware</a></h3>
<p>Log JACS requests for auditing:</p>
<pre><code class="language-javascript">function jacsLogger(req, res, next) {
  if (req.jacsPayload) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      method: req.method,
      path: req.path,
      jacsPayload: req.jacsPayload,
      ip: req.ip
    }));
  }
  next();
}

app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));
app.use('/api', jacsLogger);  // After JACS middleware
</code></pre>
<h3 id="authentication-integration"><a class="header" href="#authentication-integration">Authentication Integration</a></h3>
<p>Combine JACS with user authentication:</p>
<pre><code class="language-javascript">// JACS middleware first
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));

// Then authentication check
function requireAuth(req, res, next) {
  const payload = req.jacsPayload;

  if (!payload || !payload.userId) {
    return res.status(401).send({ error: 'Authentication required' });
  }

  // Attach user to request
  req.user = { id: payload.userId };
  next();
}

app.post('/api/protected', requireAuth, (req, res) =&gt; {
  res.send({
    message: `Hello, user ${req.user.id}`,
    data: req.jacsPayload.data
  });
});
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="unit-testing-routes"><a class="header" href="#unit-testing-routes">Unit Testing Routes</a></h3>
<pre><code class="language-javascript">import request from 'supertest';
import jacs from '@hai.ai/jacs';

describe('JACS API', () =&gt; {
  beforeAll(async () =&gt; {
    await jacs.load('./jacs.test.config.json');
  });

  it('should accept valid JACS requests', async () =&gt; {
    const payload = { action: 'test', data: 'hello' };
    const signedRequest = await jacs.signRequest(payload);

    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send(signedRequest);

    expect(response.status).toBe(200);

    // Verify response is JACS-signed
    const verified = await jacs.verifyResponse(response.text);
    expect(verified.payload.echo).toEqual(payload);
  });

  it('should reject unsigned requests', async () =&gt; {
    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send('{"invalid": "request"}');

    expect(response.status).toBe(400);
  });
});
</code></pre>
<h3 id="mock-jacs-for-testing"><a class="header" href="#mock-jacs-for-testing">Mock JACS for Testing</a></h3>
<pre><code class="language-javascript">// test/mocks/jacs.js
export const mockJacs = {
  payload: null,

  setPayload(p) {
    this.payload = p;
  },

  reset() {
    this.payload = null;
  }
};

// Mock middleware for testing
export function mockJacsMiddleware(req, res, next) {
  req.jacsPayload = mockJacs.payload;
  next();
}

// In tests
describe('API without real JACS', () =&gt; {
  beforeEach(() =&gt; {
    mockJacs.setPayload({ userId: 'test-user', action: 'test' });
  });

  afterEach(() =&gt; {
    mockJacs.reset();
  });

  it('processes payload correctly', async () =&gt; {
    const response = await request(testApp)
      .post('/api/process')
      .send('test');

    expect(response.status).toBe(200);
  });
});
</code></pre>
<h2 id="complete-application-example"><a class="header" href="#complete-application-example">Complete Application Example</a></h2>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();

// Health check (no JACS)
app.get('/health', (req, res) =&gt; res.send({ status: 'healthy' }));

// JACS-protected API routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Validation middleware
function requirePayload(req, res, next) {
  if (!req.jacsPayload) {
    return res.status(400).send({ error: 'Invalid JACS request' });
  }
  next();
}

// Routes
app.post('/api/echo', requirePayload, (req, res) =&gt; {
  res.send({ echo: req.jacsPayload });
});

app.post('/api/users', requirePayload, (req, res) =&gt; {
  const { name, email } = req.jacsPayload;

  if (!name || !email) {
    return res.status(400).send({ error: 'Name and email required' });
  }

  const user = createUser({ name, email });
  res.send({ user, created: true });
});

app.post('/api/documents', requirePayload, async (req, res) =&gt; {
  const { title, content } = req.jacsPayload;

  const document = await createDocument({ title, content });
  res.send({ document });
});

// Error handler
app.use((err, req, res, next) =&gt; {
  console.error('Error:', err);
  res.status(500).send({ error: 'Internal server error' });
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`JACS Express server listening on port ${PORT}`);
});
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="body-parsing-issues"><a class="header" href="#body-parsing-issues">Body Parsing Issues</a></h3>
<p><strong>Problem</strong>: <code>req.jacsPayload</code> is always undefined</p>
<p><strong>Solution</strong>: Ensure <code>express.text()</code> comes before JACS middleware:</p>
<pre><code class="language-javascript">// Correct
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: '...' }));

// Wrong
app.use('/api', JACSExpressMiddleware({ configPath: '...' }));
app.use('/api', express.text({ type: '*/*' }));
</code></pre>
<h3 id="json-body-parser-conflict"><a class="header" href="#json-body-parser-conflict">JSON Body Parser Conflict</a></h3>
<p><strong>Problem</strong>: Using <code>express.json()</code> interferes with JACS</p>
<p><strong>Solution</strong>: Use route-specific middleware:</p>
<pre><code class="language-javascript">// JSON for non-JACS routes
app.use('/public', express.json());

// Text for JACS routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: '...' }));
</code></pre>
<h3 id="response-not-signed"><a class="header" href="#response-not-signed">Response Not Signed</a></h3>
<p><strong>Problem</strong>: Responses are plain JSON, not JACS-signed</p>
<p><strong>Solution</strong>: Ensure you're sending an object, not a string:</p>
<pre><code class="language-javascript">// Will be signed
res.send({ data: 'value' });

// Will NOT be signed
res.send(JSON.stringify({ data: 'value' }));
</code></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li><a href="nodejs/http.html">HTTP Server</a> - Core HTTP integration concepts</li>
<li><a href="nodejs/mcp.html">MCP Integration</a> - Model Context Protocol support</li>
<li><a href="nodejs/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-3"><a class="header" href="#api-reference-3">API Reference</a></h1>
<p>Complete API documentation for the <code>@hai.ai/jacs</code> Node.js package.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
<h2 id="core-module"><a class="header" href="#core-module">Core Module</a></h2>
<pre><code class="language-javascript">import { JacsAgent, hashString, createConfig } from '@hai.ai/jacs';
</code></pre>
<hr />
<h2 id="jacsagent-class"><a class="header" href="#jacsagent-class">JacsAgent Class</a></h2>
<p>The <code>JacsAgent</code> class is the primary interface for JACS operations. Each instance maintains its own state and can be used independently, allowing multiple agents in the same process.</p>
<h3 id="constructor"><a class="header" href="#constructor">Constructor</a></h3>
<pre><code class="language-javascript">new JacsAgent()
</code></pre>
<p>Creates a new empty JacsAgent instance. Call <code>load()</code> to initialize with a configuration.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const agent = new JacsAgent();
agent.load('./jacs.config.json');
</code></pre>
<hr />
<h3 id="agentloadconfigpath"><a class="header" href="#agentloadconfigpath">agent.load(configPath)</a></h3>
<p>Load and initialize the agent from a configuration file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>configPath</code> (string): Path to the JACS configuration file</li>
</ul>
<p><strong>Returns:</strong> string - The loaded agent's JSON</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const agent = new JacsAgent();
const agentJson = agent.load('./jacs.config.json');
console.log('Agent loaded:', JSON.parse(agentJson).jacsId);
</code></pre>
<hr />
<h3 id="agentcreatedocumentdocumentstring-customschema-outputfilename-nosave-attachments-embed"><a class="header" href="#agentcreatedocumentdocumentstring-customschema-outputfilename-nosave-attachments-embed">agent.createDocument(documentString, customSchema?, outputFilename?, noSave?, attachments?, embed?)</a></h3>
<p>Create and sign a new JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): JSON string of the document content</li>
<li><code>customSchema</code> (string, optional): Path to a custom JSON Schema for validation</li>
<li><code>outputFilename</code> (string, optional): Filename to save the document</li>
<li><code>noSave</code> (boolean, optional): If true, don't save to storage (default: false)</li>
<li><code>attachments</code> (string, optional): Path to file attachments</li>
<li><code>embed</code> (boolean, optional): If true, embed attachments in the document</li>
</ul>
<p><strong>Returns:</strong> string - The signed document as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Basic document creation
const doc = agent.createDocument(JSON.stringify({
  title: 'My Document',
  content: 'Hello, World!'
}));

// With custom schema
const validatedDoc = agent.createDocument(
  JSON.stringify({ title: 'Validated', amount: 100 }),
  './schemas/invoice.schema.json'
);

// Without saving
const tempDoc = agent.createDocument(
  JSON.stringify({ data: 'temporary' }),
  null,
  null,
  true  // noSave = true
);

// With attachments
const docWithFile = agent.createDocument(
  JSON.stringify({ report: 'Monthly Report' }),
  null,
  null,
  false,
  './report.pdf',
  true  // embed = true
);
</code></pre>
<hr />
<h3 id="agentverifydocumentdocumentstring"><a class="header" href="#agentverifydocumentdocumentstring">agent.verifyDocument(documentString)</a></h3>
<p>Verify a document's signature and hash integrity.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The signed document JSON string</li>
</ul>
<p><strong>Returns:</strong> boolean - True if the document is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const isValid = agent.verifyDocument(signedDocumentJson);
if (isValid) {
  console.log('Document signature verified');
} else {
  console.log('Document verification failed');
}
</code></pre>
<hr />
<h3 id="agentverifysignaturedocumentstring-signaturefield"><a class="header" href="#agentverifysignaturedocumentstring-signaturefield">agent.verifySignature(documentString, signatureField?)</a></h3>
<p>Verify a document's signature with an optional custom signature field.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The signed document JSON string</li>
<li><code>signatureField</code> (string, optional): Name of the signature field (default: 'jacsSignature')</li>
</ul>
<p><strong>Returns:</strong> boolean - True if the signature is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Verify default signature field
const isValid = agent.verifySignature(docJson);

// Verify custom signature field
const isValidCustom = agent.verifySignature(docJson, 'customSignature');
</code></pre>
<hr />
<h3 id="agentupdatedocumentdocumentkey-newdocumentstring-attachments-embed"><a class="header" href="#agentupdatedocumentdocumentkey-newdocumentstring-attachments-embed">agent.updateDocument(documentKey, newDocumentString, attachments?, embed?)</a></h3>
<p>Update an existing document, creating a new version.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentKey</code> (string): The document key in format <code>"id:version"</code></li>
<li><code>newDocumentString</code> (string): The modified document as JSON string</li>
<li><code>attachments</code> (Array<string>, optional): Array of attachment file paths</li>
<li><code>embed</code> (boolean, optional): If true, embed attachments</li>
</ul>
<p><strong>Returns:</strong> string - The updated document as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Parse existing document to get key
const doc = JSON.parse(signedDoc);
const documentKey = `${doc.jacsId}:${doc.jacsVersion}`;

// Update the document
const updatedDoc = agent.updateDocument(
  documentKey,
  JSON.stringify({
    ...doc,
    title: 'Updated Title',
    content: 'Modified content'
  })
);
</code></pre>
<hr />
<h3 id="agentcreateagreementdocumentstring-agentids-question-context-agreementfieldname"><a class="header" href="#agentcreateagreementdocumentstring-agentids-question-context-agreementfieldname">agent.createAgreement(documentString, agentIds, question?, context?, agreementFieldName?)</a></h3>
<p>Add an agreement requiring multiple agent signatures to a document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The document JSON string</li>
<li><code>agentIds</code> (Array<string>): Array of agent IDs required to sign</li>
<li><code>question</code> (string, optional): The agreement question</li>
<li><code>context</code> (string, optional): Additional context for the agreement</li>
<li><code>agreementFieldName</code> (string, optional): Field name for the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> string - The document with agreement as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const docWithAgreement = agent.createAgreement(
  signedDocumentJson,
  ['agent-1-uuid', 'agent-2-uuid', 'agent-3-uuid'],
  'Do you agree to these terms?',
  'Q1 2024 Service Agreement',
  'jacsAgreement'
);
</code></pre>
<hr />
<h3 id="agentsignagreementdocumentstring-agreementfieldname"><a class="header" href="#agentsignagreementdocumentstring-agreementfieldname">agent.signAgreement(documentString, agreementFieldName?)</a></h3>
<p>Sign an agreement as the current agent.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The document with agreement JSON string</li>
<li><code>agreementFieldName</code> (string, optional): Field name of the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> string - The document with this agent's signature added</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const signedAgreement = agent.signAgreement(
  docWithAgreementJson,
  'jacsAgreement'
);
</code></pre>
<hr />
<h3 id="agentcheckagreementdocumentstring-agreementfieldname"><a class="header" href="#agentcheckagreementdocumentstring-agreementfieldname">agent.checkAgreement(documentString, agreementFieldName?)</a></h3>
<p>Check the status of an agreement (which agents have signed).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The document with agreement JSON string</li>
<li><code>agreementFieldName</code> (string, optional): Field name of the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> string - JSON string with agreement status</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const statusJson = agent.checkAgreement(signedAgreementJson);
const status = JSON.parse(statusJson);

console.log('Required signers:', status.required);
console.log('Signatures received:', status.signed);
console.log('Complete:', status.complete);
</code></pre>
<hr />
<h3 id="agentsignstringdata"><a class="header" href="#agentsignstringdata">agent.signString(data)</a></h3>
<p>Sign arbitrary string data with the agent's private key.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (string): The data to sign</li>
</ul>
<p><strong>Returns:</strong> string - Base64-encoded signature</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const signature = agent.signString('Important message');
console.log('Signature:', signature);
</code></pre>
<hr />
<h3 id="agentverifystringdata-signaturebase64-publickey-publickeyenctype"><a class="header" href="#agentverifystringdata-signaturebase64-publickey-publickeyenctype">agent.verifyString(data, signatureBase64, publicKey, publicKeyEncType)</a></h3>
<p>Verify a signature on arbitrary string data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (string): The original data</li>
<li><code>signatureBase64</code> (string): The base64-encoded signature</li>
<li><code>publicKey</code> (Buffer): The public key as a Buffer</li>
<li><code>publicKeyEncType</code> (string): The key algorithm (e.g., 'ring-Ed25519')</li>
</ul>
<p><strong>Returns:</strong> boolean - True if the signature is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const isValid = agent.verifyString(
  'Important message',
  signatureBase64,
  publicKeyBuffer,
  'ring-Ed25519'
);
</code></pre>
<hr />
<h3 id="agentsignrequestparams"><a class="header" href="#agentsignrequestparams">agent.signRequest(params)</a></h3>
<p>Sign a request payload, wrapping it in a JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>params</code> (any): The request payload object</li>
</ul>
<p><strong>Returns:</strong> string - JACS-signed request as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const signedRequest = agent.signRequest({
  method: 'GET',
  path: '/api/data',
  timestamp: new Date().toISOString(),
  body: { query: 'value' }
});
</code></pre>
<hr />
<h3 id="agentverifyresponsedocumentstring"><a class="header" href="#agentverifyresponsedocumentstring">agent.verifyResponse(documentString)</a></h3>
<p>Verify a JACS-signed response and extract the payload.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The JACS-signed response</li>
</ul>
<p><strong>Returns:</strong> object - Object containing the verified payload</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = agent.verifyResponse(jacsResponseString);
const payload = result.payload;
console.log('Verified payload:', payload);
</code></pre>
<hr />
<h3 id="agentverifyresponsewithagentiddocumentstring"><a class="header" href="#agentverifyresponsewithagentiddocumentstring">agent.verifyResponseWithAgentId(documentString)</a></h3>
<p>Verify a response and return both the payload and signer's agent ID.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>documentString</code> (string): The JACS-signed response</li>
</ul>
<p><strong>Returns:</strong> object - Object with payload and agent ID</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = agent.verifyResponseWithAgentId(jacsResponseString);
console.log('Payload:', result.payload);
console.log('Signed by agent:', result.agentId);
</code></pre>
<hr />
<h3 id="agentverifyagentagentfile"><a class="header" href="#agentverifyagentagentfile">agent.verifyAgent(agentFile?)</a></h3>
<p>Verify the agent's own signature and hash, or verify another agent file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>agentFile</code> (string, optional): Path to an agent file to verify</li>
</ul>
<p><strong>Returns:</strong> boolean - True if the agent is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Verify the loaded agent
const isValid = agent.verifyAgent();

// Verify another agent file
const isOtherValid = agent.verifyAgent('./other-agent.json');
</code></pre>
<hr />
<h3 id="agentupdateagentnewagentstring"><a class="header" href="#agentupdateagentnewagentstring">agent.updateAgent(newAgentString)</a></h3>
<p>Update the agent document with new data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>newAgentString</code> (string): The modified agent document as JSON string</li>
</ul>
<p><strong>Returns:</strong> string - The updated agent document</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const currentAgent = JSON.parse(agent.load('./jacs.config.json'));
const updatedAgent = agent.updateAgent(JSON.stringify({
  ...currentAgent,
  description: 'Updated description'
}));
</code></pre>
<hr />
<h3 id="agentsignagentagentstring-publickey-publickeyenctype"><a class="header" href="#agentsignagentagentstring-publickey-publickeyenctype">agent.signAgent(agentString, publicKey, publicKeyEncType)</a></h3>
<p>Sign another agent's document with a registration signature.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>agentString</code> (string): The agent document to sign</li>
<li><code>publicKey</code> (Buffer): The public key as a Buffer</li>
<li><code>publicKeyEncType</code> (string): The key algorithm</li>
</ul>
<p><strong>Returns:</strong> string - The signed agent document</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const signedAgent = agent.signAgent(
  externalAgentJson,
  publicKeyBuffer,
  'ring-Ed25519'
);
</code></pre>
<hr />
<h2 id="utility-functions-1"><a class="header" href="#utility-functions-1">Utility Functions</a></h2>
<h3 id="hashstringdata"><a class="header" href="#hashstringdata">hashString(data)</a></h3>
<p>Hash a string using SHA-256.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (string): The string to hash</li>
</ul>
<p><strong>Returns:</strong> string - Hexadecimal hash string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { hashString } from '@hai.ai/jacs';

const hash = hashString('data to hash');
console.log('SHA-256:', hash);
</code></pre>
<hr />
<h3 id="createconfigoptions"><a class="header" href="#createconfigoptions">createConfig(options)</a></h3>
<p>Create a JACS configuration JSON string programmatically.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>jacsUseSecurity</code> (string, optional): Enable security features</li>
<li><code>jacsDataDirectory</code> (string, optional): Directory for data storage</li>
<li><code>jacsKeyDirectory</code> (string, optional): Directory for key storage</li>
<li><code>jacsAgentPrivateKeyFilename</code> (string, optional): Private key filename</li>
<li><code>jacsAgentPublicKeyFilename</code> (string, optional): Public key filename</li>
<li><code>jacsAgentKeyAlgorithm</code> (string, optional): Signing algorithm</li>
<li><code>jacsPrivateKeyPassword</code> (string, optional): Password for private key</li>
<li><code>jacsAgentIdAndVersion</code> (string, optional): Agent ID and version to load</li>
<li><code>jacsDefaultStorage</code> (string, optional): Storage backend ('fs', 's3', 'memory')</li>
</ul>
<p><strong>Returns:</strong> string - Configuration as JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { createConfig } from '@hai.ai/jacs';

const configJson = createConfig(
  undefined,           // jacsUseSecurity
  './jacs_data',       // jacsDataDirectory
  './jacs_keys',       // jacsKeyDirectory
  undefined,           // private key filename
  undefined,           // public key filename
  'ring-Ed25519',      // algorithm
  undefined,           // password
  undefined,           // agent id
  'fs'                 // storage
);

// Write to file
fs.writeFileSync('jacs.config.json', configJson);
</code></pre>
<hr />
<h2 id="http-module"><a class="header" href="#http-module">HTTP Module</a></h2>
<pre><code class="language-javascript">import { JACSExpressMiddleware, JACSKoaMiddleware } from '@hai.ai/jacs/http';
</code></pre>
<h3 id="jacsexpressmiddlewareoptions-1"><a class="header" href="#jacsexpressmiddlewareoptions-1">JACSExpressMiddleware(options)</a></h3>
<p>Express middleware for JACS request/response handling.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options.configPath</code> (string): Path to JACS configuration file</li>
</ul>
<p><strong>Returns:</strong> Express middleware function</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

app.post('/api/data', (req, res) =&gt; {
  // req.jacsPayload contains verified payload
  res.send({ received: req.jacsPayload });
});
</code></pre>
<hr />
<h3 id="jacskoamiddlewareoptions-1"><a class="header" href="#jacskoamiddlewareoptions-1">JACSKoaMiddleware(options)</a></h3>
<p>Koa middleware for JACS request/response handling.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options.configPath</code> (string): Path to JACS configuration file</li>
</ul>
<p><strong>Returns:</strong> Koa middleware function</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { JACSKoaMiddleware } from '@hai.ai/jacs/http';

app.use(JACSKoaMiddleware({
  configPath: './jacs.config.json'
}));

app.use(async (ctx) =&gt; {
  // ctx.state.jacsPayload contains verified payload
  ctx.body = { received: ctx.state.jacsPayload };
});
</code></pre>
<hr />
<h2 id="mcp-module"><a class="header" href="#mcp-module">MCP Module</a></h2>
<pre><code class="language-javascript">import {
  JACSTransportProxy,
  createJACSTransportProxy,
  createJACSTransportProxyAsync
} from '@hai.ai/jacs/mcp';
</code></pre>
<h3 id="jacstransportproxy-1"><a class="header" href="#jacstransportproxy-1">JACSTransportProxy</a></h3>
<p>Class that wraps MCP transports with JACS encryption.</p>
<p><strong>Constructor:</strong></p>
<pre><code class="language-javascript">new JACSTransportProxy(transport, role, jacsConfigPath)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>transport</code>: Any MCP transport (Stdio, SSE, WebSocket)</li>
<li><code>role</code> (string): 'server' or 'client'</li>
<li><code>jacsConfigPath</code> (string): Path to JACS configuration file</li>
</ul>
<hr />
<h3 id="createjacstransportproxytransport-configpath-role"><a class="header" href="#createjacstransportproxytransport-configpath-role">createJACSTransportProxy(transport, configPath, role)</a></h3>
<p>Factory function for creating a transport proxy.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>transport</code>: The underlying MCP transport</li>
<li><code>configPath</code> (string): Path to JACS configuration file</li>
<li><code>role</code> (string): 'server' or 'client'</li>
</ul>
<p><strong>Returns:</strong> JACSTransportProxy instance</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const baseTransport = new StdioServerTransport();
const secureTransport = createJACSTransportProxy(
  baseTransport,
  './jacs.config.json',
  'server'
);
</code></pre>
<hr />
<h3 id="createjacstransportproxyasynctransport-configpath-role"><a class="header" href="#createjacstransportproxyasynctransport-configpath-role">createJACSTransportProxyAsync(transport, configPath, role)</a></h3>
<p>Async factory that waits for JACS to be fully loaded.</p>
<p><strong>Parameters:</strong> Same as <code>createJACSTransportProxy</code></p>
<p><strong>Returns:</strong> Promise<JACSTransportProxy></p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const secureTransport = await createJACSTransportProxyAsync(
  baseTransport,
  './jacs.config.json',
  'server'
);
</code></pre>
<hr />
<h2 id="typescript-support-1"><a class="header" href="#typescript-support-1">TypeScript Support</a></h2>
<p>The package includes full TypeScript definitions. Import types as needed:</p>
<pre><code class="language-typescript">import { JacsAgent, hashString, createConfig } from '@hai.ai/jacs';

const agent: JacsAgent = new JacsAgent();
const hash: string = hashString('data');
const config: string = createConfig(
  undefined,
  './data',
  './keys'
);
</code></pre>
<hr />
<h2 id="deprecated-functions"><a class="header" href="#deprecated-functions">Deprecated Functions</a></h2>
<p>The following module-level functions are deprecated. Use <code>new JacsAgent()</code> and instance methods instead:</p>
<ul>
<li><code>load()</code> - Use <code>agent.load()</code></li>
<li><code>signAgent()</code> - Use <code>agent.signAgent()</code></li>
<li><code>verifyString()</code> - Use <code>agent.verifyString()</code></li>
<li><code>signString()</code> - Use <code>agent.signString()</code></li>
<li><code>verifyAgent()</code> - Use <code>agent.verifyAgent()</code></li>
<li><code>updateAgent()</code> - Use <code>agent.updateAgent()</code></li>
<li><code>verifyDocument()</code> - Use <code>agent.verifyDocument()</code></li>
<li><code>updateDocument()</code> - Use <code>agent.updateDocument()</code></li>
<li><code>verifySignature()</code> - Use <code>agent.verifySignature()</code></li>
<li><code>createAgreement()</code> - Use <code>agent.createAgreement()</code></li>
<li><code>signAgreement()</code> - Use <code>agent.signAgreement()</code></li>
<li><code>createDocument()</code> - Use <code>agent.createDocument()</code></li>
<li><code>checkAgreement()</code> - Use <code>agent.checkAgreement()</code></li>
<li><code>signRequest()</code> - Use <code>agent.signRequest()</code></li>
<li><code>verifyResponse()</code> - Use <code>agent.verifyResponse()</code></li>
<li><code>verifyResponseWithAgentId()</code> - Use <code>agent.verifyResponseWithAgentId()</code></li>
</ul>
<p><strong>Migration Example:</strong></p>
<pre><code class="language-javascript">// Old (deprecated)
import jacs from '@hai.ai/jacs';
await jacs.load('./jacs.config.json');
const doc = jacs.createDocument(JSON.stringify({ data: 'test' }));

// New (recommended)
import { JacsAgent } from '@hai.ai/jacs';
const agent = new JacsAgent();
agent.load('./jacs.config.json');
const doc = agent.createDocument(JSON.stringify({ data: 'test' }));
</code></pre>
<hr />
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<p>All methods may throw errors. Use try/catch for error handling:</p>
<pre><code class="language-javascript">try {
  const agent = new JacsAgent();
  agent.load('./jacs.config.json');
  const doc = agent.createDocument(JSON.stringify({ data: 'test' }));
} catch (error) {
  console.error('JACS error:', error.message);
}
</code></pre>
<hr />
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="nodejs/installation.html">Installation</a> - Getting started</li>
<li><a href="nodejs/basic-usage.html">Basic Usage</a> - Common usage patterns</li>
<li><a href="nodejs/mcp.html">MCP Integration</a> - Model Context Protocol</li>
<li><a href="nodejs/http.html">HTTP Server</a> - HTTP integration</li>
<li><a href="nodejs/express.html">Express Middleware</a> - Express.js patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-installation"><a class="header" href="#python-installation">Python Installation</a></h1>
<p>The JACS Python package (<code>jacs</code>) provides Python bindings to the JACS Rust library, making it easy to integrate JACS into AI/ML workflows, data science projects, and Python applications.</p>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li><strong>Python</strong>: Version 3.10 or higher</li>
<li><strong>pip</strong>: For package management</li>
<li><strong>Operating System</strong>: Linux, macOS, or Windows with WSL</li>
<li><strong>Architecture</strong>: x86_64 or ARM64</li>
</ul>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<h3 id="using-pip"><a class="header" href="#using-pip">Using pip</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<h3 id="using-conda"><a class="header" href="#using-conda">Using conda</a></h3>
<pre><code class="language-bash">conda install -c conda-forge jacs
</code></pre>
<h3 id="using-poetry"><a class="header" href="#using-poetry">Using poetry</a></h3>
<pre><code class="language-bash">poetry add jacs
</code></pre>
<h3 id="development-installation"><a class="header" href="#development-installation">Development Installation</a></h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/HumanAssisted/JACS
cd JACS/jacspy

# Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install in development mode
pip install -e .
</code></pre>
<h2 id="verify-installation-2"><a class="header" href="#verify-installation-2">Verify Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre><code class="language-python"># test.py
import jacs

print('JACS Python bindings loaded successfully!')

# Test basic functionality
try:
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')
    print('Agent loaded successfully!')
except Exception as error:
    print(f'Error loading agent: {error}')
</code></pre>
<p>Run the test:</p>
<pre><code class="language-bash">python test.py
</code></pre>
<h2 id="package-structure-1"><a class="header" href="#package-structure-1">Package Structure</a></h2>
<p>The <code>jacs</code> package provides Python bindings to the JACS Rust library:</p>
<h3 id="core-module-1"><a class="header" href="#core-module-1">Core Module</a></h3>
<pre><code class="language-python">import jacs

# Create and load agent
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Utility functions
hash_value = jacs.hash_string("data to hash")
config_json = jacs.create_config(
    jacs_data_directory="./data",
    jacs_key_directory="./keys",
    jacs_agent_key_algorithm="ring-Ed25519"
)
</code></pre>
<h3 id="jacsagent-methods"><a class="header" href="#jacsagent-methods">JacsAgent Methods</a></h3>
<pre><code class="language-python"># Create a new agent instance
agent = jacs.JacsAgent()

# Load configuration
agent.load('./jacs.config.json')

# Document operations
signed_doc = agent.create_document(json_string)
is_valid = agent.verify_document(document_string)

# Signing operations
signature = agent.sign_string("data to sign")
</code></pre>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<h3 id="configuration-file-3"><a class="header" href="#configuration-file-3">Configuration File</a></h3>
<p>Create a <code>jacs.config.json</code> file:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "agent-uuid:version-uuid"
}
</code></pre>
<h3 id="load-configuration-in-python"><a class="header" href="#load-configuration-in-python">Load Configuration in Python</a></h3>
<pre><code class="language-python">import jacs

# Create agent and load configuration
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<h3 id="programmatic-configuration"><a class="header" href="#programmatic-configuration">Programmatic Configuration</a></h3>
<pre><code class="language-python">import jacs

# Create a configuration JSON string programmatically
config_json = jacs.create_config(
    jacs_data_directory="./jacs_data",
    jacs_key_directory="./jacs_keys",
    jacs_agent_key_algorithm="ring-Ed25519",
    jacs_default_storage="fs"
)
</code></pre>
<h3 id="environment-variables-4"><a class="header" href="#environment-variables-4">Environment Variables</a></h3>
<p>JACS reads environment variables that override configuration file settings:</p>
<pre><code class="language-bash">export JACS_DATA_DIRECTORY="./production_data"
export JACS_KEY_DIRECTORY="./production_keys"
export JACS_AGENT_KEY_ALGORITHM="ring-Ed25519"
export JACS_DEFAULT_STORAGE="fs"
</code></pre>
<h2 id="storage-backends-2"><a class="header" href="#storage-backends-2">Storage Backends</a></h2>
<p>Configure storage in <code>jacs.config.json</code>:</p>
<h3 id="file-system-default-1"><a class="header" href="#file-system-default-1">File System (Default)</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<h3 id="s3-storage-1"><a class="header" href="#s3-storage-1">S3 Storage</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "s3"
}
</code></pre>
<p>S3 credentials are read from standard AWS environment variables.</p>
<h3 id="memory-storage-testing-1"><a class="header" href="#memory-storage-testing-1">Memory Storage (Testing)</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "memory"
}
</code></pre>
<h2 id="cryptographic-algorithms-1"><a class="header" href="#cryptographic-algorithms-1">Cryptographic Algorithms</a></h2>
<h3 id="ring-ed25519-recommended-1"><a class="header" href="#ring-ed25519-recommended-1">ring-Ed25519 (Recommended)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p><strong>Pros</strong>: Fast, secure, small signatures
<strong>Cons</strong>: Requires elliptic curve support</p>
<h3 id="rsa-pss-1"><a class="header" href="#rsa-pss-1">RSA-PSS</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "RSA-PSS"
}
</code></pre>
<p><strong>Pros</strong>: Widely supported, proven security
<strong>Cons</strong>: Larger signatures, slower</p>
<h3 id="pq-dilithium-post-quantum-1"><a class="header" href="#pq-dilithium-post-quantum-1">pq-dilithium (Post-Quantum)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
<p><strong>Pros</strong>: Quantum-resistant
<strong>Cons</strong>: Experimental, large signatures</p>
<h3 id="pq2025-post-quantum-hybrid-1"><a class="header" href="#pq2025-post-quantum-hybrid-1">pq2025 (Post-Quantum Hybrid)</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq2025"
}
</code></pre>
<p><strong>Pros</strong>: Combines ML-DSA-87 with hybrid approach
<strong>Cons</strong>: Newest algorithm, largest signatures</p>
<h2 id="development-setup-1"><a class="header" href="#development-setup-1">Development Setup</a></h2>
<h3 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h3>
<pre><code>my-jacs-project/
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ jacs.config.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ agent.py
‚îÇ   ‚îú‚îÄ‚îÄ tasks.py
‚îÇ   ‚îî‚îÄ‚îÄ agreements.py
‚îú‚îÄ‚îÄ jacs_data/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îî‚îÄ‚îÄ documents/
‚îú‚îÄ‚îÄ jacs_keys/
‚îÇ   ‚îú‚îÄ‚îÄ private.pem
‚îÇ   ‚îî‚îÄ‚îÄ public.pem
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_jacs.py
</code></pre>
<h3 id="requirementstxt-setup"><a class="header" href="#requirementstxt-setup">Requirements.txt Setup</a></h3>
<pre><code>jacs&gt;=0.1.0
fastapi&gt;=0.100.0  # For FastMCP integration
uvicorn&gt;=0.23.0   # For ASGI server
pydantic&gt;=2.0.0   # For data validation
</code></pre>
<h3 id="basic-application-1"><a class="header" href="#basic-application-1">Basic Application</a></h3>
<pre><code class="language-python"># src/app.py
import jacs
import json

def main():
    # Create and load agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Create a document
    document_data = {
        "title": "My First Document",
        "content": "Hello from Python!"
    }

    signed_doc = agent.create_document(json.dumps(document_data))
    print('Document created')

    # Verify the document
    is_valid = agent.verify_document(signed_doc)
    print(f'Document valid: {is_valid}')

    print('JACS agent ready!')
    return agent

if __name__ == "__main__":
    agent = main()
</code></pre>
<h2 id="virtual-environment-setup"><a class="header" href="#virtual-environment-setup">Virtual Environment Setup</a></h2>
<h3 id="using-venv"><a class="header" href="#using-venv">Using venv</a></h3>
<pre><code class="language-bash"># Create virtual environment
python -m venv jacs-env

# Activate (Linux/macOS)
source jacs-env/bin/activate

# Activate (Windows)
jacs-env\Scripts\activate

# Install JACS
pip install jacs
</code></pre>
<h3 id="using-conda-1"><a class="header" href="#using-conda-1">Using conda</a></h3>
<pre><code class="language-bash"># Create conda environment
conda create -n jacs-env python=3.11

# Activate environment
conda activate jacs-env

# Install JACS
pip install jacs
</code></pre>
<h3 id="using-poetry-1"><a class="header" href="#using-poetry-1">Using poetry</a></h3>
<pre><code class="language-bash"># Initialize poetry project
poetry init

# Add JACS dependency
poetry add jacs

# Install dependencies
poetry install

# Activate shell
poetry shell
</code></pre>
<h2 id="jupyter-notebook-setup"><a class="header" href="#jupyter-notebook-setup">Jupyter Notebook Setup</a></h2>
<pre><code class="language-bash"># Install Jupyter in your JACS environment
pip install jupyter

# Start Jupyter
jupyter notebook
</code></pre>
<pre><code class="language-python"># In your notebook
import jacs
import json

# Create and load agent
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create a simple document
doc = agent.create_document(json.dumps({
    "title": "Notebook Analysis",
    "data": [1, 2, 3, 4, 5]
}))

print("Document created!")
print("JACS ready for notebook use!")
</code></pre>
<h2 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h2>
<h3 id="module-not-found-1"><a class="header" href="#module-not-found-1">Module Not Found</a></h3>
<p>If you get <code>ModuleNotFoundError: No module named 'jacs'</code>:</p>
<pre><code class="language-bash"># Check Python version
python --version  # Should be 3.10+

# Check if jacs is installed
pip list | grep jacs

# Reinstall if needed
pip uninstall jacs
pip install jacs
</code></pre>
<h3 id="permission-errors-1"><a class="header" href="#permission-errors-1">Permission Errors</a></h3>
<p>If you get permission errors accessing files:</p>
<pre><code class="language-bash"># Check directory permissions
ls -la jacs_data/ jacs_keys/

# Fix permissions
chmod 755 jacs_data/ jacs_keys/
chmod 600 jacs_keys/*.pem
</code></pre>
<h3 id="binary-compatibility-1"><a class="header" href="#binary-compatibility-1">Binary Compatibility</a></h3>
<p>If you get binary compatibility errors:</p>
<pre><code class="language-bash"># Update pip and reinstall
pip install --upgrade pip
pip uninstall jacs
pip install jacs --no-cache-dir
</code></pre>
<h3 id="windows-issues"><a class="header" href="#windows-issues">Windows Issues</a></h3>
<p>On Windows, you may need Visual C++ Build Tools:</p>
<pre><code class="language-bash"># Install Visual C++ Build Tools
# Or use conda-forge
conda install -c conda-forge jacs
</code></pre>
<h2 id="type-hints-and-ide-support"><a class="header" href="#type-hints-and-ide-support">Type Hints and IDE Support</a></h2>
<p>JACS is built with Rust and PyO3, providing Python bindings:</p>
<pre><code class="language-python">import jacs
import json

# Create agent instance
agent: jacs.JacsAgent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create and verify documents
signed_doc: str = agent.create_document(json.dumps({"title": "Test"}))
is_valid: bool = agent.verify_document(signed_doc)
</code></pre>
<h2 id="testing-setup"><a class="header" href="#testing-setup">Testing Setup</a></h2>
<pre><code class="language-python"># tests/test_jacs.py
import unittest
import jacs
import json

class TestJACS(unittest.TestCase):
    def setUp(self):
        # Requires a valid jacs.config.json file
        self.agent = jacs.JacsAgent()
        self.agent.load('./jacs.config.json')

    def test_document_creation(self):
        doc_data = {"title": "Test Document", "content": "Test content"}
        signed_doc = self.agent.create_document(json.dumps(doc_data))

        # Document should be a valid JSON string
        parsed = json.loads(signed_doc)
        self.assertIn("jacsId", parsed)
        self.assertIn("jacsSignature", parsed)

    def test_document_verification(self):
        doc_data = {"title": "Verify Test"}
        signed_doc = self.agent.create_document(json.dumps(doc_data))

        is_valid = self.agent.verify_document(signed_doc)
        self.assertTrue(is_valid)

    def test_sign_string(self):
        signature = self.agent.sign_string("test data")
        self.assertIsInstance(signature, str)
        self.assertTrue(len(signature) &gt; 0)

if __name__ == "__main__":
    unittest.main()
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<p>Now that you have JACS installed:</p>
<ol>
<li><strong><a href="python/basic-usage.html">Basic Usage</a></strong> - Learn core JACS operations</li>
<li><strong><a href="python/mcp.html">MCP Integration</a></strong> - Add Model Context Protocol support</li>
<li><strong><a href="python/mcp.html">FastMCP Integration</a></strong> - Build advanced MCP servers</li>
<li><strong><a href="python/api.html">API Reference</a></strong> - Complete API documentation</li>
</ol>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>Check out the complete examples in the <a href="python/../examples/python.html">examples directory</a>:</p>
<ul>
<li>Basic agent creation and task management</li>
<li>Jupyter notebook workflows</li>
<li>FastMCP server implementation</li>
<li>AI/ML pipeline integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplified-api-1"><a class="header" href="#simplified-api-1">Simplified API</a></h1>
<p>The simplified API (<code>jacs.simple</code>) provides a streamlined, module-level interface for common JACS operations. It's designed to get you signing and verifying in under 2 minutes.</p>
<h2 id="quick-start-6"><a class="header" href="#quick-start-6">Quick Start</a></h2>
<p>Zero-config -- one call to start signing:</p>
<pre><code class="language-python">import jacs.simple as jacs

jacs.quickstart()
signed = jacs.sign_message({"action": "approve", "amount": 100})
result = jacs.verify(signed.raw)
print(f"Valid: {result.valid}, Signer: {result.signer_id}")
</code></pre>
<p><code>quickstart()</code> creates an ephemeral agent with keys in memory. No config file, no setup. Pass <code>algorithm="ring-Ed25519"</code> to override the default (<code>pq2025</code>).</p>
<p>For production use with persistent keys, load from a config file instead:</p>
<pre><code class="language-python">agent = jacs.load("./jacs.config.json")
signed = jacs.sign_message({"action": "approve", "amount": 100})
</code></pre>
<h2 id="when-to-use-the-simplified-api-1"><a class="header" href="#when-to-use-the-simplified-api-1">When to Use the Simplified API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Simplified API</th><th>JacsAgent Class</th></tr></thead><tbody>
<tr><td>Quick prototyping</td><td>Multiple agents in one process</td></tr>
<tr><td>Scripts and CLI tools</td><td>Complex multi-document workflows</td></tr>
<tr><td>MCP tool implementations</td><td>Fine-grained control</td></tr>
<tr><td>Single-agent applications</td><td>Custom error handling</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="api-reference-4"><a class="header" href="#api-reference-4">API Reference</a></h2>
<h3 id="quickstartalgorithmnone"><a class="header" href="#quickstartalgorithmnone">quickstart(algorithm=None)</a></h3>
<p>Create an ephemeral agent with keys in memory. No config file, no directories, no setup. Call this once before <code>sign_message()</code> or <code>verify()</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>algorithm</code> (str, optional): Signing algorithm. Default: <code>"pq2025"</code>. Also: <code>"ring-Ed25519"</code>, <code>"RSA-PSS"</code>.</li>
</ul>
<p><strong>Returns:</strong> <code>AgentInfo</code> dataclass</p>
<pre><code class="language-python">info = jacs.quickstart()
print(f"Agent ID: {info.agent_id}")

# Or with a specific algorithm
info = jacs.quickstart(algorithm="ring-Ed25519")
</code></pre>
<hr />
<h3 id="loadconfig_pathnone"><a class="header" href="#loadconfig_pathnone">load(config_path=None)</a></h3>
<p>Load a persistent agent from a configuration file. Use this instead of <code>quickstart()</code> when you need keys on disk.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>config_path</code> (str, optional): Path to jacs.config.json (default: "./jacs.config.json")</li>
</ul>
<p><strong>Returns:</strong> <code>AgentInfo</code> dataclass</p>
<p><strong>Raises:</strong> <code>JacsError</code> if config not found or invalid</p>
<pre><code class="language-python">info = jacs.load("./jacs.config.json")
print(f"Agent ID: {info.agent_id}")
print(f"Config: {info.config_path}")
</code></pre>
<hr />
<h3 id="is_loaded"><a class="header" href="#is_loaded">is_loaded()</a></h3>
<p>Check if an agent is currently loaded.</p>
<p><strong>Returns:</strong> bool</p>
<pre><code class="language-python">if not jacs.is_loaded():
    jacs.load("./jacs.config.json")
</code></pre>
<hr />
<h3 id="get_agent_info"><a class="header" href="#get_agent_info">get_agent_info()</a></h3>
<p>Get information about the currently loaded agent.</p>
<p><strong>Returns:</strong> <code>AgentInfo</code> or None if no agent is loaded</p>
<pre><code class="language-python">info = jacs.get_agent_info()
if info:
    print(f"Agent: {info.agent_id}")
</code></pre>
<hr />
<h3 id="verify_self"><a class="header" href="#verify_self">verify_self()</a></h3>
<p>Verify the loaded agent's own integrity (signature and hash).</p>
<p><strong>Returns:</strong> <code>VerificationResult</code></p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent is loaded</p>
<pre><code class="language-python">result = jacs.verify_self()
if result.valid:
    print("Agent integrity verified")
else:
    print(f"Errors: {result.errors}")
</code></pre>
<hr />
<h3 id="sign_messagedata"><a class="header" href="#sign_messagedata">sign_message(data)</a></h3>
<p>Sign arbitrary data as a JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (any): Dict, list, string, or any JSON-serializable value</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code></p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent is loaded</p>
<pre><code class="language-python"># Sign a dict
signed = jacs.sign_message({
    "action": "transfer",
    "amount": 500,
    "recipient": "agent-123"
})

print(f"Document ID: {signed.document_id}")
print(f"Signed by: {signed.agent_id}")
print(f"Timestamp: {signed.timestamp}")
print(f"Raw JSON: {signed.raw}")
</code></pre>
<hr />
<h3 id="sign_filefile_path-embedfalse"><a class="header" href="#sign_filefile_path-embedfalse">sign_file(file_path, embed=False)</a></h3>
<p>Sign a file with optional content embedding.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>file_path</code> (str): Path to the file to sign</li>
<li><code>embed</code> (bool, optional): If True, embed file content in the document (default: False)</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code></p>
<p><strong>Raises:</strong> <code>JacsError</code> if file not found or no agent loaded</p>
<pre><code class="language-python"># Reference only (stores hash)
signed = jacs.sign_file("contract.pdf", embed=False)

# Embed content (creates portable document)
embedded = jacs.sign_file("contract.pdf", embed=True)
</code></pre>
<hr />
<h3 id="verifysigned_document"><a class="header" href="#verifysigned_document">verify(signed_document)</a></h3>
<p>Verify a signed document and extract its content.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>signed_document</code> (str): The JSON string of the signed document</li>
</ul>
<p><strong>Returns:</strong> <code>VerificationResult</code></p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent is loaded</p>
<pre><code class="language-python">result = jacs.verify(signed_json)

if result.valid:
    print(f"Signed by: {result.signer_id}")
    print(f"Timestamp: {result.timestamp}")
else:
    print(f"Invalid: {', '.join(result.errors)}")
</code></pre>
<hr />
<h3 id="verify_standalonedocument-key_resolutionlocal-data_directorynone-key_directorynone"><a class="header" href="#verify_standalonedocument-key_resolutionlocal-data_directorynone-key_directorynone">verify_standalone(document, key_resolution="local", data_directory=None, key_directory=None)</a></h3>
<p>Verify a signed document <strong>without</strong> loading an agent. Use when you only need to verify (e.g. a lightweight API).</p>
<p><strong>Parameters:</strong> <code>document</code> (str|dict), <code>key_resolution</code> (str), <code>data_directory</code> (str, optional), <code>key_directory</code> (str, optional)</p>
<p><strong>Returns:</strong> <code>VerificationResult</code></p>
<hr />
<h3 id="auditconfig_pathnone-recent_nnone"><a class="header" href="#auditconfig_pathnone-recent_nnone">audit(config_path=None, recent_n=None)</a></h3>
<p>Run a read-only security audit and health checks. Returns a dict with <code>risks</code>, <code>health_checks</code>, <code>summary</code>, and <code>overall_status</code>. Does not require a loaded agent; does not modify state.</p>
<p>See <a href="python/../advanced/security.html#security-audit-audit">Security Model ‚Äî Security Audit</a> for full details and options.</p>
<pre><code class="language-python">result = jacs.audit()
print(f"Risks: {len(result['risks'])}, Status: {result['overall_status']}")
</code></pre>
<hr />
<h3 id="update_agentnew_agent_data"><a class="header" href="#update_agentnew_agent_data">update_agent(new_agent_data)</a></h3>
<p>Update the agent document with new data and re-sign it.</p>
<p>This function expects a <strong>complete agent document</strong> (not partial updates). Use <code>export_agent()</code> to get the current document, modify it, then pass it here.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>new_agent_data</code> (dict|str): Complete agent document as JSON string or dict</li>
</ul>
<p><strong>Returns:</strong> str - The updated and re-signed agent document</p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent loaded, <code>JacsError</code> if validation fails</p>
<pre><code class="language-python">import json

# Get current agent document
agent_doc = json.loads(jacs.export_agent())

# Modify fields
agent_doc["jacsAgentType"] = "hybrid"
agent_doc["jacsContacts"] = [{"contactFirstName": "Jane", "contactLastName": "Doe"}]

# Update (creates new version, re-signs, re-hashes)
updated = jacs.update_agent(agent_doc)
new_doc = json.loads(updated)

print(f"New version: {new_doc['jacsVersion']}")
print(f"Previous: {new_doc['jacsPreviousVersion']}")
</code></pre>
<p><strong>Valid <code>jacsAgentType</code> values:</strong> <code>"human"</code>, <code>"human-org"</code>, <code>"hybrid"</code>, <code>"ai"</code></p>
<hr />
<h3 id="update_documentdocument_id-new_document_data-attachmentsnone-embedfalse"><a class="header" href="#update_documentdocument_id-new_document_data-attachmentsnone-embedfalse">update_document(document_id, new_document_data, attachments=None, embed=False)</a></h3>
<p>Update an existing document with new data and re-sign it.</p>
<p><strong>Note:</strong> The original document must have been saved to disk (created without <code>no_save=True</code>).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_id</code> (str): The document ID (jacsId) to update</li>
<li><code>new_document_data</code> (dict|str): Updated document as JSON string or dict</li>
<li><code>attachments</code> (list, optional): List of file paths to attach</li>
<li><code>embed</code> (bool, optional): If True, embed attachment contents</li>
</ul>
<p><strong>Returns:</strong> <code>SignedDocument</code> with the updated document</p>
<p><strong>Raises:</strong> <code>JacsError</code> if document not found, no agent loaded, or validation fails</p>
<pre><code class="language-python">import json

# Create a document (must be saved to disk)
original = jacs.sign_message({"status": "pending", "amount": 100})

# Later, update it
doc = json.loads(original.raw)
doc["content"]["status"] = "approved"

updated = jacs.update_document(original.document_id, doc)
new_doc = json.loads(updated.raw)

print(f"New version: {new_doc['jacsVersion']}")
print(f"Previous: {new_doc['jacsPreviousVersion']}")
</code></pre>
<hr />
<h3 id="export_agent"><a class="header" href="#export_agent">export_agent()</a></h3>
<p>Export the current agent document for sharing or inspection.</p>
<p><strong>Returns:</strong> str - The agent JSON document</p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent loaded</p>
<pre><code class="language-python">agent_doc = jacs.export_agent()
print(agent_doc)

# Parse to inspect
agent = json.loads(agent_doc)
print(f"Agent type: {agent['jacsAgentType']}")
</code></pre>
<hr />
<h3 id="get_dns_recorddomain-ttl3600"><a class="header" href="#get_dns_recorddomain-ttl3600">get_dns_record(domain, ttl=3600)</a></h3>
<p>Return the DNS TXT record line for the loaded agent (for DNS-based discovery). Format: <code>_v1.agent.jacs.{domain}. TTL IN TXT "v=hai.ai; ..."</code>.</p>
<p><strong>Returns:</strong> str</p>
<hr />
<h3 id="get_well_known_json"><a class="header" href="#get_well_known_json">get_well_known_json()</a></h3>
<p>Return the well-known JSON object for the loaded agent (e.g. for <code>/.well-known/jacs-pubkey.json</code>). Keys: <code>publicKey</code>, <code>publicKeyHash</code>, <code>algorithm</code>, <code>agentId</code>.</p>
<p><strong>Returns:</strong> dict</p>
<hr />
<h3 id="get_public_key"><a class="header" href="#get_public_key">get_public_key()</a></h3>
<p>Get the loaded agent's public key in PEM format for sharing with others.</p>
<p><strong>Returns:</strong> str - PEM-encoded public key</p>
<p><strong>Raises:</strong> <code>AgentNotLoadedError</code> if no agent loaded</p>
<pre><code class="language-python">pem = jacs.get_public_key()
print(pem)
# -----BEGIN PUBLIC KEY-----
# ...
# -----END PUBLIC KEY-----
</code></pre>
<hr />
<h2 id="type-definitions-1"><a class="header" href="#type-definitions-1">Type Definitions</a></h2>
<p>All types are Python dataclasses for convenient access:</p>
<h3 id="agentinfo-1"><a class="header" href="#agentinfo-1">AgentInfo</a></h3>
<pre><code class="language-python">@dataclass
class AgentInfo:
    agent_id: str       # Agent's UUID
    config_path: str    # Path to loaded config
    public_key_path: Optional[str] = None  # Path to public key file
</code></pre>
<h3 id="signeddocument-1"><a class="header" href="#signeddocument-1">SignedDocument</a></h3>
<pre><code class="language-python">@dataclass
class SignedDocument:
    raw: str            # Full JSON document with signature
    document_id: str    # Document's UUID (jacsId)
    agent_id: str       # Signing agent's ID
    timestamp: str      # ISO 8601 timestamp
</code></pre>
<h3 id="verificationresult-1"><a class="header" href="#verificationresult-1">VerificationResult</a></h3>
<pre><code class="language-python">@dataclass
class VerificationResult:
    valid: bool                  # True if signature verified
    signer_id: Optional[str]     # Agent who signed
    timestamp: Optional[str]     # When it was signed
    attachments: List[Attachment]  # File attachments
    errors: List[str]            # Error messages if invalid
</code></pre>
<h3 id="attachment-1"><a class="header" href="#attachment-1">Attachment</a></h3>
<pre><code class="language-python">@dataclass
class Attachment:
    filename: str       # Original filename
    mime_type: str      # MIME type
    hash: str           # SHA-256 hash
    embedded: bool      # True if content is embedded
    content: Optional[bytes] = None  # Embedded content (if available)
</code></pre>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<pre><code class="language-python">class JacsError(Exception):
    """Base exception for JACS errors."""
    pass

class AgentNotLoadedError(JacsError):
    """Raised when an operation requires a loaded agent."""
    pass
</code></pre>
<hr />
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<pre><code class="language-python">import json
import jacs.simple as jacs
from jacs.types import JacsError, AgentNotLoadedError

# Load agent
agent = jacs.load("./jacs.config.json")
print(f"Loaded agent: {agent.agent_id}")

# Verify agent integrity
self_check = jacs.verify_self()
if not self_check.valid:
    raise RuntimeError("Agent integrity check failed")

# Sign a transaction
transaction = {
    "type": "payment",
    "from": agent.agent_id,
    "to": "recipient-agent-uuid",
    "amount": 250.00,
    "currency": "USD",
    "memo": "Q1 Service Payment"
}

signed = jacs.sign_message(transaction)
print(f"Transaction signed: {signed.document_id}")

# Verify the transaction (simulating recipient)
verification = jacs.verify(signed.raw)

if verification.valid:
    doc = json.loads(signed.raw)
    print(f"Payment verified from: {verification.signer_id}")
    print(f"Amount: {doc['content']['amount']} {doc['content']['currency']}")
else:
    print(f"Verification failed: {', '.join(verification.errors)}")

# Sign a file
contract_signed = jacs.sign_file("./contract.pdf", embed=True)
print(f"Contract signed: {contract_signed.document_id}")

# Update agent metadata
agent_doc = json.loads(jacs.export_agent())
agent_doc["jacsAgentType"] = "ai"
if not agent_doc.get("jacsContacts") or len(agent_doc["jacsContacts"]) == 0:
    agent_doc["jacsContacts"] = [{"contactFirstName": "AI", "contactLastName": "Agent"}]
updated_agent = jacs.update_agent(agent_doc)
print("Agent metadata updated")

# Share public key
public_key = jacs.get_public_key()
print("Share this public key for verification:")
print(public_key)
</code></pre>
<hr />
<h2 id="mcp-integration-1"><a class="header" href="#mcp-integration-1">MCP Integration</a></h2>
<p>The simplified API works well with FastMCP tool implementations:</p>
<pre><code class="language-python">from fastmcp import FastMCP
import jacs.simple as jacs

mcp = FastMCP("My Server")

# Load agent once at startup
jacs.load("./jacs.config.json")

@mcp.tool()
def approve_request(request_id: str) -&gt; dict:
    """Approve a request with cryptographic signature."""
    signed = jacs.sign_message({
        "action": "approve",
        "request_id": request_id,
        "approved_by": jacs.get_agent_info().agent_id
    })
    return {"signed_approval": signed.raw}

@mcp.tool()
def verify_approval(signed_json: str) -&gt; dict:
    """Verify a signed approval."""
    result = jacs.verify(signed_json)
    return {
        "valid": result.valid,
        "signer": result.signer_id,
        "errors": result.errors
    }
</code></pre>
<hr />
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<pre><code class="language-python">import jacs.simple as jacs
from jacs.types import JacsError, AgentNotLoadedError

try:
    jacs.load("./missing-config.json")
except JacsError as e:
    print(f"Config not found: {e}")

try:
    # Will fail if no agent loaded
    jacs.sign_message({"data": "test"})
except AgentNotLoadedError as e:
    print(f"No agent: {e}")

try:
    jacs.sign_file("/nonexistent/file.pdf")
except JacsError as e:
    print(f"File not found: {e}")

# Verification doesn't throw - check result.valid
result = jacs.verify("invalid json")
if not result.valid:
    print(f"Verification errors: {result.errors}")
</code></pre>
<hr />
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="python/basic-usage.html">Basic Usage</a> - JacsAgent class usage</li>
<li><a href="python/api.html">API Reference</a> - Complete JacsAgent API</li>
<li><a href="python/mcp.html">MCP Integration</a> - Model Context Protocol</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h1>
<p>This chapter covers fundamental JACS operations in Python, including agent initialization, document creation, signing, and verification.</p>
<h2 id="initializing-an-agent-1"><a class="header" href="#initializing-an-agent-1">Initializing an Agent</a></h2>
<h3 id="create-and-load-agent-1"><a class="header" href="#create-and-load-agent-1">Create and Load Agent</a></h3>
<pre><code class="language-python">import jacs

# Create a new agent instance
agent = jacs.JacsAgent()

# Load configuration from file
agent.load('./jacs.config.json')
</code></pre>
<h3 id="configuration-file-4"><a class="header" href="#configuration-file-4">Configuration File</a></h3>
<p>Create <code>jacs.config.json</code>:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "agent-uuid:version-uuid"
}
</code></pre>
<h2 id="creating-documents-3"><a class="header" href="#creating-documents-3">Creating Documents</a></h2>
<h3 id="basic-document-creation-1"><a class="header" href="#basic-document-creation-1">Basic Document Creation</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create a document from JSON
document_data = {
    "title": "Project Proposal",
    "content": "Quarterly development plan",
    "budget": 50000
}

signed_document = agent.create_document(json.dumps(document_data))
print('Signed document:', signed_document)
</code></pre>
<h3 id="with-custom-schema-2"><a class="header" href="#with-custom-schema-2">With Custom Schema</a></h3>
<p>Validate against a custom JSON Schema:</p>
<pre><code class="language-python">signed_document = agent.create_document(
    json.dumps(document_data),
    './schemas/proposal.schema.json'  # custom schema path
)
</code></pre>
<h3 id="with-output-file-1"><a class="header" href="#with-output-file-1">With Output File</a></h3>
<pre><code class="language-python">signed_document = agent.create_document(
    json.dumps(document_data),
    None,                     # no custom schema
    './output/proposal.json'  # output filename
)
</code></pre>
<h3 id="without-saving-1"><a class="header" href="#without-saving-1">Without Saving</a></h3>
<pre><code class="language-python">signed_document = agent.create_document(
    json.dumps(document_data),
    None,   # no custom schema
    None,   # no output filename
    True    # no_save = True
)
</code></pre>
<h3 id="with-attachments-1"><a class="header" href="#with-attachments-1">With Attachments</a></h3>
<pre><code class="language-python">signed_document = agent.create_document(
    json.dumps(document_data),
    None,                        # no custom schema
    None,                        # no output filename
    False,                       # save the document
    './attachments/report.pdf',  # attachment path
    True                         # embed files
)
</code></pre>
<h2 id="verifying-documents-3"><a class="header" href="#verifying-documents-3">Verifying Documents</a></h2>
<h3 id="verify-document-signature-1"><a class="header" href="#verify-document-signature-1">Verify Document Signature</a></h3>
<pre><code class="language-python"># Verify a document's signature and hash
is_valid = agent.verify_document(signed_document_json)
print('Document valid:', is_valid)
</code></pre>
<h3 id="verify-specific-signature-field-1"><a class="header" href="#verify-specific-signature-field-1">Verify Specific Signature Field</a></h3>
<pre><code class="language-python"># Verify with a custom signature field
is_valid = agent.verify_signature(
    signed_document_json,
    'jacsSignature'  # signature field name
)
</code></pre>
<h2 id="updating-documents-3"><a class="header" href="#updating-documents-3">Updating Documents</a></h2>
<h3 id="update-existing-document-1"><a class="header" href="#update-existing-document-1">Update Existing Document</a></h3>
<pre><code class="language-python"># Original document key format: "id:version"
document_key = 'doc-uuid:version-uuid'

# Modified document content (must include jacsId and jacsVersion)
updated_data = {
    "jacsId": "doc-uuid",
    "jacsVersion": "version-uuid",
    "title": "Updated Proposal",
    "content": "Revised quarterly plan",
    "budget": 75000
}

updated_document = agent.update_document(
    document_key,
    json.dumps(updated_data)
)

print('Updated document:', updated_document)
</code></pre>
<h3 id="update-with-new-attachments-1"><a class="header" href="#update-with-new-attachments-1">Update with New Attachments</a></h3>
<pre><code class="language-python">updated_document = agent.update_document(
    document_key,
    json.dumps(updated_data),
    ['./new-report.pdf'],  # new attachments
    True                   # embed files
)
</code></pre>
<h2 id="signing-and-verification-2"><a class="header" href="#signing-and-verification-2">Signing and Verification</a></h2>
<h3 id="sign-arbitrary-data-1"><a class="header" href="#sign-arbitrary-data-1">Sign Arbitrary Data</a></h3>
<pre><code class="language-python"># Sign any string data
signature = agent.sign_string('Important message to sign')
print('Signature:', signature)
</code></pre>
<h3 id="verify-arbitrary-data-1"><a class="header" href="#verify-arbitrary-data-1">Verify Arbitrary Data</a></h3>
<pre><code class="language-python"># Verify a signature on string data
is_valid = agent.verify_string(
    'Important message to sign',  # original data
    signature_base64,             # base64 signature
    public_key_bytes,             # public key as bytes
    'ring-Ed25519'                # algorithm
)
</code></pre>
<h2 id="working-with-agreements-1"><a class="header" href="#working-with-agreements-1">Working with Agreements</a></h2>
<h3 id="create-an-agreement-1"><a class="header" href="#create-an-agreement-1">Create an Agreement</a></h3>
<pre><code class="language-python"># Add agreement requiring multiple agent signatures
document_with_agreement = agent.create_agreement(
    signed_document_json,
    ['agent1-uuid', 'agent2-uuid'],           # required signers
    'Do you agree to these terms?',            # question
    'Q1 2024 service contract',                # context
    'jacsAgreement'                            # field name
)
</code></pre>
<h3 id="sign-an-agreement-1"><a class="header" href="#sign-an-agreement-1">Sign an Agreement</a></h3>
<pre><code class="language-python"># Sign the agreement as the current agent
signed_agreement = agent.sign_agreement(
    document_with_agreement_json,
    'jacsAgreement'  # agreement field name
)
</code></pre>
<h3 id="check-agreement-status-1"><a class="header" href="#check-agreement-status-1">Check Agreement Status</a></h3>
<pre><code class="language-python"># Check which agents have signed
status = agent.check_agreement(
    document_with_agreement_json,
    'jacsAgreement'
)

print('Agreement status:', json.loads(status))
</code></pre>
<h2 id="agent-operations-1"><a class="header" href="#agent-operations-1">Agent Operations</a></h2>
<h3 id="verify-agent-2"><a class="header" href="#verify-agent-2">Verify Agent</a></h3>
<pre><code class="language-python"># Verify the loaded agent's signature
is_valid = agent.verify_agent()
print('Agent valid:', is_valid)

# Verify a specific agent file
is_valid_other = agent.verify_agent('./other-agent.json')
</code></pre>
<h3 id="update-agent-1"><a class="header" href="#update-agent-1">Update Agent</a></h3>
<pre><code class="language-python"># Update agent document
updated_agent_json = agent.update_agent(json.dumps({
    "jacsId": "agent-uuid",
    "jacsVersion": "version-uuid",
    "name": "Updated Agent Name",
    "description": "Updated description"
}))
</code></pre>
<h3 id="sign-external-agent-1"><a class="header" href="#sign-external-agent-1">Sign External Agent</a></h3>
<pre><code class="language-python"># Sign another agent's document with registration signature
signed_agent_json = agent.sign_agent(
    external_agent_json,
    public_key_bytes,
    'ring-Ed25519'
)
</code></pre>
<h2 id="requestresponse-signing-1"><a class="header" href="#requestresponse-signing-1">Request/Response Signing</a></h2>
<h3 id="sign-a-request-1"><a class="header" href="#sign-a-request-1">Sign a Request</a></h3>
<pre><code class="language-python"># Sign request parameters as a JACS document
signed_request = agent.sign_request({
    "method": "GET",
    "path": "/api/resource",
    "timestamp": datetime.now().isoformat(),
    "body": {"query": "data"}
})
</code></pre>
<h3 id="verify-a-response-1"><a class="header" href="#verify-a-response-1">Verify a Response</a></h3>
<pre><code class="language-python"># Verify a signed response
result = agent.verify_response(signed_response_json)
print('Response valid:', result)

# Verify and get signer's agent ID
result_with_id = agent.verify_response_with_agent_id(signed_response_json)
print('Signer ID:', result_with_id)
</code></pre>
<h2 id="utility-functions-2"><a class="header" href="#utility-functions-2">Utility Functions</a></h2>
<h3 id="hash-string-1"><a class="header" href="#hash-string-1">Hash String</a></h3>
<pre><code class="language-python">import jacs

# SHA-256 hash of a string
hash_value = jacs.hash_string('data to hash')
print('Hash:', hash_value)
</code></pre>
<h3 id="create-configuration-2"><a class="header" href="#create-configuration-2">Create Configuration</a></h3>
<pre><code class="language-python">import jacs

# Programmatically create a config JSON string
config_json = jacs.create_config(
    jacs_data_directory='./jacs_data',
    jacs_key_directory='./jacs_keys',
    jacs_agent_key_algorithm='ring-Ed25519',
    jacs_default_storage='fs'
)

print('Config:', config_json)
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<pre><code class="language-python">import jacs

agent = jacs.JacsAgent()

try:
    agent.load('./jacs.config.json')
except Exception as error:
    print(f'Failed to load agent: {error}')

try:
    doc = agent.create_document(json.dumps({'data': 'test'}))
    print('Document created')
except Exception as error:
    print(f'Failed to create document: {error}')

try:
    is_valid = agent.verify_document(invalid_json)
except Exception as error:
    print(f'Verification failed: {error}')
</code></pre>
<h2 id="complete-example-6"><a class="header" href="#complete-example-6">Complete Example</a></h2>
<pre><code class="language-python">import jacs
import json

def main():
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Create a task document
    task = {
        "title": "Code Review",
        "description": "Review pull request #123",
        "assignee": "developer-uuid",
        "deadline": "2024-02-01"
    }

    signed_task = agent.create_document(json.dumps(task))
    print('Task created')

    # Verify the task
    if agent.verify_document(signed_task):
        print('Task signature valid')

    # Create agreement for task acceptance
    task_with_agreement = agent.create_agreement(
        signed_task,
        ['manager-uuid', 'developer-uuid'],
        'Do you accept this task assignment?'
    )

    # Sign the agreement
    signed_agreement = agent.sign_agreement(task_with_agreement)
    print('Agreement signed')

    # Check agreement status
    status = agent.check_agreement(signed_agreement)
    print('Status:', status)

    # Hash some data for reference
    task_hash = jacs.hash_string(signed_task)
    print('Task hash:', task_hash)

if __name__ == "__main__":
    main()
</code></pre>
<h2 id="working-with-document-data"><a class="header" href="#working-with-document-data">Working with Document Data</a></h2>
<h3 id="parse-signed-documents"><a class="header" href="#parse-signed-documents">Parse Signed Documents</a></h3>
<pre><code class="language-python">import json

# Create and sign a document
doc_data = {"title": "My Document", "content": "Hello, World!"}
signed_doc = agent.create_document(json.dumps(doc_data))

# Parse the signed document to access JACS fields
parsed = json.loads(signed_doc)
print('Document ID:', parsed.get('jacsId'))
print('Document Version:', parsed.get('jacsVersion'))
print('Signature:', parsed.get('jacsSignature'))
</code></pre>
<h3 id="document-key-format"><a class="header" href="#document-key-format">Document Key Format</a></h3>
<pre><code class="language-python"># Document keys combine ID and version
doc_id = parsed['jacsId']
doc_version = parsed['jacsVersion']
document_key = f"{doc_id}:{doc_version}"

# Use the key for updates
updated_doc = agent.update_document(document_key, json.dumps({
    **parsed,
    "content": "Updated content"
}))
</code></pre>
<h2 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h2>
<h3 id="load-from-file"><a class="header" href="#load-from-file">Load from File</a></h3>
<pre><code class="language-python">import jacs

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<h3 id="environment-variables-5"><a class="header" href="#environment-variables-5">Environment Variables</a></h3>
<p>JACS reads environment variables that override configuration file settings:</p>
<pre><code class="language-bash">export JACS_DATA_DIRECTORY="./production_data"
export JACS_KEY_DIRECTORY="./production_keys"
export JACS_AGENT_KEY_ALGORITHM="ring-Ed25519"
export JACS_DEFAULT_STORAGE="fs"
</code></pre>
<h3 id="programmatic-configuration-1"><a class="header" href="#programmatic-configuration-1">Programmatic Configuration</a></h3>
<pre><code class="language-python">import jacs
import json
import os

# Create config programmatically
config_json = jacs.create_config(
    jacs_data_directory='./jacs_data',
    jacs_key_directory='./jacs_keys',
    jacs_agent_key_algorithm='ring-Ed25519',
    jacs_default_storage='fs'
)

# Write to file
with open('jacs.config.json', 'w') as f:
    f.write(config_json)

# Then load it
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li><a href="python/mcp.html">MCP Integration</a> - Model Context Protocol support</li>
<li><a href="python/mcp.html">FastMCP Integration</a> - Build advanced MCP servers</li>
<li><a href="python/api.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcp-integration-2"><a class="header" href="#mcp-integration-2">MCP Integration</a></h1>
<p>JACS provides seamless integration with the Model Context Protocol (MCP), enabling cryptographically signed and verified communication between AI agents and MCP servers. This integration ensures that all tool calls, resource requests, and prompt interactions are authenticated and tamper-proof.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>JACS MCP integration provides:</p>
<ul>
<li><strong>Cryptographic Authentication</strong>: All MCP messages are signed and verified</li>
<li><strong>FastMCP Support</strong>: Native integration with FastMCP servers</li>
<li><strong>HTTP &amp; SSE Transports</strong>: Support for Server-Sent Events transport</li>
<li><strong>Transparent Security</strong>: Existing MCP code works with minimal changes</li>
</ul>
<h2 id="quick-start-7"><a class="header" href="#quick-start-7">Quick Start</a></h2>
<h3 id="basic-mcp-server-with-jacs-1"><a class="header" href="#basic-mcp-server-with-jacs-1">Basic MCP Server with JACS</a></h3>
<pre><code class="language-python">import jacs
import os
from pathlib import Path
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import uvicorn

# Setup JACS configuration
current_dir = Path(__file__).parent.absolute()
jacs_config_path = current_dir / "jacs.config.json"

# Initialize JACS agent
agent = jacs.JacsAgent()
agent.load(str(jacs_config_path))

# Create FastMCP server with JACS authentication
mcp = JACSMCPServer(FastMCP("Authenticated Echo Server"))

@mcp.tool()
def echo_tool(text: str) -&gt; str:
    """Echo the input text with server prefix"""
    return f"SERVER SAYS: {text}"

@mcp.resource("echo://static")
def echo_resource() -&gt; str:
    return "Echo!"

@mcp.prompt("echo")
def echo_prompt(text: str) -&gt; str:
    return f"Echo prompt: {text}"

# Get the ASGI app with JACS middleware
sse_app_with_middleware = mcp.sse_app()

if __name__ == "__main__":
    print("Starting JACS-enabled MCP server...")
    uvicorn.run(sse_app_with_middleware, host="localhost", port=8000)
</code></pre>
<h3 id="basic-mcp-client-with-jacs"><a class="header" href="#basic-mcp-client-with-jacs">Basic MCP Client with JACS</a></h3>
<pre><code class="language-python">import asyncio
import os
from pathlib import Path
import jacs
from jacs.mcp import JACSMCPClient

# Setup JACS configuration
current_dir = Path(__file__).parent.absolute()
jacs_config_path = current_dir / "jacs.client.config.json"

# Initialize JACS agent
agent = jacs.JacsAgent()
agent.load(str(jacs_config_path))

async def main():
    server_url = "http://localhost:8000/sse"

    try:
        client = JACSMCPClient(server_url)

        async with client:
            # Call authenticated tool
            result = await client.call_tool("echo_tool", {
                "text": "Hello from authenticated client!"
            })
            print(f"Tool result: {result}")

            # Read authenticated resource
            resource = await client.read_resource("echo://static")
            print(f"Resource: {resource}")

    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<h3 id="jacsmcpserver"><a class="header" href="#jacsmcpserver">JACSMCPServer</a></h3>
<p>The <code>JACSMCPServer</code> wrapper adds JACS middleware to a FastMCP server:</p>
<ol>
<li><strong>Incoming Requests</strong>: Intercepts JSON-RPC requests and verifies them using <code>jacs.verify_request()</code></li>
<li><strong>Outgoing Responses</strong>: Signs JSON-RPC responses using <code>jacs.sign_response()</code></li>
</ol>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP

# Create FastMCP server
base_server = FastMCP("My Server")

# Wrap with JACS authentication
authenticated_server = JACSMCPServer(base_server)

# All decorators work normally
@authenticated_server.tool()
def my_tool(data: str) -&gt; str:
    return f"Processed: {data}"

# Get ASGI app with JACS middleware
app = authenticated_server.sse_app()
</code></pre>
<h3 id="jacsmcpclient"><a class="header" href="#jacsmcpclient">JACSMCPClient</a></h3>
<p>The <code>JACSMCPClient</code> wrapper adds interceptors to a FastMCP client:</p>
<ol>
<li><strong>Outgoing Messages</strong>: Signs messages using <code>jacs.sign_request()</code></li>
<li><strong>Incoming Messages</strong>: Verifies messages using <code>jacs.verify_response()</code></li>
</ol>
<pre><code class="language-python">from jacs.mcp import JACSMCPClient

client = JACSMCPClient("http://localhost:8000/sse")

async with client:
    result = await client.call_tool("my_tool", {"data": "test"})
</code></pre>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<h3 id="jacs-configuration-file"><a class="header" href="#jacs-configuration-file">JACS Configuration File</a></h3>
<p>Create a <code>jacs.config.json</code> file for your server and client:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_agent_id_and_version": "your-agent-id:version",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_private_key_filename": "private.pem",
  "jacs_agent_public_key_filename": "public.pem",
  "jacs_data_directory": "./jacs_data",
  "jacs_default_storage": "fs",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<h3 id="initializing-the-agent"><a class="header" href="#initializing-the-agent">Initializing the Agent</a></h3>
<p>Before using MCP integration, initialize your JACS agent:</p>
<pre><code class="language-python">import jacs

# Create and load agent
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

# Agent is now ready for MCP operations
</code></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="fastmcp-with-jacs-middleware"><a class="header" href="#fastmcp-with-jacs-middleware">FastMCP with JACS Middleware</a></h3>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import jacs

# Initialize JACS
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

# Create and wrap server
server = FastMCP("My Server")
authenticated_server = JACSMCPServer(server)

@authenticated_server.tool()
def secure_tool(input_data: str) -&gt; str:
    """A tool that processes signed input"""
    return f"Securely processed: {input_data}"

# Run server
if __name__ == "__main__":
    import uvicorn
    app = authenticated_server.sse_app()
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h3 id="manual-requestresponse-signing"><a class="header" href="#manual-requestresponse-signing">Manual Request/Response Signing</a></h3>
<p>For custom integrations, you can use the module-level functions directly:</p>
<pre><code class="language-python">import jacs

# Initialize agent first
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

# Sign a request
signed_request = jacs.sign_request({
    "method": "tools/call",
    "params": {"name": "my_tool", "arguments": {"data": "test"}}
})

# Verify a response
verified_response = jacs.verify_response(signed_response_string)
payload = verified_response.get("payload")
</code></pre>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<pre><code class="language-python">import jacs
from jacs.mcp import JACSMCPClient

async def robust_mcp_client():
    try:
        agent = jacs.JacsAgent()
        agent.load("./jacs.config.json")

        client = JACSMCPClient("http://localhost:8000/sse")
        async with client:
            result = await client.call_tool("my_tool", {"data": "test"})
            return result

    except FileNotFoundError as e:
        print(f"Configuration file not found: {e}")

    except ConnectionError as e:
        print(f"MCP connection failed: {e}")

    except Exception as e:
        print(f"Unexpected error: {e}")
</code></pre>
<h3 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h3>
<p>Enable logging to debug authentication issues:</p>
<pre><code class="language-python">import logging

# Enable detailed logging
logging.basicConfig(level=logging.DEBUG)

# Your MCP code here...
</code></pre>
<h2 id="production-deployment"><a class="header" href="#production-deployment">Production Deployment</a></h2>
<h3 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h3>
<ol>
<li><strong>Key Management</strong>: Store private keys securely</li>
<li><strong>Environment Variables</strong>: Use environment variables for sensitive paths</li>
<li><strong>Network Security</strong>: Use TLS for network transport</li>
<li><strong>Key Rotation</strong>: Implement key rotation policies</li>
</ol>
<pre><code class="language-python">import os
import jacs

# Production initialization
config_path = os.getenv("JACS_CONFIG_PATH", "/etc/jacs/config.json")

agent = jacs.JacsAgent()
agent.load(config_path)
</code></pre>
<h3 id="docker-deployment"><a class="header" href="#docker-deployment">Docker Deployment</a></h3>
<pre><code class="language-dockerfile">FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy application
COPY . .

# Create secure key directory
RUN mkdir -p /secure/keys &amp;&amp; chmod 700 /secure/keys

# Set environment variables
ENV JACS_CONFIG_PATH=/app/jacs.config.json

# Run MCP server
CMD ["python", "mcp_server.py"]
</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<h3 id="unit-testing-mcp-tools"><a class="header" href="#unit-testing-mcp-tools">Unit Testing MCP Tools</a></h3>
<pre><code class="language-python">import pytest
import jacs
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport

@pytest.fixture
def jacs_agent():
    agent = jacs.JacsAgent()
    agent.load("./test.config.json")
    return agent

@pytest.fixture
def jacs_mcp_server(jacs_agent):
    server = FastMCP("Test Server")
    return JACSMCPServer(server)

async def test_authenticated_tool(jacs_mcp_server):
    @jacs_mcp_server.tool()
    def echo(text: str) -&gt; str:
        return f"Echo: {text}"

    # Test the tool directly
    result = echo("test")
    assert "test" in result
</code></pre>
<h2 id="api-reference-5"><a class="header" href="#api-reference-5">API Reference</a></h2>
<h3 id="jacsmcpservermcp_server"><a class="header" href="#jacsmcpservermcp_server">JACSMCPServer(mcp_server)</a></h3>
<p>Wraps a FastMCP server with JACS authentication middleware.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>mcp_server</code>: A FastMCP server instance</li>
</ul>
<p><strong>Returns:</strong> The wrapped server with JACS middleware</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP

server = FastMCP("My Server")
authenticated = JACSMCPServer(server)
app = authenticated.sse_app()
</code></pre>
<h3 id="jacsmcpclienturl-kwargs"><a class="header" href="#jacsmcpclienturl-kwargs">JACSMCPClient(url, **kwargs)</a></h3>
<p>Creates a FastMCP client with JACS authentication interceptors.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>url</code>: The MCP server SSE endpoint URL</li>
<li><code>**kwargs</code>: Additional arguments passed to the FastMCP Client</li>
</ul>
<p><strong>Returns:</strong> A FastMCP Client with JACS interceptors</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">from jacs.mcp import JACSMCPClient

client = JACSMCPClient("http://localhost:8000/sse")
async with client:
    result = await client.call_tool("my_tool", {"arg": "value"})
</code></pre>
<h3 id="module-functions"><a class="header" href="#module-functions">Module Functions</a></h3>
<p>These functions are used internally by the MCP integration:</p>
<ul>
<li><code>jacs.sign_request(data)</code> - Sign a request payload</li>
<li><code>jacs.verify_request(data)</code> - Verify an incoming request</li>
<li><code>jacs.sign_response(data)</code> - Sign a response payload</li>
<li><code>jacs.verify_response(data)</code> - Verify an incoming response</li>
</ul>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li><strong><a href="python/mcp.html">FastMCP Integration</a></strong> - Advanced FastMCP patterns</li>
<li><strong><a href="python/api.html">API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="python/../examples/python.html">Examples</a></strong> - More complex examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-6"><a class="header" href="#api-reference-6">API Reference</a></h1>
<p>Complete API documentation for the <code>jacs</code> Python package.</p>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<pre><code class="language-bash">pip install jacs
</code></pre>
<h2 id="core-module-2"><a class="header" href="#core-module-2">Core Module</a></h2>
<pre><code class="language-python">import jacs
from jacs import JacsAgent
</code></pre>
<hr />
<h2 id="jacsagent-class-1"><a class="header" href="#jacsagent-class-1">JacsAgent Class</a></h2>
<p>The <code>JacsAgent</code> class is the primary interface for JACS operations. Each instance maintains its own state and can be used independently, allowing multiple agents in the same process.</p>
<h3 id="constructor-1"><a class="header" href="#constructor-1">Constructor</a></h3>
<pre><code class="language-python">JacsAgent()
</code></pre>
<p>Creates a new empty JacsAgent instance. Call <code>load()</code> to initialize with a configuration.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<hr />
<h3 id="agentloadconfig_path"><a class="header" href="#agentloadconfig_path">agent.load(config_path)</a></h3>
<p>Load and initialize the agent from a configuration file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>config_path</code> (str): Path to the JACS configuration file</li>
</ul>
<p><strong>Returns:</strong> str - The loaded agent's JSON</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">agent = jacs.JacsAgent()
agent_json = agent.load('./jacs.config.json')
print('Agent loaded:', json.loads(agent_json)['jacsId'])
</code></pre>
<hr />
<h3 id="agentcreate_documentdocument_string-custom_schemanone-output_filenamenone-no_savefalse-attachmentsnone-embedfalse"><a class="header" href="#agentcreate_documentdocument_string-custom_schemanone-output_filenamenone-no_savefalse-attachmentsnone-embedfalse">agent.create_document(document_string, custom_schema=None, output_filename=None, no_save=False, attachments=None, embed=False)</a></h3>
<p>Create and sign a new JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): JSON string of the document content</li>
<li><code>custom_schema</code> (str, optional): Path to a custom JSON Schema for validation</li>
<li><code>output_filename</code> (str, optional): Filename to save the document</li>
<li><code>no_save</code> (bool, optional): If True, don't save to storage (default: False)</li>
<li><code>attachments</code> (str, optional): Path to file attachments</li>
<li><code>embed</code> (bool, optional): If True, embed attachments in the document</li>
</ul>
<p><strong>Returns:</strong> str - The signed document as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python"># Basic document creation
doc = agent.create_document(json.dumps({
    'title': 'My Document',
    'content': 'Hello, World!'
}))

# With custom schema
validated_doc = agent.create_document(
    json.dumps({'title': 'Validated', 'amount': 100}),
    custom_schema='./schemas/invoice.schema.json'
)

# Without saving
temp_doc = agent.create_document(
    json.dumps({'data': 'temporary'}),
    no_save=True
)

# With attachments
doc_with_file = agent.create_document(
    json.dumps({'report': 'Monthly Report'}),
    attachments='./report.pdf',
    embed=True
)
</code></pre>
<hr />
<h3 id="agentverify_documentdocument_string"><a class="header" href="#agentverify_documentdocument_string">agent.verify_document(document_string)</a></h3>
<p>Verify a document's signature and hash integrity.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The signed document JSON string</li>
</ul>
<p><strong>Returns:</strong> bool - True if the document is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">is_valid = agent.verify_document(signed_document_json)
if is_valid:
    print('Document signature verified')
else:
    print('Document verification failed')
</code></pre>
<hr />
<h3 id="agentverify_signaturedocument_string-signature_fieldnone"><a class="header" href="#agentverify_signaturedocument_string-signature_fieldnone">agent.verify_signature(document_string, signature_field=None)</a></h3>
<p>Verify a document's signature with an optional custom signature field.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The signed document JSON string</li>
<li><code>signature_field</code> (str, optional): Name of the signature field (default: 'jacsSignature')</li>
</ul>
<p><strong>Returns:</strong> bool - True if the signature is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python"># Verify default signature field
is_valid = agent.verify_signature(doc_json)

# Verify custom signature field
is_valid_custom = agent.verify_signature(doc_json, 'customSignature')
</code></pre>
<hr />
<h3 id="agentupdate_documentdocument_key-new_document_string-attachmentsnone-embedfalse"><a class="header" href="#agentupdate_documentdocument_key-new_document_string-attachmentsnone-embedfalse">agent.update_document(document_key, new_document_string, attachments=None, embed=False)</a></h3>
<p>Update an existing document, creating a new version.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_key</code> (str): The document key in format <code>"id:version"</code></li>
<li><code>new_document_string</code> (str): The modified document as JSON string</li>
<li><code>attachments</code> (list, optional): List of attachment file paths</li>
<li><code>embed</code> (bool, optional): If True, embed attachments</li>
</ul>
<p><strong>Returns:</strong> str - The updated document as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python"># Parse existing document to get key
doc = json.loads(signed_doc)
document_key = f"{doc['jacsId']}:{doc['jacsVersion']}"

# Update the document
updated_doc = agent.update_document(
    document_key,
    json.dumps({
        **doc,
        'title': 'Updated Title',
        'content': 'Modified content'
    })
)
</code></pre>
<hr />
<h3 id="agentcreate_agreementdocument_string-agent_ids-questionnone-contextnone-agreement_field_namenone"><a class="header" href="#agentcreate_agreementdocument_string-agent_ids-questionnone-contextnone-agreement_field_namenone">agent.create_agreement(document_string, agent_ids, question=None, context=None, agreement_field_name=None)</a></h3>
<p>Add an agreement requiring multiple agent signatures to a document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The document JSON string</li>
<li><code>agent_ids</code> (list): List of agent IDs required to sign</li>
<li><code>question</code> (str, optional): The agreement question</li>
<li><code>context</code> (str, optional): Additional context for the agreement</li>
<li><code>agreement_field_name</code> (str, optional): Field name for the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> str - The document with agreement as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">doc_with_agreement = agent.create_agreement(
    signed_document_json,
    ['agent-1-uuid', 'agent-2-uuid', 'agent-3-uuid'],
    question='Do you agree to these terms?',
    context='Q1 2024 Service Agreement',
    agreement_field_name='jacsAgreement'
)
</code></pre>
<hr />
<h3 id="agentsign_agreementdocument_string-agreement_field_namenone"><a class="header" href="#agentsign_agreementdocument_string-agreement_field_namenone">agent.sign_agreement(document_string, agreement_field_name=None)</a></h3>
<p>Sign an agreement as the current agent.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The document with agreement JSON string</li>
<li><code>agreement_field_name</code> (str, optional): Field name of the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> str - The document with this agent's signature added</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">signed_agreement = agent.sign_agreement(
    doc_with_agreement_json,
    'jacsAgreement'
)
</code></pre>
<hr />
<h3 id="agentcheck_agreementdocument_string-agreement_field_namenone"><a class="header" href="#agentcheck_agreementdocument_string-agreement_field_namenone">agent.check_agreement(document_string, agreement_field_name=None)</a></h3>
<p>Check the status of an agreement (which agents have signed).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The document with agreement JSON string</li>
<li><code>agreement_field_name</code> (str, optional): Field name of the agreement (default: 'jacsAgreement')</li>
</ul>
<p><strong>Returns:</strong> str - JSON string with agreement status</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">status_json = agent.check_agreement(signed_agreement_json)
status = json.loads(status_json)

print('Required signers:', status['required'])
print('Signatures received:', status['signed'])
print('Complete:', status['complete'])
</code></pre>
<hr />
<h3 id="agentsign_stringdata"><a class="header" href="#agentsign_stringdata">agent.sign_string(data)</a></h3>
<p>Sign arbitrary string data with the agent's private key.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (str): The data to sign</li>
</ul>
<p><strong>Returns:</strong> str - Base64-encoded signature</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">signature = agent.sign_string('Important message')
print('Signature:', signature)
</code></pre>
<hr />
<h3 id="agentverify_stringdata-signature_base64-public_key-public_key_enc_type"><a class="header" href="#agentverify_stringdata-signature_base64-public_key-public_key_enc_type">agent.verify_string(data, signature_base64, public_key, public_key_enc_type)</a></h3>
<p>Verify a signature on arbitrary string data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> (str): The original data</li>
<li><code>signature_base64</code> (str): The base64-encoded signature</li>
<li><code>public_key</code> (bytes): The public key as bytes</li>
<li><code>public_key_enc_type</code> (str): The key algorithm (e.g., 'ring-Ed25519')</li>
</ul>
<p><strong>Returns:</strong> bool - True if the signature is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">is_valid = agent.verify_string(
    'Important message',
    signature_base64,
    public_key_bytes,
    'ring-Ed25519'
)
</code></pre>
<hr />
<h3 id="agentsign_requestparams"><a class="header" href="#agentsign_requestparams">agent.sign_request(params)</a></h3>
<p>Sign a request payload, wrapping it in a JACS document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>params</code> (any): The request payload (will be JSON serialized)</li>
</ul>
<p><strong>Returns:</strong> str - JACS-signed request as a JSON string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">signed_request = agent.sign_request({
    'method': 'GET',
    'path': '/api/data',
    'timestamp': datetime.now().isoformat(),
    'body': {'query': 'value'}
})
</code></pre>
<hr />
<h3 id="agentverify_responsedocument_string"><a class="header" href="#agentverify_responsedocument_string">agent.verify_response(document_string)</a></h3>
<p>Verify a JACS-signed response and extract the payload.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The JACS-signed response</li>
</ul>
<p><strong>Returns:</strong> dict - Dictionary containing the verified payload</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">result = agent.verify_response(jacs_response_string)
payload = result.get('payload')
print('Verified payload:', payload)
</code></pre>
<hr />
<h3 id="agentverify_response_with_agent_iddocument_string"><a class="header" href="#agentverify_response_with_agent_iddocument_string">agent.verify_response_with_agent_id(document_string)</a></h3>
<p>Verify a response and return both the payload and signer's agent ID.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>document_string</code> (str): The JACS-signed response</li>
</ul>
<p><strong>Returns:</strong> dict - Dictionary with payload and agent ID</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">result = agent.verify_response_with_agent_id(jacs_response_string)
print('Payload:', result['payload'])
print('Signed by agent:', result['agentId'])
</code></pre>
<hr />
<h3 id="agentverify_agentagent_filenone"><a class="header" href="#agentverify_agentagent_filenone">agent.verify_agent(agent_file=None)</a></h3>
<p>Verify the agent's own signature and hash, or verify another agent file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>agent_file</code> (str, optional): Path to an agent file to verify</li>
</ul>
<p><strong>Returns:</strong> bool - True if the agent is valid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python"># Verify the loaded agent
is_valid = agent.verify_agent()

# Verify another agent file
is_other_valid = agent.verify_agent('./other-agent.json')
</code></pre>
<hr />
<h3 id="agentupdate_agentnew_agent_string"><a class="header" href="#agentupdate_agentnew_agent_string">agent.update_agent(new_agent_string)</a></h3>
<p>Update the agent document with new data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>new_agent_string</code> (str): The modified agent document as JSON string</li>
</ul>
<p><strong>Returns:</strong> str - The updated agent document</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">current_agent = json.loads(agent.load('./jacs.config.json'))
updated_agent = agent.update_agent(json.dumps({
    **current_agent,
    'description': 'Updated description'
}))
</code></pre>
<hr />
<h3 id="agentsign_agentagent_string-public_key-public_key_enc_type"><a class="header" href="#agentsign_agentagent_string-public_key-public_key_enc_type">agent.sign_agent(agent_string, public_key, public_key_enc_type)</a></h3>
<p>Sign another agent's document with a registration signature.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>agent_string</code> (str): The agent document to sign</li>
<li><code>public_key</code> (bytes): The public key as bytes</li>
<li><code>public_key_enc_type</code> (str): The key algorithm</li>
</ul>
<p><strong>Returns:</strong> str - The signed agent document</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">signed_agent = agent.sign_agent(
    external_agent_json,
    public_key_bytes,
    'ring-Ed25519'
)
</code></pre>
<hr />
<h2 id="module-level-functions"><a class="header" href="#module-level-functions">Module-Level Functions</a></h2>
<p>These functions operate on a global agent singleton and are maintained for backwards compatibility. <strong>New code should use the <code>JacsAgent</code> class instead.</strong></p>
<h3 id="jacsloadconfig_path"><a class="header" href="#jacsloadconfig_path">jacs.load(config_path)</a></h3>
<p>Load the global agent from a configuration file.</p>
<pre><code class="language-python">import jacs
jacs.load('./jacs.config.json')
</code></pre>
<h3 id="jacssign_requestdata"><a class="header" href="#jacssign_requestdata">jacs.sign_request(data)</a></h3>
<p>Sign a request using the global agent.</p>
<pre><code class="language-python">signed = jacs.sign_request({'method': 'tools/call', 'params': {...}})
</code></pre>
<h3 id="jacsverify_requestdata"><a class="header" href="#jacsverify_requestdata">jacs.verify_request(data)</a></h3>
<p>Verify an incoming request using the global agent.</p>
<pre><code class="language-python">payload = jacs.verify_request(incoming_request_string)
</code></pre>
<h3 id="jacssign_responsedata"><a class="header" href="#jacssign_responsedata">jacs.sign_response(data)</a></h3>
<p>Sign a response using the global agent.</p>
<pre><code class="language-python">signed = jacs.sign_response({'result': 'success'})
</code></pre>
<h3 id="jacsverify_responsedata"><a class="header" href="#jacsverify_responsedata">jacs.verify_response(data)</a></h3>
<p>Verify an incoming response using the global agent.</p>
<pre><code class="language-python">result = jacs.verify_response(response_string)
payload = result.get('payload')
</code></pre>
<hr />
<h2 id="mcp-module-1"><a class="header" href="#mcp-module-1">MCP Module</a></h2>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer, JACSMCPClient
</code></pre>
<h3 id="jacsmcpservermcp_server-1"><a class="header" href="#jacsmcpservermcp_server-1">JACSMCPServer(mcp_server)</a></h3>
<p>Wraps a FastMCP server with JACS authentication middleware.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>mcp_server</code>: A FastMCP server instance</li>
</ul>
<p><strong>Returns:</strong> The wrapped server with JACS middleware</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP

server = FastMCP("My Server")
authenticated = JACSMCPServer(server)
app = authenticated.sse_app()
</code></pre>
<h3 id="jacsmcpclienturl-kwargs-1"><a class="header" href="#jacsmcpclienturl-kwargs-1">JACSMCPClient(url, **kwargs)</a></h3>
<p>Creates a FastMCP client with JACS authentication interceptors.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>url</code>: The MCP server SSE endpoint URL</li>
<li><code>**kwargs</code>: Additional arguments passed to the FastMCP Client</li>
</ul>
<p><strong>Returns:</strong> A FastMCP Client with JACS interceptors</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">from jacs.mcp import JACSMCPClient

client = JACSMCPClient("http://localhost:8000/sse")
async with client:
    result = await client.call_tool("my_tool", {"arg": "value"})
</code></pre>
<hr />
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<h3 id="configuration-file-format"><a class="header" href="#configuration-file-format">Configuration File Format</a></h3>
<p>Create a <code>jacs.config.json</code> file:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_agent_id_and_version": "your-agent-id:version",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_private_key_filename": "private.pem",
  "jacs_agent_public_key_filename": "public.pem",
  "jacs_data_directory": "./jacs_data",
  "jacs_default_storage": "fs",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs_agent_id_and_version</code></td><td>string</td><td>Agent ID and version in format <code>"id:version"</code></td></tr>
<tr><td><code>jacs_agent_key_algorithm</code></td><td>string</td><td>Signing algorithm: <code>"ring-Ed25519"</code>, <code>"RSA-PSS"</code>, <code>"pq-dilithium"</code>, <code>"pq2025"</code></td></tr>
<tr><td><code>jacs_agent_private_key_filename</code></td><td>string</td><td>Private key filename</td></tr>
<tr><td><code>jacs_agent_public_key_filename</code></td><td>string</td><td>Public key filename</td></tr>
<tr><td><code>jacs_data_directory</code></td><td>string</td><td>Directory for data storage</td></tr>
<tr><td><code>jacs_key_directory</code></td><td>string</td><td>Directory for key storage</td></tr>
<tr><td><code>jacs_default_storage</code></td><td>string</td><td>Storage backend: <code>"fs"</code>, <code>"s3"</code>, <code>"memory"</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h2>
<p>All methods may raise exceptions. Use try/except for error handling:</p>
<pre><code class="language-python">try:
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')
    doc = agent.create_document(json.dumps({'data': 'test'}))
except FileNotFoundError as e:
    print(f'Configuration file not found: {e}')
except ValueError as e:
    print(f'Invalid configuration: {e}')
except Exception as e:
    print(f'JACS error: {e}')
</code></pre>
<h3 id="common-exceptions"><a class="header" href="#common-exceptions">Common Exceptions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Exception</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FileNotFoundError</code></td><td>Configuration file or key file not found</td></tr>
<tr><td><code>ValueError</code></td><td>Invalid configuration or document format</td></tr>
<tr><td><code>RuntimeError</code></td><td>Agent not loaded or cryptographic operation failed</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="type-hints"><a class="header" href="#type-hints">Type Hints</a></h2>
<p>The package supports type hints for better IDE integration:</p>
<pre><code class="language-python">from jacs import JacsAgent
import json

def process_document(agent: JacsAgent, data: dict) -&gt; str:
    """Create and return a signed document."""
    doc_string = json.dumps(data)
    return agent.create_document(doc_string)

def verify_and_extract(agent: JacsAgent, doc: str) -&gt; dict:
    """Verify document and extract content."""
    if agent.verify_document(doc):
        return json.loads(doc)
    raise ValueError("Document verification failed")
</code></pre>
<hr />
<h2 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h2>
<p><code>JacsAgent</code> instances use internal locking and are thread-safe. You can safely use the same agent instance across multiple threads:</p>
<pre><code class="language-python">import threading
from jacs import JacsAgent

agent = JacsAgent()
agent.load('./jacs.config.json')

def worker(data):
    # Safe to call from multiple threads
    doc = agent.create_document(json.dumps(data))
    return doc

threads = [
    threading.Thread(target=worker, args=({'id': i},))
    for i in range(10)
]
for t in threads:
    t.start()
for t in threads:
    t.join()
</code></pre>
<hr />
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="python/installation.html">Installation</a> - Getting started</li>
<li><a href="python/basic-usage.html">Basic Usage</a> - Common usage patterns</li>
<li><a href="python/mcp.html">MCP Integration</a> - Model Context Protocol</li>
<li><a href="python/../examples/python.html">Examples</a> - More complex examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schemas"><a class="header" href="#json-schemas">JSON Schemas</a></h1>
<p>JACS uses JSON Schema (Draft-07) to define the structure and validation rules for all documents in the system. These schemas ensure consistency, enable validation, and provide a contract for interoperability between agents.</p>
<h2 id="schema-architecture"><a class="header" href="#schema-architecture">Schema Architecture</a></h2>
<p>JACS schemas follow a hierarchical composition pattern:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Document Schemas                      ‚îÇ
‚îÇ  (agent.schema.json, task.schema.json, message.schema.json)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Header Schema                          ‚îÇ
‚îÇ              (header.schema.json)                        ‚îÇ
‚îÇ  Base fields: jacsId, jacsVersion, jacsSignature, etc.  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Component Schemas                        ‚îÇ
‚îÇ   signature.schema.json, agreement.schema.json,         ‚îÇ
‚îÇ   files.schema.json, embedding.schema.json, etc.        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="schema-categories"><a class="header" href="#schema-categories">Schema Categories</a></h2>
<h3 id="configuration-schema"><a class="header" href="#configuration-schema">Configuration Schema</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Schema</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>jacs.config.schema.json</code></td><td>Agent configuration file format</td></tr>
</tbody></table>
</div>
<h3 id="document-schemas"><a class="header" href="#document-schemas">Document Schemas</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Schema</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>header/v1/header.schema.json</code></td><td>Base fields for all JACS documents</td></tr>
<tr><td><code>agent/v1/agent.schema.json</code></td><td>Agent identity and capabilities</td></tr>
<tr><td><code>task/v1/task.schema.json</code></td><td>Task workflow and state management</td></tr>
<tr><td><code>message/v1/message.schema.json</code></td><td>Inter-agent messages</td></tr>
<tr><td><code>node/v1/node.schema.json</code></td><td>Graph node representation</td></tr>
<tr><td><code>program/v1/program.schema.json</code></td><td>Executable program definitions</td></tr>
<tr><td><code>eval/v1/eval.schema.json</code></td><td>Evaluation and assessment records</td></tr>
<tr><td><code>agentstate/v1/agentstate.schema.json</code></td><td>Signed agent state files (memory, skills, plans, configs, hooks, other)</td></tr>
<tr><td><code>commitment/v1/commitment.schema.json</code></td><td>Shared, signed agreements between agents</td></tr>
<tr><td><code>todo/v1/todo.schema.json</code></td><td>Private, signed todo lists with inline items</td></tr>
</tbody></table>
</div>
<h3 id="component-schemas"><a class="header" href="#component-schemas">Component Schemas</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Schema</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>signature/v1/signature.schema.json</code></td><td>Cryptographic signatures</td></tr>
<tr><td><code>agreement/v1/agreement.schema.json</code></td><td>Multi-party agreements</td></tr>
<tr><td><code>files/v1/files.schema.json</code></td><td>File attachments</td></tr>
<tr><td><code>embedding/v1/embedding.schema.json</code></td><td>Vector embeddings</td></tr>
<tr><td><code>contact/v1/contact.schema.json</code></td><td>Contact information</td></tr>
<tr><td><code>service/v1/service.schema.json</code></td><td>Service definitions</td></tr>
<tr><td><code>tool/v1/tool.schema.json</code></td><td>Tool capabilities</td></tr>
<tr><td><code>action/v1/action.schema.json</code></td><td>Action definitions</td></tr>
<tr><td><code>unit/v1/unit.schema.json</code></td><td>Unit of measurement</td></tr>
<tr><td><code>todoitem/v1/todoitem.schema.json</code></td><td>Inline todo item (goal or task)</td></tr>
</tbody></table>
</div>
<h2 id="schema-locations"><a class="header" href="#schema-locations">Schema Locations</a></h2>
<p>Schemas are available at:</p>
<ul>
<li><strong>HTTPS URLs</strong>: <code>https://hai.ai/schemas/...</code></li>
<li><strong>Local files</strong>: <code>jacs/schemas/...</code></li>
</ul>
<p>Example schema URLs:</p>
<pre><code>https://hai.ai/schemas/jacs.config.schema.json
https://hai.ai/schemas/header/v1/header.schema.json
https://hai.ai/schemas/agent/v1/agent.schema.json
https://hai.ai/schemas/components/signature/v1/signature.schema.json
</code></pre>
<h2 id="using-schemas"><a class="header" href="#using-schemas">Using Schemas</a></h2>
<h3 id="in-documents"><a class="header" href="#in-documents">In Documents</a></h3>
<p>Every JACS document must include a <code>$schema</code> field:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsType": "agent",
  ...
}
</code></pre>
<h3 id="in-configuration-files"><a class="header" href="#in-configuration-files">In Configuration Files</a></h3>
<p>Reference the config schema for IDE support:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  ...
}
</code></pre>
<h3 id="custom-schema-validation-1"><a class="header" href="#custom-schema-validation-1">Custom Schema Validation</a></h3>
<p>Validate documents against custom schemas:</p>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create document with custom schema
doc = agent.create_document(
    json.dumps({'invoice_id': 'INV-001', 'amount': 100.00}),
    custom_schema='./schemas/invoice.schema.json'
)
</code></pre>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');

// Create document with custom schema
const doc = agent.createDocument(
  JSON.stringify({ invoice_id: 'INV-001', amount: 100.00 }),
  './schemas/invoice.schema.json'
);
</code></pre>
<h2 id="hai-extensions"><a class="header" href="#hai-extensions">HAI Extensions</a></h2>
<p>JACS schemas include a custom <code>hai</code> property that categorizes fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>meta</code></td><td>Metadata fields (IDs, dates, versions)</td></tr>
<tr><td><code>base</code></td><td>Core cryptographic fields (hashes, signatures)</td></tr>
<tr><td><code>agent</code></td><td>Agent-controlled content fields</td></tr>
</tbody></table>
</div>
<p>This categorization helps determine which fields should be included in hash calculations and signature operations.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Schemas are versioned using directory paths:</p>
<pre><code>schemas/
‚îú‚îÄ‚îÄ header/
‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îÇ       ‚îî‚îÄ‚îÄ header.schema.json
‚îú‚îÄ‚îÄ agent/
‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îÇ       ‚îî‚îÄ‚îÄ agent.schema.json
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ signature/
        ‚îî‚îÄ‚îÄ v1/
            ‚îî‚îÄ‚îÄ signature.schema.json
</code></pre>
<p>Configuration options allow specifying schema versions:</p>
<pre><code class="language-json">{
  "jacs_agent_schema_version": "v1",
  "jacs_header_schema_version": "v1",
  "jacs_signature_schema_version": "v1"
}
</code></pre>
<h2 id="schema-composition"><a class="header" href="#schema-composition">Schema Composition</a></h2>
<p>Document schemas use JSON Schema's <code>allOf</code> to compose the header with type-specific fields:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "jacsAgentType": { ... },
        "jacsServices": { ... }
      }
    }
  ]
}
</code></pre>
<p>This ensures all documents share common header fields while allowing type-specific extensions.</p>
<h2 id="creating-custom-schemas"><a class="header" href="#creating-custom-schemas">Creating Custom Schemas</a></h2>
<p>Create custom schemas that extend JACS schemas:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://example.com/schemas/invoice.schema.json",
  "title": "Invoice",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "invoiceNumber": {
          "type": "string",
          "description": "Unique invoice identifier"
        },
        "amount": {
          "type": "number",
          "minimum": 0,
          "description": "Invoice amount"
        },
        "currency": {
          "type": "string",
          "enum": ["USD", "EUR", "GBP"],
          "default": "USD"
        },
        "lineItems": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "description": { "type": "string" },
              "quantity": { "type": "integer", "minimum": 1 },
              "unitPrice": { "type": "number", "minimum": 0 }
            },
            "required": ["description", "quantity", "unitPrice"]
          }
        }
      },
      "required": ["invoiceNumber", "amount"]
    }
  ]
}
</code></pre>
<h2 id="validation-rules"><a class="header" href="#validation-rules">Validation Rules</a></h2>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<p>All JACS documents require these header fields:</p>
<ul>
<li><code>jacsId</code> - Unique document identifier (UUID v4)</li>
<li><code>jacsType</code> - Document type identifier</li>
<li><code>jacsVersion</code> - Version identifier (UUID v4)</li>
<li><code>jacsVersionDate</code> - Version timestamp (ISO 8601)</li>
<li><code>jacsOriginalVersion</code> - First version identifier</li>
<li><code>jacsOriginalDate</code> - Creation timestamp</li>
<li><code>jacsLevel</code> - Document level (raw, config, artifact, derived)</li>
<li><code>$schema</code> - Schema reference URL</li>
</ul>
<h3 id="format-validation"><a class="header" href="#format-validation">Format Validation</a></h3>
<p>Fields use JSON Schema format keywords:</p>
<ul>
<li><code>uuid</code> - UUID v4 format</li>
<li><code>date-time</code> - ISO 8601 date-time format</li>
<li><code>uri</code> - Valid URI format</li>
</ul>
<h3 id="enum-constraints"><a class="header" href="#enum-constraints">Enum Constraints</a></h3>
<p>Many fields have enumerated valid values:</p>
<pre><code class="language-json">{
  "jacsLevel": {
    "enum": ["raw", "config", "artifact", "derived"]
  },
  "jacsAgentType": {
    "enum": ["human", "human-org", "hybrid", "ai"]
  },
  "jacs_agent_key_algorithm": {
    "enum": ["RSA-PSS", "ring-Ed25519", "pq-dilithium", "pq2025"]
  }
}
</code></pre>
<h2 id="schema-reference"><a class="header" href="#schema-reference">Schema Reference</a></h2>
<p>For detailed documentation on specific schemas:</p>
<ul>
<li><a href="schemas/agent.html">Agent Schema</a> - Agent identity and capabilities</li>
<li><a href="schemas/document.html">Document Schema</a> - Document header and structure</li>
<li><a href="schemas/task.html">Task Schema</a> - Task workflow management</li>
<li><a href="schemas/agentstate.html">Agent State Schema</a> - Signed agent state documents</li>
<li><a href="schemas/commitment.html">Commitment Schema</a> - Shared agreements between agents</li>
<li><a href="schemas/todo.html">Todo List Schema</a> - Private task tracking with inline items</li>
<li><a href="schemas/conversation.html">Conversation Schema</a> - Message threading and ordering</li>
<li><a href="schemas/configuration.html">Configuration</a> - Configuration file format</li>
</ul>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="schemas/../advanced/custom-schemas.html">Custom Schemas</a> - Creating custom document types</li>
<li><a href="schemas/../advanced/security.html">Security Model</a> - How schemas relate to security</li>
<li><a href="schemas/../python/api.html">API Reference</a> - Using schemas in code</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agent-schema"><a class="header" href="#agent-schema">Agent Schema</a></h1>
<p>The Agent Schema defines the structure for agent identity documents in JACS. Agents represent entities that can sign documents, participate in agreements, and provide services.</p>
<h2 id="schema-location"><a class="header" href="#schema-location">Schema Location</a></h2>
<pre><code>https://hai.ai/schemas/agent/v1/agent.schema.json
</code></pre>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>Agent documents describe:</p>
<ul>
<li><strong>Identity</strong>: Unique identifiers and versioning</li>
<li><strong>Type</strong>: Human, organizational, hybrid, or AI classification</li>
<li><strong>Services</strong>: Capabilities the agent offers</li>
<li><strong>Contacts</strong>: How to reach human or hybrid agents</li>
<li><strong>Domain</strong>: Optional DNS-based verification</li>
</ul>
<h2 id="schema-structure"><a class="header" href="#schema-structure">Schema Structure</a></h2>
<p>The agent schema extends the <a href="schemas/document.html">Header Schema</a> using JSON Schema composition:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "title": "Agent",
  "description": "General schema for human, hybrid, and AI agents",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    { "type": "object", "properties": { ... } }
  ]
}
</code></pre>
<h2 id="agent-types-1"><a class="header" href="#agent-types-1">Agent Types</a></h2>
<p>The <code>jacsAgentType</code> field classifies the agent:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>human</code></td><td>A biological entity (individual person)</td></tr>
<tr><td><code>human-org</code></td><td>A group of people (organization, company)</td></tr>
<tr><td><code>hybrid</code></td><td>Combination of human and AI components</td></tr>
<tr><td><code>ai</code></td><td>Fully artificial intelligence</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacsAgentType": {
    "type": "string",
    "enum": ["human", "human-org", "hybrid", "ai"]
  }
}
</code></pre>
<h3 id="contact-requirements"><a class="header" href="#contact-requirements">Contact Requirements</a></h3>
<p>Human and hybrid agents must provide contact information:</p>
<pre><code class="language-json">{
  "if": {
    "properties": {
      "jacsAgentType": { "enum": ["human", "human-org", "hybrid"] }
    }
  },
  "then": {
    "required": ["jacsContacts"]
  }
}
</code></pre>
<h2 id="agent-properties"><a class="header" href="#agent-properties">Agent Properties</a></h2>
<h3 id="core-fields-from-header"><a class="header" href="#core-fields-from-header">Core Fields (from Header)</a></h3>
<p>All agents inherit these header fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsId</code></td><td>string (UUID)</td><td>Yes</td><td>Unique agent identifier</td></tr>
<tr><td><code>jacsVersion</code></td><td>string (UUID)</td><td>Yes</td><td>Current version identifier</td></tr>
<tr><td><code>jacsVersionDate</code></td><td>string (date-time)</td><td>Yes</td><td>Version timestamp</td></tr>
<tr><td><code>jacsType</code></td><td>string</td><td>Yes</td><td>Set to "agent"</td></tr>
<tr><td><code>jacsOriginalVersion</code></td><td>string (UUID)</td><td>Yes</td><td>First version identifier</td></tr>
<tr><td><code>jacsOriginalDate</code></td><td>string (date-time)</td><td>Yes</td><td>Creation timestamp</td></tr>
<tr><td><code>jacsLevel</code></td><td>string</td><td>Yes</td><td>Document level</td></tr>
<tr><td><code>jacsSignature</code></td><td>object</td><td>No</td><td>Cryptographic signature</td></tr>
<tr><td><code>jacsSha256</code></td><td>string</td><td>No</td><td>Content hash</td></tr>
</tbody></table>
</div>
<h3 id="agent-specific-fields"><a class="header" href="#agent-specific-fields">Agent-Specific Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsAgentType</code></td><td>string</td><td>Yes</td><td>Agent classification</td></tr>
<tr><td><code>jacsAgentDomain</code></td><td>string</td><td>No</td><td>Domain for DNS verification</td></tr>
<tr><td><code>jacsServices</code></td><td>array</td><td>Yes</td><td>Services the agent provides</td></tr>
<tr><td><code>jacsContacts</code></td><td>array</td><td>Conditional</td><td>Contact information (required for human/hybrid)</td></tr>
</tbody></table>
</div>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<p>Services describe capabilities the agent offers:</p>
<pre><code class="language-json">{
  "jacsServices": [{
    "name": "Document Signing Service",
    "serviceDescription": "Sign and verify JACS documents",
    "successDescription": "Documents are signed with valid signatures",
    "failureDescription": "Invalid documents or signing errors",
    "costDescription": "Free for basic usage, paid tiers available",
    "idealCustomerDescription": "Developers building secure agent systems",
    "termsOfService": "https://example.com/tos",
    "privacyPolicy": "https://example.com/privacy",
    "isDev": false,
    "tools": [...]
  }]
}
</code></pre>
<h3 id="service-schema-fields"><a class="header" href="#service-schema-fields">Service Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>No</td><td>Service name</td></tr>
<tr><td><code>serviceDescription</code></td><td>string</td><td>Yes</td><td>What the service does</td></tr>
<tr><td><code>successDescription</code></td><td>string</td><td>Yes</td><td>What success looks like</td></tr>
<tr><td><code>failureDescription</code></td><td>string</td><td>Yes</td><td>What failure looks like</td></tr>
<tr><td><code>costDescription</code></td><td>string</td><td>No</td><td>Pricing information</td></tr>
<tr><td><code>idealCustomerDescription</code></td><td>string</td><td>No</td><td>Target customer profile</td></tr>
<tr><td><code>termsOfService</code></td><td>string</td><td>No</td><td>Legal terms URL or text</td></tr>
<tr><td><code>privacyPolicy</code></td><td>string</td><td>No</td><td>Privacy policy URL or text</td></tr>
<tr><td><code>copyright</code></td><td>string</td><td>No</td><td>Usage rights for provided data</td></tr>
<tr><td><code>eula</code></td><td>string</td><td>No</td><td>End-user license agreement</td></tr>
<tr><td><code>isDev</code></td><td>boolean</td><td>No</td><td>Whether this is a dev/test service</td></tr>
<tr><td><code>tools</code></td><td>array</td><td>No</td><td>Tool definitions</td></tr>
<tr><td><code>piiDesired</code></td><td>array</td><td>No</td><td>Types of sensitive data needed</td></tr>
</tbody></table>
</div>
<h3 id="pii-types"><a class="header" href="#pii-types">PII Types</a></h3>
<p>Services can declare what personally identifiable information they need:</p>
<pre><code class="language-json">{
  "piiDesired": ["email", "phone", "address"]
}
</code></pre>
<p>Valid PII types:</p>
<ul>
<li><code>signature</code> - Digital signatures</li>
<li><code>cryptoaddress</code> - Cryptocurrency addresses</li>
<li><code>creditcard</code> - Payment card numbers</li>
<li><code>govid</code> - Government identification</li>
<li><code>social</code> - Social security numbers</li>
<li><code>email</code> - Email addresses</li>
<li><code>phone</code> - Phone numbers</li>
<li><code>address</code> - Physical addresses</li>
<li><code>zip</code> - Postal codes</li>
<li><code>PHI</code> - Protected health information</li>
<li><code>MHI</code> - Mental health information</li>
<li><code>identity</code> - Identity documents</li>
<li><code>political</code> - Political affiliation</li>
<li><code>bankaddress</code> - Banking information</li>
<li><code>income</code> - Income data</li>
</ul>
<h2 id="contacts"><a class="header" href="#contacts">Contacts</a></h2>
<p>Contact information for human and hybrid agents:</p>
<pre><code class="language-json">{
  "jacsContacts": [{
    "firstName": "Jane",
    "lastName": "Smith",
    "email": "jane@example.com",
    "phone": "+1-555-0123",
    "isPrimary": true,
    "mailAddress": "123 Main St",
    "mailState": "CA",
    "mailZip": "94102",
    "mailCountry": "USA"
  }]
}
</code></pre>
<h3 id="contact-schema-fields"><a class="header" href="#contact-schema-fields">Contact Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>firstName</code></td><td>string</td><td>First name</td></tr>
<tr><td><code>lastName</code></td><td>string</td><td>Last name</td></tr>
<tr><td><code>addressName</code></td><td>string</td><td>Location name</td></tr>
<tr><td><code>phone</code></td><td>string</td><td>Phone number</td></tr>
<tr><td><code>email</code></td><td>string (email)</td><td>Email address</td></tr>
<tr><td><code>mailName</code></td><td>string</td><td>Name at address</td></tr>
<tr><td><code>mailAddress</code></td><td>string</td><td>Street address</td></tr>
<tr><td><code>mailAddressTwo</code></td><td>string</td><td>Address line 2</td></tr>
<tr><td><code>mailState</code></td><td>string</td><td>State/province</td></tr>
<tr><td><code>mailZip</code></td><td>string</td><td>Postal code</td></tr>
<tr><td><code>mailCountry</code></td><td>string</td><td>Country</td></tr>
<tr><td><code>isPrimary</code></td><td>boolean</td><td>Primary contact flag</td></tr>
</tbody></table>
</div>
<h2 id="dns-verification"><a class="header" href="#dns-verification">DNS Verification</a></h2>
<p>Agents can link to a domain for DNSSEC-validated verification:</p>
<pre><code class="language-json">{
  "jacsAgentDomain": "example.com"
}
</code></pre>
<p>The domain should have a DNS TXT record at <code>_v1.agent.jacs.example.com.</code> containing the agent's public key fingerprint.</p>
<p>See the <a href="schemas/../dns.html">DNS chapter</a> for complete setup instructions.</p>
<h2 id="complete-example-7"><a class="header" href="#complete-example-7">Complete Example</a></h2>
<h3 id="ai-agent"><a class="header" href="#ai-agent">AI Agent</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsType": "agent",
  "jacsOriginalVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsOriginalDate": "2024-01-15T10:30:00Z",
  "jacsLevel": "artifact",
  "jacsAgentType": "ai",
  "jacsServices": [{
    "name": "Code Review Service",
    "serviceDescription": "Automated code review and analysis",
    "successDescription": "Review completed with actionable feedback",
    "failureDescription": "Unable to process or analyze code",
    "isDev": false
  }],
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "date": "2024-01-15T10:30:00Z",
    "signature": "base64-encoded-signature...",
    "publicKeyHash": "sha256-hash-of-public-key",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsVersion", "jacsAgentType", "jacsServices"]
  },
  "jacsSha256": "document-hash..."
}
</code></pre>
<h3 id="human-agent"><a class="header" href="#human-agent">Human Agent</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsId": "660e8400-e29b-41d4-a716-446655440001",
  "jacsVersion": "a47ac10b-58cc-4372-a567-0e02b2c3d480",
  "jacsVersionDate": "2024-01-15T11:00:00Z",
  "jacsType": "agent",
  "jacsOriginalVersion": "a47ac10b-58cc-4372-a567-0e02b2c3d480",
  "jacsOriginalDate": "2024-01-15T11:00:00Z",
  "jacsLevel": "artifact",
  "jacsAgentType": "human",
  "jacsAgentDomain": "smith.example.com",
  "jacsServices": [{
    "name": "Consulting",
    "serviceDescription": "Technical consulting services",
    "successDescription": "Project goals achieved",
    "failureDescription": "Unable to meet requirements",
    "termsOfService": "https://smith.example.com/tos"
  }],
  "jacsContacts": [{
    "firstName": "John",
    "lastName": "Smith",
    "email": "john@smith.example.com",
    "isPrimary": true
  }]
}
</code></pre>
<h3 id="organization-agent"><a class="header" href="#organization-agent">Organization Agent</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agent/v1/agent.schema.json",
  "jacsId": "770e8400-e29b-41d4-a716-446655440002",
  "jacsVersion": "b47ac10b-58cc-4372-a567-0e02b2c3d481",
  "jacsVersionDate": "2024-01-15T12:00:00Z",
  "jacsType": "agent",
  "jacsOriginalVersion": "b47ac10b-58cc-4372-a567-0e02b2c3d481",
  "jacsOriginalDate": "2024-01-15T12:00:00Z",
  "jacsLevel": "artifact",
  "jacsAgentType": "human-org",
  "jacsAgentDomain": "acme.com",
  "jacsServices": [{
    "name": "Enterprise Software",
    "serviceDescription": "Enterprise software solutions",
    "successDescription": "Software deployed and operational",
    "failureDescription": "Deployment or integration failure",
    "privacyPolicy": "https://acme.com/privacy",
    "piiDesired": ["email", "phone"]
  }],
  "jacsContacts": [{
    "addressName": "Acme Corporation",
    "email": "contact@acme.com",
    "phone": "+1-800-555-ACME",
    "mailAddress": "1 Corporate Plaza",
    "mailState": "NY",
    "mailZip": "10001",
    "mailCountry": "USA",
    "isPrimary": true
  }]
}
</code></pre>
<h2 id="creating-agents"><a class="header" href="#creating-agents">Creating Agents</a></h2>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# The agent is created during configuration setup
# Agent document is available after loading
agent_json = agent.load('./jacs.config.json')
agent_doc = json.loads(agent_json)

print(f"Agent ID: {agent_doc['jacsId']}")
print(f"Agent Type: {agent_doc['jacsAgentType']}")
</code></pre>
<h3 id="nodejs-1"><a class="header" href="#nodejs-1">Node.js</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
const agentJson = agent.load('./jacs.config.json');
const agentDoc = JSON.parse(agentJson);

console.log(`Agent ID: ${agentDoc.jacsId}`);
console.log(`Agent Type: ${agentDoc.jacsAgentType}`);
</code></pre>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<pre><code class="language-bash"># Create a new agent
jacs agent create

# View agent details
jacs agent show
</code></pre>
<h2 id="verifying-agents-1"><a class="header" href="#verifying-agents-1">Verifying Agents</a></h2>
<pre><code class="language-python"># Verify the loaded agent
is_valid = agent.verify_agent()

# Verify another agent file
is_valid = agent.verify_agent('./other-agent.json')
</code></pre>
<pre><code class="language-javascript">// Verify the loaded agent
const isValid = agent.verifyAgent();

// Verify another agent file
const isOtherValid = agent.verifyAgent('./other-agent.json');
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="schemas/document.html">Document Schema</a> - Header fields documentation</li>
<li><a href="schemas/task.html">Task Schema</a> - Task workflow schema</li>
<li><a href="schemas/../dns.html">DNS Verification</a> - Setting up domain verification</li>
<li><a href="schemas/../rust/agent.html">Creating an Agent</a> - Agent creation guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-schema"><a class="header" href="#document-schema">Document Schema</a></h1>
<p>The Document Schema (Header Schema) defines the base structure for all JACS documents. Every JACS document type (agents, tasks, messages, etc.) extends this schema.</p>
<h2 id="schema-location-1"><a class="header" href="#schema-location-1">Schema Location</a></h2>
<pre><code>https://hai.ai/schemas/header/v1/header.schema.json
</code></pre>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The header schema provides:</p>
<ul>
<li><strong>Unique Identification</strong>: Every document has a unique ID and version</li>
<li><strong>Version Tracking</strong>: Full history with previous version references</li>
<li><strong>Cryptographic Integrity</strong>: Signatures and hashes for verification</li>
<li><strong>File Attachments</strong>: Support for embedded or linked files</li>
<li><strong>Vector Embeddings</strong>: Pre-computed embeddings for semantic search</li>
<li><strong>Agreements</strong>: Multi-party signature support</li>
</ul>
<h2 id="core-fields"><a class="header" href="#core-fields">Core Fields</a></h2>
<h3 id="identification"><a class="header" href="#identification">Identification</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>$schema</code></td><td>string</td><td>Yes</td><td>Schema URL for validation</td></tr>
<tr><td><code>jacsId</code></td><td>string (UUID)</td><td>Yes</td><td>Unique document identifier</td></tr>
<tr><td><code>jacsType</code></td><td>string</td><td>Yes</td><td>Document type (agent, task, etc.)</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/header/v1/header.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsType": "document"
}
</code></pre>
<h3 id="versioning-1"><a class="header" href="#versioning-1">Versioning</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsVersion</code></td><td>string (UUID)</td><td>Yes</td><td>Current version identifier</td></tr>
<tr><td><code>jacsVersionDate</code></td><td>string (date-time)</td><td>Yes</td><td>Version creation timestamp</td></tr>
<tr><td><code>jacsPreviousVersion</code></td><td>string (UUID)</td><td>No</td><td>Previous version (if not first)</td></tr>
<tr><td><code>jacsOriginalVersion</code></td><td>string (UUID)</td><td>Yes</td><td>First version identifier</td></tr>
<tr><td><code>jacsOriginalDate</code></td><td>string (date-time)</td><td>Yes</td><td>Document creation timestamp</td></tr>
<tr><td><code>jacsBranch</code></td><td>string (UUID)</td><td>No</td><td>Branch identifier for JACS databases</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacsVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsPreviousVersion": "e36ac10b-58cc-4372-a567-0e02b2c3d478",
  "jacsOriginalVersion": "a47ac10b-58cc-4372-a567-0e02b2c3d476",
  "jacsOriginalDate": "2024-01-01T09:00:00Z"
}
</code></pre>
<h3 id="document-level"><a class="header" href="#document-level">Document Level</a></h3>
<p>The <code>jacsLevel</code> field indicates the intended use:</p>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Description</th></tr></thead><tbody>
<tr><td><code>raw</code></td><td>Raw data that should not change</td></tr>
<tr><td><code>config</code></td><td>Configuration meant to be updated</td></tr>
<tr><td><code>artifact</code></td><td>Generated content that may be updated</td></tr>
<tr><td><code>derived</code></td><td>Computed from other documents</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacsLevel": "artifact"
}
</code></pre>
<h2 id="cryptographic-fields"><a class="header" href="#cryptographic-fields">Cryptographic Fields</a></h2>
<h3 id="signature"><a class="header" href="#signature">Signature</a></h3>
<p>The <code>jacsSignature</code> field contains the creator's cryptographic signature:</p>
<pre><code class="language-json">{
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "date": "2024-01-15T10:30:00Z",
    "signature": "base64-encoded-signature-string",
    "publicKeyHash": "sha256-hash-of-public-key",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsVersion", "jacsType", "content"]
  }
}
</code></pre>
<h4 id="signature-schema-fields"><a class="header" href="#signature-schema-fields">Signature Schema Fields</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>agentID</code></td><td>string (UUID)</td><td>Yes</td><td>Signing agent's ID</td></tr>
<tr><td><code>agentVersion</code></td><td>string (UUID)</td><td>Yes</td><td>Signing agent's version</td></tr>
<tr><td><code>date</code></td><td>string (date-time)</td><td>Yes</td><td>Signing timestamp</td></tr>
<tr><td><code>signature</code></td><td>string</td><td>Yes</td><td>Base64-encoded signature</td></tr>
<tr><td><code>publicKeyHash</code></td><td>string</td><td>Yes</td><td>Hash of public key used</td></tr>
<tr><td><code>signingAlgorithm</code></td><td>string</td><td>No</td><td>Algorithm used (ring-Ed25519, RSA-PSS, pq-dilithium)</td></tr>
<tr><td><code>fields</code></td><td>array</td><td>Yes</td><td>Fields included in signature</td></tr>
<tr><td><code>response</code></td><td>string</td><td>No</td><td>Text response with signature</td></tr>
<tr><td><code>responseType</code></td><td>string</td><td>No</td><td>agree, disagree, or reject</td></tr>
</tbody></table>
</div>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<p>The <code>jacsRegistration</code> field contains a signature from a registration authority:</p>
<pre><code class="language-json">{
  "jacsRegistration": {
    "agentID": "registrar-agent-id",
    "agentVersion": "registrar-version",
    "date": "2024-01-15T10:35:00Z",
    "signature": "registrar-signature",
    "publicKeyHash": "registrar-key-hash",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsSignature"]
  }
}
</code></pre>
<h3 id="hash"><a class="header" href="#hash">Hash</a></h3>
<p>The <code>jacsSha256</code> field contains a SHA-256 hash of all document content (excluding this field):</p>
<pre><code class="language-json">{
  "jacsSha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
}
</code></pre>
<h2 id="agreements-2"><a class="header" href="#agreements-2">Agreements</a></h2>
<p>Documents can include multi-party agreements using <code>jacsAgreement</code>:</p>
<pre><code class="language-json">{
  "jacsAgreement": {
    "agentIDs": [
      "agent-1-uuid",
      "agent-2-uuid",
      "agent-3-uuid"
    ],
    "question": "Do you agree to these terms?",
    "context": "Q1 2024 Service Agreement",
    "signatures": [
      {
        "agentID": "agent-1-uuid",
        "signature": "...",
        "responseType": "agree",
        "date": "2024-01-15T11:00:00Z"
      }
    ]
  },
  "jacsAgreementHash": "hash-of-content-at-agreement-time"
}
</code></pre>
<h3 id="agreement-schema-fields"><a class="header" href="#agreement-schema-fields">Agreement Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>agentIDs</code></td><td>array</td><td>Yes</td><td>Required signers</td></tr>
<tr><td><code>question</code></td><td>string</td><td>No</td><td>What parties are agreeing to</td></tr>
<tr><td><code>context</code></td><td>string</td><td>No</td><td>Additional context</td></tr>
<tr><td><code>signatures</code></td><td>array</td><td>No</td><td>Collected signatures</td></tr>
</tbody></table>
</div>
<h2 id="file-attachments-1"><a class="header" href="#file-attachments-1">File Attachments</a></h2>
<p>Documents can include file attachments using <code>jacsFiles</code>:</p>
<pre><code class="language-json">{
  "jacsFiles": [
    {
      "mimetype": "application/pdf",
      "path": "./documents/contract.pdf",
      "embed": true,
      "contents": "base64-encoded-file-contents",
      "sha256": "file-content-hash"
    },
    {
      "mimetype": "image/png",
      "path": "./images/diagram.png",
      "embed": false,
      "sha256": "file-content-hash"
    }
  ]
}
</code></pre>
<h3 id="file-schema-fields"><a class="header" href="#file-schema-fields">File Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mimetype</code></td><td>string</td><td>Yes</td><td>MIME type of the file</td></tr>
<tr><td><code>path</code></td><td>string</td><td>Yes</td><td>File location (local path)</td></tr>
<tr><td><code>embed</code></td><td>boolean</td><td>Yes</td><td>Whether to embed contents</td></tr>
<tr><td><code>contents</code></td><td>string</td><td>No</td><td>Base64-encoded file contents</td></tr>
<tr><td><code>sha256</code></td><td>string</td><td>No</td><td>Hash for content verification</td></tr>
</tbody></table>
</div>
<h2 id="vector-embeddings"><a class="header" href="#vector-embeddings">Vector Embeddings</a></h2>
<p>Documents can include pre-computed embeddings for semantic search:</p>
<pre><code class="language-json">{
  "jacsEmbedding": [
    {
      "llm": "text-embedding-ada-002",
      "vector": [0.0023, -0.0089, 0.0156, ...]
    }
  ]
}
</code></pre>
<h3 id="embedding-schema-fields"><a class="header" href="#embedding-schema-fields">Embedding Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>llm</code></td><td>string</td><td>Yes</td><td>Model used for embedding</td></tr>
<tr><td><code>vector</code></td><td>array</td><td>Yes</td><td>Vector of numbers</td></tr>
</tbody></table>
</div>
<h2 id="complete-example-8"><a class="header" href="#complete-example-8">Complete Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/header/v1/header.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsType": "document",
  "jacsVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsOriginalVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsOriginalDate": "2024-01-15T10:30:00Z",
  "jacsLevel": "artifact",

  "title": "Sample Document",
  "content": "This is the document content.",

  "jacsFiles": [
    {
      "mimetype": "application/pdf",
      "path": "./attachment.pdf",
      "embed": false,
      "sha256": "abc123..."
    }
  ],

  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "date": "2024-01-15T10:30:00Z",
    "signature": "signature-base64...",
    "publicKeyHash": "key-hash...",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsVersion", "title", "content"]
  },

  "jacsSha256": "document-hash..."
}
</code></pre>
<h2 id="hai-field-categories"><a class="header" href="#hai-field-categories">HAI Field Categories</a></h2>
<p>Fields include a <code>hai</code> property indicating their category:</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th><th>Examples</th></tr></thead><tbody>
<tr><td><code>meta</code></td><td>Metadata (IDs, dates)</td><td>jacsId, jacsVersion, jacsVersionDate</td></tr>
<tr><td><code>base</code></td><td>Cryptographic data</td><td>jacsSha256, signature</td></tr>
<tr><td><code>agent</code></td><td>Agent-controlled content</td><td>Custom content fields</td></tr>
</tbody></table>
</div>
<p>This categorization determines which fields are included in hash and signature calculations.</p>
<h2 id="working-with-documents-2"><a class="header" href="#working-with-documents-2">Working with Documents</a></h2>
<h3 id="creating-documents-4"><a class="header" href="#creating-documents-4">Creating Documents</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create a basic document
doc = agent.create_document(json.dumps({
    'title': 'My Document',
    'content': 'Document content here'
}))
</code></pre>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');

const doc = agent.createDocument(JSON.stringify({
  title: 'My Document',
  content: 'Document content here'
}));
</code></pre>
<h3 id="verifying-documents-4"><a class="header" href="#verifying-documents-4">Verifying Documents</a></h3>
<pre><code class="language-python">is_valid = agent.verify_document(doc_json)
</code></pre>
<pre><code class="language-javascript">const isValid = agent.verifyDocument(docJson);
</code></pre>
<h3 id="updating-documents-4"><a class="header" href="#updating-documents-4">Updating Documents</a></h3>
<pre><code class="language-python">doc = json.loads(signed_doc)
document_key = f"{doc['jacsId']}:{doc['jacsVersion']}"

updated = agent.update_document(
    document_key,
    json.dumps({**doc, 'content': 'Updated content'})
)
</code></pre>
<pre><code class="language-javascript">const doc = JSON.parse(signedDoc);
const documentKey = `${doc.jacsId}:${doc.jacsVersion}`;

const updated = agent.updateDocument(
  documentKey,
  JSON.stringify({...doc, content: 'Updated content'})
);
</code></pre>
<h3 id="adding-attachments"><a class="header" href="#adding-attachments">Adding Attachments</a></h3>
<pre><code class="language-python">doc = agent.create_document(
    json.dumps({'title': 'Report'}),
    attachments='./report.pdf',
    embed=True
)
</code></pre>
<pre><code class="language-javascript">const doc = agent.createDocument(
  JSON.stringify({ title: 'Report' }),
  null,    // custom_schema
  null,    // output_filename
  false,   // no_save
  './report.pdf',  // attachments
  true     // embed
);
</code></pre>
<h2 id="version-history-1"><a class="header" href="#version-history-1">Version History</a></h2>
<p>Documents maintain a version chain:</p>
<pre><code>Original (v1) ‚Üê Previous (v2) ‚Üê Current (v3)
     ‚îÇ
     ‚îî‚îÄ‚îÄ jacsOriginalVersion points here for all versions
</code></pre>
<p>Each version:</p>
<ul>
<li>Has its own <code>jacsVersion</code> UUID</li>
<li>References <code>jacsPreviousVersion</code> (except the first)</li>
<li>All share the same <code>jacsId</code> and <code>jacsOriginalVersion</code></li>
</ul>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="schemas/agent.html">Agent Schema</a> - Agent document structure</li>
<li><a href="schemas/task.html">Task Schema</a> - Task document structure</li>
<li><a href="schemas/../rust/documents.html">Working with Documents</a> - Document operations guide</li>
<li><a href="schemas/../rust/agreements.html">Agreements</a> - Multi-party agreements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-schema"><a class="header" href="#task-schema">Task Schema</a></h1>
<p>The Task Schema defines the structure for task documents in JACS. Tasks represent work items with defined states, assigned agents, and completion criteria.</p>
<h2 id="schema-location-2"><a class="header" href="#schema-location-2">Schema Location</a></h2>
<pre><code>https://hai.ai/schemas/task/v1/task.schema.json
</code></pre>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Task documents manage:</p>
<ul>
<li><strong>Workflow States</strong>: From creation through completion</li>
<li><strong>Agent Assignment</strong>: Customer and assigned agent tracking</li>
<li><strong>Actions</strong>: Desired outcomes and completion criteria</li>
<li><strong>Agreements</strong>: Start and end agreements between parties</li>
<li><strong>Relationships</strong>: Sub-tasks, copies, and merges</li>
</ul>
<h2 id="schema-structure-1"><a class="header" href="#schema-structure-1">Schema Structure</a></h2>
<p>The task schema extends the <a href="schemas/document.html">Header Schema</a>:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://hai.ai/schemas/task/v1/task-schema.json",
  "title": "Task",
  "description": "General schema for stateful resources.",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    { "type": "object", "properties": { ... } }
  ]
}
</code></pre>
<h2 id="task-states"><a class="header" href="#task-states">Task States</a></h2>
<p>Tasks progress through defined workflow states:</p>
<div class="table-wrapper"><table><thead><tr><th>State</th><th>Description</th></tr></thead><tbody>
<tr><td><code>creating</code></td><td>Task is being drafted</td></tr>
<tr><td><code>rfp</code></td><td>Request for proposal - seeking agents</td></tr>
<tr><td><code>proposal</code></td><td>Agent has submitted a proposal</td></tr>
<tr><td><code>negotiation</code></td><td>Terms being negotiated</td></tr>
<tr><td><code>started</code></td><td>Work has begun</td></tr>
<tr><td><code>review</code></td><td>Work submitted for review</td></tr>
<tr><td><code>completed</code></td><td>Task is finished</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacsTaskState": "started"
}
</code></pre>
<h3 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h3>
<pre><code>creating ‚Üí rfp ‚Üí proposal ‚Üí negotiation ‚Üí started ‚Üí review ‚Üí completed
                    ‚Üë_______________|
                (may cycle back for renegotiation)
</code></pre>
<h2 id="task-properties"><a class="header" href="#task-properties">Task Properties</a></h2>
<h3 id="core-fields-from-header-1"><a class="header" href="#core-fields-from-header-1">Core Fields (from Header)</a></h3>
<p>Tasks inherit all <a href="schemas/document.html">document header fields</a> plus task-specific fields.</p>
<h3 id="task-specific-fields"><a class="header" href="#task-specific-fields">Task-Specific Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsTaskName</code></td><td>string</td><td>No</td><td>Human-readable task name</td></tr>
<tr><td><code>jacsTaskSuccess</code></td><td>string</td><td>No</td><td>Description of success criteria</td></tr>
<tr><td><code>jacsTaskState</code></td><td>string</td><td>Yes</td><td>Current workflow state</td></tr>
<tr><td><code>jacsTaskCustomer</code></td><td>object</td><td>Yes</td><td>Customer agent signature</td></tr>
<tr><td><code>jacsTaskAgent</code></td><td>object</td><td>No</td><td>Assigned agent signature</td></tr>
<tr><td><code>jacsTaskStartDate</code></td><td>string (date-time)</td><td>No</td><td>When work started</td></tr>
<tr><td><code>jacsTaskCompleteDate</code></td><td>string (date-time)</td><td>No</td><td>When work completed</td></tr>
<tr><td><code>jacsTaskActionsDesired</code></td><td>array</td><td>Yes</td><td>Required actions</td></tr>
<tr><td><code>jacsStartAgreement</code></td><td>object</td><td>No</td><td>Agreement to begin work</td></tr>
<tr><td><code>jacsEndAgreement</code></td><td>object</td><td>No</td><td>Agreement that work is complete</td></tr>
</tbody></table>
</div>
<h3 id="relationship-fields"><a class="header" href="#relationship-fields">Relationship Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsTaskSubTaskOf</code></td><td>array</td><td>Parent task IDs</td></tr>
<tr><td><code>jacsTaskCopyOf</code></td><td>array</td><td>Source task IDs (branching)</td></tr>
<tr><td><code>jacsTaskMergedTasks</code></td><td>array</td><td>Tasks folded into this one</td></tr>
</tbody></table>
</div>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<p>Actions define what needs to be accomplished:</p>
<pre><code class="language-json">{
  "jacsTaskActionsDesired": [
    {
      "name": "Create API Endpoint",
      "description": "Build REST endpoint for user registration",
      "cost": {
        "value": 500,
        "unit": "USD"
      },
      "duration": {
        "value": 8,
        "unit": "hours"
      },
      "completionAgreementRequired": true,
      "tools": [...]
    }
  ]
}
</code></pre>
<h3 id="action-schema-fields"><a class="header" href="#action-schema-fields">Action Schema Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Action name</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Yes</td><td>What needs to be done</td></tr>
<tr><td><code>tools</code></td><td>array</td><td>No</td><td>Tools that can be used</td></tr>
<tr><td><code>cost</code></td><td>object</td><td>No</td><td>Cost estimate</td></tr>
<tr><td><code>duration</code></td><td>object</td><td>No</td><td>Time estimate</td></tr>
<tr><td><code>completionAgreementRequired</code></td><td>boolean</td><td>No</td><td>Requires sign-off</td></tr>
</tbody></table>
</div>
<h3 id="unit-schema"><a class="header" href="#unit-schema">Unit Schema</a></h3>
<p>Costs and durations use the unit schema:</p>
<pre><code class="language-json">{
  "cost": {
    "value": 100,
    "unit": "USD"
  },
  "duration": {
    "value": 2,
    "unit": "days"
  }
}
</code></pre>
<h2 id="agreements-3"><a class="header" href="#agreements-3">Agreements</a></h2>
<p>Tasks can include start and end agreements:</p>
<h3 id="start-agreement"><a class="header" href="#start-agreement">Start Agreement</a></h3>
<p>Signed when parties agree to begin work:</p>
<pre><code class="language-json">{
  "jacsStartAgreement": {
    "agentIDs": ["customer-uuid", "agent-uuid"],
    "question": "Do you agree to begin this work?",
    "context": "Project XYZ - Phase 1",
    "signatures": [...]
  }
}
</code></pre>
<h3 id="end-agreement"><a class="header" href="#end-agreement">End Agreement</a></h3>
<p>Signed when parties agree work is complete:</p>
<pre><code class="language-json">{
  "jacsEndAgreement": {
    "agentIDs": ["customer-uuid", "agent-uuid"],
    "question": "Do you agree this work is complete?",
    "context": "Final deliverables reviewed",
    "signatures": [...]
  }
}
</code></pre>
<h2 id="complete-example-9"><a class="header" href="#complete-example-9">Complete Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/task/v1/task.schema.json",
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsType": "task",
  "jacsVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsOriginalVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "jacsOriginalDate": "2024-01-15T10:30:00Z",
  "jacsLevel": "artifact",

  "jacsTaskName": "Build Authentication System",
  "jacsTaskSuccess": "Users can register, login, and manage sessions",
  "jacsTaskState": "started",

  "jacsTaskCustomer": {
    "agentID": "customer-agent-uuid",
    "agentVersion": "customer-version-uuid",
    "date": "2024-01-15T10:30:00Z",
    "signature": "customer-signature...",
    "publicKeyHash": "customer-key-hash",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsTaskName", "jacsTaskActionsDesired"]
  },

  "jacsTaskAgent": {
    "agentID": "assigned-agent-uuid",
    "agentVersion": "agent-version-uuid",
    "date": "2024-01-16T09:00:00Z",
    "signature": "agent-signature...",
    "publicKeyHash": "agent-key-hash",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsTaskName", "jacsTaskActionsDesired"]
  },

  "jacsTaskStartDate": "2024-01-16T09:00:00Z",

  "jacsStartAgreement": {
    "agentIDs": ["customer-agent-uuid", "assigned-agent-uuid"],
    "question": "Do you agree to begin work on this task?",
    "signatures": [
      {
        "agentID": "customer-agent-uuid",
        "signature": "...",
        "responseType": "agree",
        "date": "2024-01-16T09:00:00Z"
      },
      {
        "agentID": "assigned-agent-uuid",
        "signature": "...",
        "responseType": "agree",
        "date": "2024-01-16T09:05:00Z"
      }
    ]
  },

  "jacsTaskActionsDesired": [
    {
      "name": "User Registration",
      "description": "Implement user registration with email verification",
      "duration": { "value": 4, "unit": "hours" },
      "completionAgreementRequired": true
    },
    {
      "name": "User Login",
      "description": "Implement secure login with password hashing",
      "duration": { "value": 3, "unit": "hours" },
      "completionAgreementRequired": true
    },
    {
      "name": "Session Management",
      "description": "Implement JWT-based session tokens",
      "duration": { "value": 2, "unit": "hours" },
      "completionAgreementRequired": false
    }
  ],

  "jacsSignature": {
    "agentID": "customer-agent-uuid",
    "agentVersion": "customer-version-uuid",
    "date": "2024-01-15T10:30:00Z",
    "signature": "document-signature...",
    "publicKeyHash": "key-hash...",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsTaskName", "jacsTaskActionsDesired"]
  }
}
</code></pre>
<h2 id="task-relationships"><a class="header" href="#task-relationships">Task Relationships</a></h2>
<h3 id="sub-tasks"><a class="header" href="#sub-tasks">Sub-Tasks</a></h3>
<p>Break large tasks into smaller units:</p>
<pre><code class="language-json">{
  "jacsTaskSubTaskOf": ["parent-task-uuid"]
}
</code></pre>
<h3 id="task-copies-branching"><a class="header" href="#task-copies-branching">Task Copies (Branching)</a></h3>
<p>Create variations or branches:</p>
<pre><code class="language-json">{
  "jacsTaskCopyOf": ["original-task-uuid"]
}
</code></pre>
<h3 id="merged-tasks"><a class="header" href="#merged-tasks">Merged Tasks</a></h3>
<p>Combine completed tasks:</p>
<pre><code class="language-json">{
  "jacsTaskMergedTasks": [
    "subtask-1-uuid",
    "subtask-2-uuid"
  ]
}
</code></pre>
<h2 id="task-workflow"><a class="header" href="#task-workflow">Task Workflow</a></h2>
<h3 id="1-creating-a-task"><a class="header" href="#1-creating-a-task">1. Creating a Task</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

task = agent.create_document(json.dumps({
    'jacsTaskName': 'Build Feature X',
    'jacsTaskSuccess': 'Feature is deployed and tested',
    'jacsTaskState': 'creating',
    'jacsTaskActionsDesired': [
        {
            'name': 'Implementation',
            'description': 'Write the code',
            'completionAgreementRequired': True
        }
    ]
}), custom_schema='https://hai.ai/schemas/task/v1/task.schema.json')
</code></pre>
<h3 id="2-assigning-an-agent"><a class="header" href="#2-assigning-an-agent">2. Assigning an Agent</a></h3>
<p>When an agent accepts the task, add their signature to <code>jacsTaskAgent</code> and update state to <code>started</code>.</p>
<h3 id="3-signing-start-agreement"><a class="header" href="#3-signing-start-agreement">3. Signing Start Agreement</a></h3>
<p>Both parties sign the start agreement to confirm work begins.</p>
<h3 id="4-completing-work"><a class="header" href="#4-completing-work">4. Completing Work</a></h3>
<p>Update state to <code>review</code>, then both parties sign the end agreement.</p>
<h3 id="5-final-completion"><a class="header" href="#5-final-completion">5. Final Completion</a></h3>
<p>After end agreement is signed by all parties, update state to <code>completed</code>.</p>
<h2 id="state-machine-rules"><a class="header" href="#state-machine-rules">State Machine Rules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Current State</th><th>Valid Next States</th></tr></thead><tbody>
<tr><td><code>creating</code></td><td><code>rfp</code></td></tr>
<tr><td><code>rfp</code></td><td><code>proposal</code>, <code>creating</code></td></tr>
<tr><td><code>proposal</code></td><td><code>negotiation</code>, <code>rfp</code></td></tr>
<tr><td><code>negotiation</code></td><td><code>started</code>, <code>proposal</code></td></tr>
<tr><td><code>started</code></td><td><code>review</code></td></tr>
<tr><td><code>review</code></td><td><code>completed</code>, <code>started</code></td></tr>
<tr><td><code>completed</code></td><td>(terminal)</td></tr>
</tbody></table>
</div>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="schemas/document.html">Document Schema</a> - Base document fields</li>
<li><a href="schemas/agent.html">Agent Schema</a> - Agent structure</li>
<li><a href="schemas/../rust/agreements.html">Agreements</a> - Working with agreements</li>
<li><a href="schemas/overview.html">JSON Schemas Overview</a> - Schema architecture</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agent-state-schema"><a class="header" href="#agent-state-schema">Agent State Schema</a></h1>
<p>The Agent State Schema defines the structure for signed agent state documents in JACS. Agent state documents wrap and cryptographically sign any agent configuration file -- memory files, skills, plans, configs, hooks, or any other document an agent wants to verify.</p>
<h2 id="schema-location-3"><a class="header" href="#schema-location-3">Schema Location</a></h2>
<pre><code>https://hai.ai/schemas/agentstate/v1/agentstate.schema.json
</code></pre>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>Agent state documents provide:</p>
<ul>
<li><strong>Signed state files</strong>: Cryptographically sign MEMORY.md, skill files, plans, configs, hooks, or any file</li>
<li><strong>File integrity</strong>: SHA-256 hashes verify file contents haven't been tampered with</li>
<li><strong>Origin tracking</strong>: Record whether state was authored, adopted, generated, or imported</li>
<li><strong>Framework tagging</strong>: Identify which agent framework (claude-code, langchain, etc.) the state belongs to</li>
<li><strong>General-purpose signing</strong>: Use type <code>other</code> to sign any document an agent wants to verify</li>
</ul>
<p>All documents are stored within the JACS data directory for security.</p>
<h2 id="schema-structure-2"><a class="header" href="#schema-structure-2">Schema Structure</a></h2>
<p>The agent state schema extends the <a href="schemas/document.html">Header Schema</a>:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://hai.ai/schemas/agentstate/v1/agentstate.schema.json",
  "title": "Agent State Document",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" }
  ],
  "properties": {
    "jacsAgentStateType": {
      "type": "string",
      "enum": ["memory", "skill", "plan", "config", "hook", "other"]
    },
    "jacsAgentStateName": { "type": "string" }
  },
  "required": ["jacsAgentStateType", "jacsAgentStateName"]
}
</code></pre>
<h2 id="state-types"><a class="header" href="#state-types">State Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>memory</code></td><td>Agent memory/knowledge files</td><td>MEMORY.md, context files</td></tr>
<tr><td><code>skill</code></td><td>Agent skill definitions</td><td>Coding patterns, domain knowledge</td></tr>
<tr><td><code>plan</code></td><td>Agent plans and strategies</td><td>Implementation plans, workflows</td></tr>
<tr><td><code>config</code></td><td>Agent configuration files</td><td>Settings, preferences</td></tr>
<tr><td><code>hook</code></td><td>Agent hooks and triggers (always embedded)</td><td>Pre-commit hooks, event handlers</td></tr>
<tr><td><code>other</code></td><td>Any document the agent wants to sign and verify</td><td>Reports, artifacts, custom files</td></tr>
</tbody></table>
</div>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="required-fields-1"><a class="header" href="#required-fields-1">Required Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsAgentStateType</code></td><td>string (enum)</td><td>Type of agent state: memory, skill, plan, config, hook, other</td></tr>
<tr><td><code>jacsAgentStateName</code></td><td>string</td><td>Human-readable name for this state document</td></tr>
</tbody></table>
</div>
<h3 id="optional-fields"><a class="header" href="#optional-fields">Optional Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsAgentStateDescription</code></td><td>string</td><td>Description of what this state contains</td></tr>
<tr><td><code>jacsAgentStateFramework</code></td><td>string</td><td>Agent framework (e.g., "claude-code", "langchain")</td></tr>
<tr><td><code>jacsAgentStateVersion</code></td><td>string</td><td>Content version (distinct from <code>jacsVersion</code>)</td></tr>
<tr><td><code>jacsAgentStateContentType</code></td><td>string</td><td>MIME type (text/markdown, application/json, etc.)</td></tr>
<tr><td><code>jacsAgentStateContent</code></td><td>string</td><td>Inline content (used when embedding)</td></tr>
<tr><td><code>jacsAgentStateTags</code></td><td>string[]</td><td>Tags for categorization and search</td></tr>
<tr><td><code>jacsAgentStateOrigin</code></td><td>string (enum)</td><td>How created: authored, adopted, generated, imported</td></tr>
<tr><td><code>jacsAgentStateSourceUrl</code></td><td>string (uri)</td><td>Where content was obtained from</td></tr>
</tbody></table>
</div>
<h2 id="origin-tracking"><a class="header" href="#origin-tracking">Origin Tracking</a></h2>
<p>Every agent state document can track its provenance:</p>
<div class="table-wrapper"><table><thead><tr><th>Origin</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>authored</code></td><td>Created by the signing agent</td></tr>
<tr><td><code>adopted</code></td><td>Found unsigned, signed by adopting agent</td></tr>
<tr><td><code>generated</code></td><td>Produced by AI/automation</td></tr>
<tr><td><code>imported</code></td><td>Brought from another JACS installation</td></tr>
</tbody></table>
</div>
<h2 id="file-references"><a class="header" href="#file-references">File References</a></h2>
<p>Agent state documents can reference external files using <code>jacsFiles</code>:</p>
<pre><code class="language-json">{
  "jacsFiles": [
    {
      "mimetype": "text/markdown",
      "path": "MEMORY.md",
      "embed": true,
      "sha256": "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9",
      "contents": "base64-encoded-gzipped-content"
    }
  ]
}
</code></pre>
<p>When <code>embed</code> is <code>true</code>, the file content is stored inline in the document. <strong>Hook-type documents always embed content</strong> for security (prevents time-of-check/time-of-use attacks).</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="minimal-agent-state"><a class="header" href="#minimal-agent-state">Minimal Agent State</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agentstate/v1/agentstate.schema.json",
  "jacsAgentStateType": "memory",
  "jacsAgentStateName": "Project Memory",
  "jacsType": "agentstate",
  "jacsLevel": "config"
}
</code></pre>
<h3 id="memory-file-with-embedding"><a class="header" href="#memory-file-with-embedding">Memory File with Embedding</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agentstate/v1/agentstate.schema.json",
  "jacsAgentStateType": "memory",
  "jacsAgentStateName": "JACS Project Memory",
  "jacsAgentStateDescription": "Agent memory for the JACS project workspace",
  "jacsAgentStateFramework": "claude-code",
  "jacsAgentStateOrigin": "authored",
  "jacsAgentStateContentType": "text/markdown",
  "jacsAgentStateContent": "# MEMORY.md\n\n## Project: JACS\n- Location: /home/agent/jacs\n- Rust library for cryptographic signing\n",
  "jacsAgentStateTags": ["jacs", "rust", "crypto"],
  "jacsType": "agentstate",
  "jacsLevel": "config"
}
</code></pre>
<h3 id="adopted-skill"><a class="header" href="#adopted-skill">Adopted Skill</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agentstate/v1/agentstate.schema.json",
  "jacsAgentStateType": "skill",
  "jacsAgentStateName": "JSON Schema Validation",
  "jacsAgentStateOrigin": "adopted",
  "jacsAgentStateSourceUrl": "https://agentskills.io/skills/json-schema",
  "jacsAgentStateVersion": "2.1.0",
  "jacsType": "agentstate",
  "jacsLevel": "config"
}
</code></pre>
<h3 id="general-purpose-signed-document"><a class="header" href="#general-purpose-signed-document">General-Purpose Signed Document</a></h3>
<p>Use type <code>other</code> to sign any document:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/agentstate/v1/agentstate.schema.json",
  "jacsAgentStateType": "other",
  "jacsAgentStateName": "Q1 Financial Report",
  "jacsAgentStateDescription": "Quarterly financial summary for verification",
  "jacsAgentStateContentType": "application/json",
  "jacsAgentStateContent": "{\"revenue\": 150000, \"expenses\": 120000}",
  "jacsType": "agentstate",
  "jacsLevel": "config"
}
</code></pre>
<h2 id="rust-api"><a class="header" href="#rust-api">Rust API</a></h2>
<h3 id="creating-agent-state-documents"><a class="header" href="#creating-agent-state-documents">Creating Agent State Documents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::schema::agentstate_crud::*;

// Minimal state
let doc = create_minimal_agentstate("memory", "Project Memory", Some("Agent memory file"))?;

// With file reference
let doc = create_agentstate_with_file("skill", "Rust Patterns", "./skills/rust.md", true)?;

// With inline content
let doc = create_agentstate_with_content(
    "config",
    "Agent Settings",
    "{\"theme\": \"dark\"}",
    "application/json"
)?;

// General-purpose signing
let doc = create_agentstate_with_content(
    "other",
    "Audit Report",
    "Report contents here...",
    "text/plain"
)?;

// Set metadata
let mut doc = create_minimal_agentstate("memory", "My Memory", None)?;
set_agentstate_framework(&amp;mut doc, "claude-code")?;
set_agentstate_origin(&amp;mut doc, "authored", None)?;
set_agentstate_tags(&amp;mut doc, vec!["project", "notes"])?;
set_agentstate_version(&amp;mut doc, "1.0.0")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="signing-and-verification-3"><a class="header" href="#signing-and-verification-3">Signing and Verification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create, sign, and store
let doc_string = serde_json::to_string(&amp;doc)?;
let signed_doc = agent.create_document_and_load(&amp;doc_string, None, None)?;

// Verify file integrity
let hash_valid = verify_agentstate_file_hash(&amp;doc)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="mcp-tools"><a class="header" href="#mcp-tools">MCP Tools</a></h2>
<p>Six MCP tools are available for agent state operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs_sign_state</code></td><td>Create and sign a new agent state document</td></tr>
<tr><td><code>jacs_verify_state</code></td><td>Verify an existing agent state document's signature</td></tr>
<tr><td><code>jacs_load_state</code></td><td>Load an agent state document by key</td></tr>
<tr><td><code>jacs_update_state</code></td><td>Update and re-sign an agent state document</td></tr>
<tr><td><code>jacs_list_state</code></td><td>List all agent state documents</td></tr>
<tr><td><code>jacs_adopt_state</code></td><td>Adopt an external file as a signed agent state</td></tr>
</tbody></table>
</div>
<h3 id="mcp-example-sign-a-memory-file"><a class="header" href="#mcp-example-sign-a-memory-file">MCP Example: Sign a Memory File</a></h3>
<pre><code class="language-json">{
  "tool": "jacs_sign_state",
  "arguments": {
    "state_type": "memory",
    "name": "Project Memory",
    "content": "# My Agent Memory\n\nKey facts about the project...",
    "content_type": "text/markdown",
    "framework": "claude-code",
    "tags": ["project", "memory"]
  }
}
</code></pre>
<h3 id="mcp-example-sign-any-document"><a class="header" href="#mcp-example-sign-any-document">MCP Example: Sign Any Document</a></h3>
<pre><code class="language-json">{
  "tool": "jacs_sign_state",
  "arguments": {
    "state_type": "other",
    "name": "Verification Report",
    "content": "{\"status\": \"passed\", \"checks\": 42}",
    "content_type": "application/json"
  }
}
</code></pre>
<h2 id="security-notes"><a class="header" href="#security-notes">Security Notes</a></h2>
<ul>
<li>All agent state documents are stored within the JACS data directory for security</li>
<li>Hook-type documents always embed content to prevent TOCTOU attacks</li>
<li>File hashes (SHA-256) are verified on load to detect tampering</li>
<li>Origin tracking provides provenance auditing</li>
<li>Documents are signed with the agent's private key, providing non-repudiation</li>
</ul>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="schemas/overview.html">JSON Schemas</a> - Schema architecture overview</li>
<li><a href="schemas/../rust/documents.html">Working with Documents</a> - General document operations</li>
<li><a href="schemas/../integrations/mcp.html">MCP Integration</a> - MCP server setup</li>
<li><a href="schemas/../advanced/security.html">Security Model</a> - Cryptographic details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitment-schema"><a class="header" href="#commitment-schema">Commitment Schema</a></h1>
<p>Commitments are shared, signed agreements between agents. They represent what an agent commits to doing, optionally within a conversation or linked to a task or todo item.</p>
<p><strong>Key design</strong>: Commitments work standalone. They do not require goals, tasks, conversations, or any other document type to be created first.</p>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<ul>
<li><strong>ID</strong>: <code>https://hai.ai/schemas/commitment/v1/commitment.schema.json</code></li>
<li><strong>Type</strong>: <code>jacsType: "commitment"</code></li>
<li><strong>Level</strong>: <code>jacsLevel: "config"</code> (editable, versioned)</li>
<li><strong>Extends</strong>: <code>header.schema.json</code> via <code>allOf</code></li>
</ul>
<h2 id="required-fields-2"><a class="header" href="#required-fields-2">Required Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsCommitmentDescription</code></td><td>string</td><td>Human-readable description of the commitment</td></tr>
<tr><td><code>jacsCommitmentStatus</code></td><td>enum</td><td>Lifecycle status</td></tr>
</tbody></table>
</div>
<h2 id="status-lifecycle"><a class="header" href="#status-lifecycle">Status Lifecycle</a></h2>
<pre><code>pending -&gt; active -&gt; completed
                  -&gt; failed
                  -&gt; renegotiated
         -&gt; disputed
         -&gt; revoked
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>pending</code></td><td>Created but not yet started</td></tr>
<tr><td><code>active</code></td><td>Work is underway</td></tr>
<tr><td><code>completed</code></td><td>Successfully fulfilled</td></tr>
<tr><td><code>failed</code></td><td>Could not be fulfilled</td></tr>
<tr><td><code>renegotiated</code></td><td>Terms changed, replaced by new commitment</td></tr>
<tr><td><code>disputed</code></td><td>One party contests the commitment</td></tr>
<tr><td><code>revoked</code></td><td>Withdrawn by the owner</td></tr>
</tbody></table>
</div>
<h2 id="optional-fields-1"><a class="header" href="#optional-fields-1">Optional Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsCommitmentTerms</code></td><td>object</td><td>Structured terms (deliverable, deadline, compensation, etc.)</td></tr>
<tr><td><code>jacsCommitmentDisputeReason</code></td><td>string</td><td>Reason when status is <code>disputed</code> or <code>revoked</code></td></tr>
<tr><td><code>jacsCommitmentTaskId</code></td><td>uuid</td><td>Reference to a task document</td></tr>
<tr><td><code>jacsCommitmentConversationRef</code></td><td>uuid</td><td>Thread ID of the conversation that produced this commitment</td></tr>
<tr><td><code>jacsCommitmentTodoRef</code></td><td>string</td><td>Todo item reference in format <code>list-uuid:item-uuid</code></td></tr>
<tr><td><code>jacsCommitmentQuestion</code></td><td>string</td><td>Structured question prompt</td></tr>
<tr><td><code>jacsCommitmentAnswer</code></td><td>string</td><td>Answer to the question</td></tr>
<tr><td><code>jacsCommitmentCompletionQuestion</code></td><td>string</td><td>Question to verify completion</td></tr>
<tr><td><code>jacsCommitmentCompletionAnswer</code></td><td>string</td><td>Answer verifying completion</td></tr>
<tr><td><code>jacsCommitmentStartDate</code></td><td>date-time</td><td>When the commitment period begins</td></tr>
<tr><td><code>jacsCommitmentEndDate</code></td><td>date-time</td><td>Deadline</td></tr>
<tr><td><code>jacsCommitmentRecurrence</code></td><td>object</td><td>Recurrence pattern (<code>frequency</code> + <code>interval</code>)</td></tr>
<tr><td><code>jacsCommitmentOwner</code></td><td>signature</td><td>Single-agent owner signature</td></tr>
</tbody></table>
</div>
<h2 id="cross-references"><a class="header" href="#cross-references">Cross-References</a></h2>
<p>Commitments can link to other document types:</p>
<ul>
<li><strong>Conversation</strong>: <code>jacsCommitmentConversationRef</code> holds a thread UUID</li>
<li><strong>Todo item</strong>: <code>jacsCommitmentTodoRef</code> uses format <code>list-uuid:item-uuid</code></li>
<li><strong>Task</strong>: <code>jacsCommitmentTaskId</code> holds a task document UUID</li>
</ul>
<p>These references are optional. Commitments work independently.</p>
<h2 id="multi-agent-agreements"><a class="header" href="#multi-agent-agreements">Multi-Agent Agreements</a></h2>
<p>Commitments use the standard JACS agreement mechanism from the header schema. Two or more agents can co-sign a commitment using <code>jacsAgreement</code>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/commitment/v1/commitment.schema.json",
  "jacsCommitmentDescription": "Deliver Q1 analytics report by March 15",
  "jacsCommitmentStatus": "active",
  "jacsCommitmentTerms": {
    "deliverable": "PDF report with charts",
    "deadline": "2026-03-15T00:00:00Z"
  },
  "jacsCommitmentStartDate": "2026-01-15T00:00:00Z",
  "jacsCommitmentEndDate": "2026-03-15T00:00:00Z",
  "jacsType": "commitment",
  "jacsLevel": "config"
}
</code></pre>
<h2 id="rust-api-1"><a class="header" href="#rust-api-1">Rust API</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::schema::commitment_crud::*;

// Create
let commitment = create_minimal_commitment("Deliver report").unwrap();

// With structured terms
let commitment = create_commitment_with_terms(
    "Weekly standup",
    serde_json::json!({"frequency": "weekly"}),
).unwrap();

// Update status
update_commitment_status(&amp;mut commitment, "active").unwrap();

// Dispute
dispute_commitment(&amp;mut commitment, "Terms not met").unwrap();

// Cross-references
set_conversation_ref(&amp;mut commitment, &amp;thread_id).unwrap();
set_todo_ref(&amp;mut commitment, "list-uuid:item-uuid").unwrap();
set_task_ref(&amp;mut commitment, &amp;task_id).unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="versioning-2"><a class="header" href="#versioning-2">Versioning</a></h2>
<p>Since commitments use <code>jacsLevel: "config"</code>, they can be updated. Each update creates a new <code>jacsVersion</code> linked to the previous via <code>jacsPreviousVersion</code>. This provides a full audit trail of status changes and modifications.</p>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="schemas/todo.html">Todo List Schema</a> - Private task tracking</li>
<li><a href="schemas/conversation.html">Conversation Schema</a> - Message threading</li>
<li><a href="schemas/document.html">Document Schema</a> - Header fields and signing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-list-schema"><a class="header" href="#todo-list-schema">Todo List Schema</a></h1>
<p>Todo lists are private, signed documents belonging to a single agent. They contain inline items (goals and tasks) and are re-signed as a whole when any item changes.</p>
<h2 id="schema-1"><a class="header" href="#schema-1">Schema</a></h2>
<ul>
<li><strong>ID</strong>: <code>https://hai.ai/schemas/todo/v1/todo.schema.json</code></li>
<li><strong>Type</strong>: <code>jacsType: "todo"</code></li>
<li><strong>Level</strong>: <code>jacsLevel: "config"</code> (editable, versioned)</li>
<li><strong>Extends</strong>: <code>header.schema.json</code> via <code>allOf</code></li>
<li><strong>Component</strong>: <code>todoitem.schema.json</code> for inline items</li>
</ul>
<h2 id="required-fields-3"><a class="header" href="#required-fields-3">Required Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsTodoName</code></td><td>string</td><td>Human-readable name for this list</td></tr>
<tr><td><code>jacsTodoItems</code></td><td>array</td><td>Inline todo items</td></tr>
</tbody></table>
</div>
<h2 id="optional-fields-2"><a class="header" href="#optional-fields-2">Optional Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacsTodoArchiveRefs</code></td><td>uuid[]</td><td>UUIDs of archived todo lists</td></tr>
</tbody></table>
</div>
<h2 id="todo-items"><a class="header" href="#todo-items">Todo Items</a></h2>
<p>Each item in <code>jacsTodoItems</code> is an inline object following <code>todoitem.schema.json</code>.</p>
<h3 id="required-item-fields"><a class="header" href="#required-item-fields">Required Item Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>itemId</code></td><td>uuid</td><td>Stable UUID that does not change on re-signing</td></tr>
<tr><td><code>itemType</code></td><td>enum</td><td><code>"goal"</code> (broad objective) or <code>"task"</code> (specific action)</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Human-readable description</td></tr>
<tr><td><code>status</code></td><td>enum</td><td><code>"pending"</code>, <code>"in-progress"</code>, <code>"completed"</code>, <code>"abandoned"</code></td></tr>
</tbody></table>
</div>
<h3 id="optional-item-fields"><a class="header" href="#optional-item-fields">Optional Item Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>priority</code></td><td>enum</td><td><code>"low"</code>, <code>"medium"</code>, <code>"high"</code>, <code>"critical"</code></td></tr>
<tr><td><code>childItemIds</code></td><td>uuid[]</td><td>Sub-goals or tasks under this item</td></tr>
<tr><td><code>relatedCommitmentId</code></td><td>uuid</td><td>Commitment that formalizes this item</td></tr>
<tr><td><code>relatedConversationThread</code></td><td>uuid</td><td>Conversation thread related to this item</td></tr>
<tr><td><code>completedDate</code></td><td>date-time</td><td>When the item was completed</td></tr>
<tr><td><code>assignedAgent</code></td><td>uuid</td><td>Agent assigned to this item</td></tr>
<tr><td><code>tags</code></td><td>string[]</td><td>Tags for categorization</td></tr>
</tbody></table>
</div>
<h2 id="cross-references-1"><a class="header" href="#cross-references-1">Cross-References</a></h2>
<p>Todo items can link to other document types:</p>
<ul>
<li><strong>Commitment</strong>: <code>relatedCommitmentId</code> links an item to a commitment</li>
<li><strong>Conversation</strong>: <code>relatedConversationThread</code> links an item to a message thread</li>
</ul>
<p>References use the <code>list-uuid:item-uuid</code> format when referenced FROM other documents (e.g., <code>jacsCommitmentTodoRef</code> on a commitment). Use <code>build_todo_item_ref()</code> and <code>parse_todo_item_ref()</code> from <code>reference_utils</code> for this format.</p>
<h2 id="item-hierarchy"><a class="header" href="#item-hierarchy">Item Hierarchy</a></h2>
<p>Items support parent-child relationships via <code>childItemIds</code>:</p>
<pre><code>Goal: "Ship Q1 release"
  ‚îú‚îÄ‚îÄ Task: "Write documentation"
  ‚îú‚îÄ‚îÄ Task: "Run integration tests"
  ‚îî‚îÄ‚îÄ Goal: "Performance optimization"
       ‚îú‚îÄ‚îÄ Task: "Profile database queries"
       ‚îî‚îÄ‚îÄ Task: "Add caching layer"
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/todo/v1/todo.schema.json",
  "jacsTodoName": "Q1 Sprint",
  "jacsTodoItems": [
    {
      "itemId": "550e8400-e29b-41d4-a716-446655440001",
      "itemType": "goal",
      "description": "Ship analytics dashboard",
      "status": "in-progress",
      "priority": "high",
      "childItemIds": [
        "550e8400-e29b-41d4-a716-446655440002"
      ]
    },
    {
      "itemId": "550e8400-e29b-41d4-a716-446655440002",
      "itemType": "task",
      "description": "Build chart components",
      "status": "pending",
      "priority": "medium",
      "relatedCommitmentId": "660e8400-e29b-41d4-a716-446655440000",
      "tags": ["frontend", "charts"]
    }
  ],
  "jacsType": "todo",
  "jacsLevel": "config"
}
</code></pre>
<h2 id="rust-api-2"><a class="header" href="#rust-api-2">Rust API</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::schema::todo_crud::*;

// Create a list
let mut list = create_minimal_todo_list("Sprint Work").unwrap();

// Add items
let goal_id = add_todo_item(&amp;mut list, "goal", "Ship Q1", Some("high")).unwrap();
let task_id = add_todo_item(&amp;mut list, "task", "Write tests", None).unwrap();

// Build hierarchy
add_child_to_item(&amp;mut list, &amp;goal_id, &amp;task_id).unwrap();

// Progress tracking
update_todo_item_status(&amp;mut list, &amp;task_id, "in-progress").unwrap();
mark_todo_item_complete(&amp;mut list, &amp;task_id).unwrap();

// Cross-references
set_item_commitment_ref(&amp;mut list, &amp;task_id, &amp;commitment_id).unwrap();
set_item_conversation_ref(&amp;mut list, &amp;task_id, &amp;thread_id).unwrap();

// Archive completed items
let completed = remove_completed_items(&amp;mut list).unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="versioning-3"><a class="header" href="#versioning-3">Versioning</a></h2>
<p>Since todo lists use <code>jacsLevel: "config"</code>, each modification creates a new signed version. The <code>itemId</code> fields remain stable across versions, enabling consistent cross-referencing even as items are added, updated, or removed.</p>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="schemas/commitment.html">Commitment Schema</a> - Shared agreements</li>
<li><a href="schemas/conversation.html">Conversation Schema</a> - Message threading</li>
<li><a href="schemas/document.html">Document Schema</a> - Header fields and signing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversation-schema"><a class="header" href="#conversation-schema">Conversation Schema</a></h1>
<p>Conversations use the existing message schema enhanced with thread tracking and message ordering. There is no separate "conversation" schema - conversations are sequences of signed messages sharing a thread ID.</p>
<h2 id="schema-2"><a class="header" href="#schema-2">Schema</a></h2>
<ul>
<li><strong>ID</strong>: <code>https://hai.ai/schemas/message/v1/message.schema.json</code></li>
<li><strong>Type</strong>: <code>jacsType: "message"</code></li>
<li><strong>Level</strong>: <code>jacsLevel: "raw"</code> (immutable once signed)</li>
<li><strong>Extends</strong>: <code>header.schema.json</code> via <code>allOf</code></li>
</ul>
<h2 id="message-fields"><a class="header" href="#message-fields">Message Fields</a></h2>
<h3 id="required"><a class="header" href="#required">Required</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>to</code></td><td>string[]</td><td>Recipient agent identifiers</td></tr>
<tr><td><code>from</code></td><td>string[]</td><td>Sender agent identifiers</td></tr>
<tr><td><code>content</code></td><td>object</td><td>Message body (free-form object)</td></tr>
</tbody></table>
</div>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>threadID</code></td><td>string</td><td>UUID of the conversation thread</td></tr>
<tr><td><code>jacsMessagePreviousId</code></td><td>uuid</td><td>UUID of the previous message in this thread</td></tr>
<tr><td><code>attachments</code></td><td>array</td><td>File attachments</td></tr>
</tbody></table>
</div>
<h2 id="threading-model"><a class="header" href="#threading-model">Threading Model</a></h2>
<p>Messages form a thread via two fields:</p>
<ol>
<li><strong><code>threadID</code></strong> - All messages in a conversation share the same thread ID</li>
<li><strong><code>jacsMessagePreviousId</code></strong> - Each message references the previous one, creating an ordered chain</li>
</ol>
<pre><code>Message 1 (threadID: "abc-123", previousId: null)
    ‚îî‚îÄ‚îÄ Message 2 (threadID: "abc-123", previousId: msg1.jacsId)
         ‚îî‚îÄ‚îÄ Message 3 (threadID: "abc-123", previousId: msg2.jacsId)
</code></pre>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>Messages use <code>jacsLevel: "raw"</code>, making them immutable once signed. To continue a conversation, create a new message referencing the previous one. This ensures the integrity of the conversation history.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/message/v1/message.schema.json",
  "threadID": "550e8400-e29b-41d4-a716-446655440000",
  "content": {
    "body": "I agree to the proposed terms.",
    "subject": "Re: Q1 Deliverables"
  },
  "to": ["agent-b-uuid"],
  "from": ["agent-a-uuid"],
  "jacsMessagePreviousId": "660e8400-e29b-41d4-a716-446655440001",
  "jacsType": "message",
  "jacsLevel": "raw"
}
</code></pre>
<h2 id="rust-api-3"><a class="header" href="#rust-api-3">Rust API</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::schema::conversation_crud::*;

// Start a new conversation (generates thread ID)
let (first_msg, thread_id) = start_new_conversation(
    serde_json::json!({"body": "Hello, let's discuss terms."}),
    vec!["agent-b".to_string()],
    vec!["agent-a".to_string()],
).unwrap();

// Continue the conversation
let reply = create_conversation_message(
    &amp;thread_id,
    serde_json::json!({"body": "Sounds good. Here are my terms."}),
    vec!["agent-a".to_string()],
    vec!["agent-b".to_string()],
    Some(&amp;previous_message_jacs_id),
).unwrap();

// Extract thread info
let tid = get_thread_id(&amp;message).unwrap();
let prev = get_previous_message_id(&amp;message);
<span class="boring">}</span></code></pre></pre>
<h2 id="cross-references-2"><a class="header" href="#cross-references-2">Cross-References</a></h2>
<p>Conversations can be referenced by other document types:</p>
<ul>
<li><strong>Commitment</strong>: <code>jacsCommitmentConversationRef</code> stores the thread UUID</li>
<li><strong>Todo item</strong>: <code>relatedConversationThread</code> stores the thread UUID</li>
</ul>
<p>This allows tracking which conversation led to a commitment or is related to a work item.</p>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="schemas/commitment.html">Commitment Schema</a> - Agreements arising from conversations</li>
<li><a href="schemas/todo.html">Todo List Schema</a> - Private task tracking</li>
<li><a href="schemas/document.html">Document Schema</a> - Header fields and signing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h1>
<p>The JACS configuration file (<code>jacs.config.json</code>) defines agent settings, key locations, storage backends, and observability options.</p>
<h2 id="schema-location-4"><a class="header" href="#schema-location-4">Schema Location</a></h2>
<pre><code>https://hai.ai/schemas/jacs.config.schema.json
</code></pre>
<h2 id="quick-start-8"><a class="header" href="#quick-start-8">Quick Start</a></h2>
<p>Create a minimal configuration file:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_private_key_filename": "private.pem",
  "jacs_agent_public_key_filename": "public.pem",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_default_storage": "fs"
}
</code></pre>
<h2 id="required-fields-4"><a class="header" href="#required-fields-4">Required Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs_data_directory</code></td><td>string</td><td>Path to store documents and agents</td></tr>
<tr><td><code>jacs_key_directory</code></td><td>string</td><td>Path to store cryptographic keys</td></tr>
<tr><td><code>jacs_agent_private_key_filename</code></td><td>string</td><td>Private key filename</td></tr>
<tr><td><code>jacs_agent_public_key_filename</code></td><td>string</td><td>Public key filename</td></tr>
<tr><td><code>jacs_agent_key_algorithm</code></td><td>string</td><td>Signing algorithm</td></tr>
<tr><td><code>jacs_default_storage</code></td><td>string</td><td>Storage backend</td></tr>
</tbody></table>
</div>
<h2 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h2>
<h3 id="key-configuration"><a class="header" href="#key-configuration">Key Configuration</a></h3>
<h4 id="jacs_agent_key_algorithm"><a class="header" href="#jacs_agent_key_algorithm">jacs_agent_key_algorithm</a></h4>
<p>Specifies the cryptographic algorithm for signing:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ring-Ed25519</code></td><td>Ed25519 signatures (recommended)</td></tr>
<tr><td><code>RSA-PSS</code></td><td>RSA with PSS padding</td></tr>
<tr><td><code>pq-dilithium</code></td><td>Post-quantum Dilithium</td></tr>
<tr><td><code>pq2025</code></td><td>Post-quantum composite</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<h4 id="jacs_agent_private_key_filename"><a class="header" href="#jacs_agent_private_key_filename">jacs_agent_private_key_filename</a></h4>
<p>Name of the private key file in the key directory:</p>
<pre><code class="language-json">{
  "jacs_agent_private_key_filename": "private.pem"
}
</code></pre>
<p>If the key is encrypted, it will have <code>.enc</code> appended automatically when loading.</p>
<h4 id="jacs_agent_public_key_filename"><a class="header" href="#jacs_agent_public_key_filename">jacs_agent_public_key_filename</a></h4>
<p>Name of the public key file:</p>
<pre><code class="language-json">{
  "jacs_agent_public_key_filename": "public.pem"
}
</code></pre>
<h4 id="jacs_private_key_password"><a class="header" href="#jacs_private_key_password">jacs_private_key_password</a></h4>
<p>Password for encrypted private keys:</p>
<pre><code class="language-json">{
  "jacs_private_key_password": "your-password"
}
</code></pre>
<p><strong>Warning</strong>: Do not store passwords in config files for production. Use the <code>JACS_PRIVATE_KEY_PASSWORD</code> environment variable instead.</p>
<h3 id="storage-configuration"><a class="header" href="#storage-configuration">Storage Configuration</a></h3>
<h4 id="jacs_default_storage"><a class="header" href="#jacs_default_storage">jacs_default_storage</a></h4>
<p>Specifies where documents are stored:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fs</code></td><td>Local filesystem</td></tr>
<tr><td><code>aws</code></td><td>AWS S3 storage</td></tr>
<tr><td><code>hai</code></td><td>HAI cloud storage</td></tr>
</tbody></table>
</div>
<pre><code class="language-json">{
  "jacs_default_storage": "fs"
}
</code></pre>
<h4 id="jacs_data_directory"><a class="header" href="#jacs_data_directory">jacs_data_directory</a></h4>
<p>Path for storing documents and agents:</p>
<pre><code class="language-json">{
  "jacs_data_directory": "./jacs_data"
}
</code></pre>
<h3 id="agent-identity-1"><a class="header" href="#agent-identity-1">Agent Identity</a></h3>
<h4 id="jacs_agent_id_and_version"><a class="header" href="#jacs_agent_id_and_version">jacs_agent_id_and_version</a></h4>
<p>Load an existing agent by ID and version:</p>
<pre><code class="language-json">{
  "jacs_agent_id_and_version": "550e8400-e29b-41d4-a716-446655440000:f47ac10b-58cc-4372-a567-0e02b2c3d479"
}
</code></pre>
<h3 id="schema-versions"><a class="header" href="#schema-versions">Schema Versions</a></h3>
<p>Specify which schema versions to use:</p>
<pre><code class="language-json">{
  "jacs_agent_schema_version": "v1",
  "jacs_header_schema_version": "v1",
  "jacs_signature_schema_version": "v1"
}
</code></pre>
<h3 id="dns-configuration"><a class="header" href="#dns-configuration">DNS Configuration</a></h3>
<p>For DNSSEC-based agent verification:</p>
<h4 id="jacs_agent_domain"><a class="header" href="#jacs_agent_domain">jacs_agent_domain</a></h4>
<p>Domain for DNS-based public key verification:</p>
<pre><code class="language-json">{
  "jacs_agent_domain": "example.com"
}
</code></pre>
<h4 id="jacs_dns_validate"><a class="header" href="#jacs_dns_validate">jacs_dns_validate</a></h4>
<p>Enable DNS TXT fingerprint validation:</p>
<pre><code class="language-json">{
  "jacs_dns_validate": true
}
</code></pre>
<h4 id="jacs_dns_strict"><a class="header" href="#jacs_dns_strict">jacs_dns_strict</a></h4>
<p>Require DNSSEC validation (no fallback):</p>
<pre><code class="language-json">{
  "jacs_dns_strict": true
}
</code></pre>
<h4 id="jacs_dns_required"><a class="header" href="#jacs_dns_required">jacs_dns_required</a></h4>
<p>Require domain and DNS validation:</p>
<pre><code class="language-json">{
  "jacs_dns_required": true
}
</code></pre>
<h3 id="security-2"><a class="header" href="#security-2">Security</a></h3>
<h4 id="jacs_use_security"><a class="header" href="#jacs_use_security">jacs_use_security</a></h4>
<p>Enable strict security features:</p>
<pre><code class="language-json">{
  "jacs_use_security": "1"
}
</code></pre>
<p>Values: <code>"0"</code>, <code>"1"</code>, or <code>"false"</code>, <code>"true"</code></p>
<h2 id="observability-configuration"><a class="header" href="#observability-configuration">Observability Configuration</a></h2>
<p>JACS supports comprehensive observability through logs, metrics, and tracing.</p>
<h3 id="logs-configuration"><a class="header" href="#logs-configuration">Logs Configuration</a></h3>
<pre><code class="language-json">{
  "observability": {
    "logs": {
      "enabled": true,
      "level": "info",
      "destination": {
        "type": "stderr"
      }
    }
  }
}
</code></pre>
<h4 id="log-levels-1"><a class="header" href="#log-levels-1">Log Levels</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Description</th></tr></thead><tbody>
<tr><td><code>trace</code></td><td>Most verbose</td></tr>
<tr><td><code>debug</code></td><td>Debug information</td></tr>
<tr><td><code>info</code></td><td>General information</td></tr>
<tr><td><code>warn</code></td><td>Warnings</td></tr>
<tr><td><code>error</code></td><td>Errors only</td></tr>
</tbody></table>
</div>
<h4 id="log-destinations-1"><a class="header" href="#log-destinations-1">Log Destinations</a></h4>
<p><strong>stderr</strong> (default):</p>
<pre><code class="language-json">{
  "destination": { "type": "stderr" }
}
</code></pre>
<p><strong>File</strong>:</p>
<pre><code class="language-json">{
  "destination": {
    "type": "file",
    "path": "/var/log/jacs/app.log"
  }
}
</code></pre>
<p><strong>OTLP</strong> (OpenTelemetry):</p>
<pre><code class="language-json">{
  "destination": {
    "type": "otlp",
    "endpoint": "http://localhost:4317",
    "headers": {
      "Authorization": "Bearer token"
    }
  }
}
</code></pre>
<p><strong>Null</strong> (disabled):</p>
<pre><code class="language-json">{
  "destination": { "type": "null" }
}
</code></pre>
<h3 id="metrics-configuration"><a class="header" href="#metrics-configuration">Metrics Configuration</a></h3>
<pre><code class="language-json">{
  "observability": {
    "metrics": {
      "enabled": true,
      "destination": {
        "type": "prometheus",
        "endpoint": "http://localhost:9090/api/v1/write"
      },
      "export_interval_seconds": 60
    }
  }
}
</code></pre>
<h4 id="metrics-destinations-1"><a class="header" href="#metrics-destinations-1">Metrics Destinations</a></h4>
<p><strong>Prometheus</strong>:</p>
<pre><code class="language-json">{
  "destination": {
    "type": "prometheus",
    "endpoint": "http://localhost:9090/api/v1/write"
  }
}
</code></pre>
<p><strong>OTLP</strong>:</p>
<pre><code class="language-json">{
  "destination": {
    "type": "otlp",
    "endpoint": "http://localhost:4317"
  }
}
</code></pre>
<p><strong>File</strong>:</p>
<pre><code class="language-json">{
  "destination": {
    "type": "file",
    "path": "/var/log/jacs/metrics.json"
  }
}
</code></pre>
<p><strong>stdout</strong>:</p>
<pre><code class="language-json">{
  "destination": { "type": "stdout" }
}
</code></pre>
<h3 id="tracing-configuration"><a class="header" href="#tracing-configuration">Tracing Configuration</a></h3>
<pre><code class="language-json">{
  "observability": {
    "tracing": {
      "enabled": true,
      "sampling": {
        "ratio": 0.1,
        "parent_based": true,
        "rate_limit": 100
      },
      "resource": {
        "service_name": "my-jacs-agent",
        "service_version": "1.0.0",
        "environment": "production",
        "attributes": {
          "team": "backend"
        }
      }
    }
  }
}
</code></pre>
<h4 id="sampling-options"><a class="header" href="#sampling-options">Sampling Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ratio</code></td><td>number (0-1)</td><td>Percentage of traces to sample</td></tr>
<tr><td><code>parent_based</code></td><td>boolean</td><td>Follow parent span's sampling decision</td></tr>
<tr><td><code>rate_limit</code></td><td>integer</td><td>Max traces per second</td></tr>
</tbody></table>
</div>
<h2 id="complete-configuration-example"><a class="header" href="#complete-configuration-example">Complete Configuration Example</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",

  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_private_key_filename": "private.pem",
  "jacs_agent_public_key_filename": "public.pem",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_default_storage": "fs",

  "jacs_agent_schema_version": "v1",
  "jacs_header_schema_version": "v1",
  "jacs_signature_schema_version": "v1",

  "jacs_agent_domain": "myagent.example.com",
  "jacs_dns_validate": true,
  "jacs_dns_strict": false,

  "observability": {
    "logs": {
      "enabled": true,
      "level": "info",
      "destination": {
        "type": "file",
        "path": "/var/log/jacs/agent.log"
      }
    },
    "metrics": {
      "enabled": true,
      "destination": {
        "type": "prometheus",
        "endpoint": "http://prometheus:9090/api/v1/write"
      },
      "export_interval_seconds": 30
    },
    "tracing": {
      "enabled": true,
      "sampling": {
        "ratio": 0.1,
        "parent_based": true
      },
      "resource": {
        "service_name": "jacs-agent",
        "service_version": "1.0.0",
        "environment": "production"
      }
    }
  }
}
</code></pre>
<h2 id="environment-variables-6"><a class="header" href="#environment-variables-6">Environment Variables</a></h2>
<p>Configuration can be overridden with environment variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Config Field</th></tr></thead><tbody>
<tr><td><code>JACS_PRIVATE_KEY_PASSWORD</code></td><td><code>jacs_private_key_password</code></td></tr>
<tr><td><code>JACS_DATA_DIRECTORY</code></td><td><code>jacs_data_directory</code></td></tr>
<tr><td><code>JACS_KEY_DIRECTORY</code></td><td><code>jacs_key_directory</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-bash">export JACS_PRIVATE_KEY_PASSWORD="secure-password"
</code></pre>
<h2 id="loading-configuration-1"><a class="header" href="#loading-configuration-1">Loading Configuration</a></h2>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<pre><code class="language-python">import jacs

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<h3 id="nodejs-2"><a class="header" href="#nodejs-2">Node.js</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');
</code></pre>
<h3 id="cli-1"><a class="header" href="#cli-1">CLI</a></h3>
<pre><code class="language-bash">jacs --config ./jacs.config.json agent show
</code></pre>
<h2 id="production-best-practices"><a class="header" href="#production-best-practices">Production Best Practices</a></h2>
<ol>
<li><strong>Never commit private keys</strong> - Keep keys out of version control</li>
<li><strong>Use environment variables for secrets</strong> - Don't store passwords in config files</li>
<li><strong>Enable observability</strong> - Configure logs and metrics for monitoring</li>
<li><strong>Use DNS validation</strong> - Enable <code>jacs_dns_validate</code> for additional security</li>
<li><strong>Secure key directories</strong> - Restrict file permissions on key directories</li>
</ol>
<pre><code class="language-bash">chmod 700 ./jacs_keys
chmod 600 ./jacs_keys/private.pem
</code></pre>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="schemas/overview.html">JSON Schemas Overview</a> - Schema architecture</li>
<li><a href="schemas/../rust/observability.html">Observability</a> - Monitoring guide</li>
<li><a href="schemas/../dns.html">DNS Verification</a> - Domain-based verification</li>
<li><a href="schemas/../getting-started/quickstart.html">Quick Start</a> - Getting started guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-model"><a class="header" href="#security-model">Security Model</a></h1>
<p>JACS implements a comprehensive security model designed to ensure authenticity, integrity, and non-repudiation for all agent communications and documents.</p>
<h2 id="security-model-v060"><a class="header" href="#security-model-v060">Security Model (v0.6.0)</a></h2>
<ul>
<li><strong>Passwords</strong>: The private key password must be set only via the <code>JACS_PRIVATE_KEY_PASSWORD</code> environment variable. It is never stored in config files.</li>
<li><strong>Keys</strong>: Private keys are encrypted at rest (AES-256-GCM with PBKDF2, 600k iterations). Public keys and config may be stored on disk.</li>
<li><strong>Path validation</strong>: All paths built from untrusted input (e.g. <code>publicKeyHash</code>, filenames) are validated via <code>require_relative_path_safe()</code> to prevent directory traversal. This single validation function is used in data and key directory path builders and the trust store. It rejects empty segments, <code>.</code>, <code>..</code>, null bytes, and Windows drive-prefixed paths.</li>
<li><strong>Trust ID canonicalization</strong>: Trust-store operations normalize canonical agent docs (<code>jacsId</code> + <code>jacsVersion</code>) into a safe <code>UUID:VERSION_UUID</code> identifier before filesystem use, preserving path-safety checks while supporting standard agent document layout.</li>
<li><strong>Filesystem schema policy</strong>: Local schema loading is disabled by default and requires <code>JACS_ALLOW_FILESYSTEM_SCHEMAS=true</code>. When enabled, schema paths must remain within configured roots (<code>JACS_DATA_DIRECTORY</code> and/or <code>JACS_SCHEMA_DIRECTORY</code>) after normalized/canonical path checks.</li>
<li><strong>Network endpoint policy</strong>: HAI registration verification requires HTTPS for <code>HAI_API_URL</code> (localhost HTTP is allowed for local testing only).</li>
<li><strong>No secrets in config</strong>: Config files must not contain passwords or other secrets. The example config (<code>jacs.config.example.json</code>) does not include <code>jacs_private_key_password</code>.</li>
<li><strong>Dependency auditing</strong>: Run <code>cargo audit</code> (Rust), <code>npm audit</code> (Node.js), or <code>pip audit</code> (Python) to check for known vulnerabilities.</li>
</ul>
<h2 id="core-security-principles"><a class="header" href="#core-security-principles">Core Security Principles</a></h2>
<h3 id="1-cryptographic-identity"><a class="header" href="#1-cryptographic-identity">1. Cryptographic Identity</a></h3>
<p>Every JACS agent has a unique cryptographic identity:</p>
<ul>
<li><strong>Key Pair</strong>: Each agent possesses a private/public key pair</li>
<li><strong>Agent ID</strong>: Unique UUID identifying the agent</li>
<li><strong>Public Key Hash</strong>: SHA-256 hash of the public key for verification</li>
</ul>
<pre><code class="language-json">{
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "publicKeyHash": "sha256-of-public-key",
    "signingAlgorithm": "ring-Ed25519"
  }
}
</code></pre>
<h3 id="2-document-integrity"><a class="header" href="#2-document-integrity">2. Document Integrity</a></h3>
<p>All documents include cryptographic guarantees:</p>
<ul>
<li><strong>Signature</strong>: Cryptographic signature over specified fields</li>
<li><strong>Hash</strong>: SHA-256 hash of document contents</li>
<li><strong>Version Tracking</strong>: Immutable version history</li>
</ul>
<h3 id="3-non-repudiation"><a class="header" href="#3-non-repudiation">3. Non-Repudiation</a></h3>
<p>Signatures provide proof of origin:</p>
<ul>
<li>Agents cannot deny signing a document</li>
<li>Timestamps record when signatures were made</li>
<li>Public keys enable independent verification</li>
</ul>
<h2 id="security-audit-audit"><a class="header" href="#security-audit-audit">Security Audit (<code>audit()</code>)</a></h2>
<p>JACS provides a read-only <strong>security audit</strong> that checks configuration, directories, secrets, trust store, storage, quarantine/failed files, and optionally re-verifies recent documents. It does not modify state.</p>
<p><strong>Purpose</strong>: Surface misconfiguration, missing keys, unexpected paths, and verification failures in one report.</p>
<p><strong>Options</strong> (all optional):</p>
<ul>
<li><code>config_path</code>: Path to <code>jacs.config.json</code> (default: 12-factor load)</li>
<li><code>data_directory</code> / <code>key_directory</code>: Override paths</li>
<li><code>recent_verify_count</code>: Number of recent documents to re-verify (default 10, max 100)</li>
</ul>
<p><strong>Return structure</strong>: <code>AuditResult</code> with <code>overall_status</code>, <code>risks</code> (list of <code>AuditRisk</code>), <code>health_checks</code> (list of <code>ComponentHealth</code>), <code>summary</code>, <code>checked_at</code>, and optional <code>quarantine_entries</code> / <code>failed_entries</code>.</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::audit::{audit, AuditOptions};

let result = audit(AuditOptions::default())?;
println!("{}", jacs::format_audit_report(&amp;result));
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">import jacs.simple as jacs

result = jacs.audit()  # dict with risks, health_checks, summary, overall_status
print(f"Risks: {len(result['risks'])}, Status: {result['overall_status']}")
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">import * as jacs from '@hai.ai/jacs/simple';

const result = jacs.audit({ recentN: 5 });
console.log(`Risks: ${result.risks.length}, Status: ${result.overall_status}`);
</code></pre>
<p>Available in all bindings and as an MCP tool (<code>jacs_audit</code>) for automation.</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="protected-against"><a class="header" href="#protected-against">Protected Against</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Threat</th><th>Protection</th></tr></thead><tbody>
<tr><td><strong>Tampering</strong></td><td>Content hashes detect modifications</td></tr>
<tr><td><strong>Impersonation</strong></td><td>Cryptographic signatures verify identity</td></tr>
<tr><td><strong>Replay Attacks</strong></td><td>Timestamps and version IDs ensure freshness; future timestamps rejected; optional signature expiration via <code>JACS_MAX_SIGNATURE_AGE_SECONDS</code></td></tr>
<tr><td><strong>Man-in-the-Middle</strong></td><td>DNS verification via DNSSEC; TLS certificate validation</td></tr>
<tr><td><strong>Key Compromise</strong></td><td>Key rotation through versioning</td></tr>
<tr><td><strong>Weak Passwords</strong></td><td>Minimum 28-bit entropy enforcement (35-bit for single class)</td></tr>
</tbody></table>
</div>
<h3 id="trust-assumptions"><a class="header" href="#trust-assumptions">Trust Assumptions</a></h3>
<ol>
<li>Private keys are kept secure</li>
<li>Cryptographic algorithms are sound</li>
<li>DNS infrastructure (when used) is trustworthy</li>
</ol>
<h2 id="signature-process-1"><a class="header" href="#signature-process-1">Signature Process</a></h2>
<h3 id="signing-a-document"><a class="header" href="#signing-a-document">Signing a Document</a></h3>
<ol>
<li><strong>Field Selection</strong>: Determine which fields to sign</li>
<li><strong>Canonicalization</strong>: Serialize fields deterministically</li>
<li><strong>Signature Generation</strong>: Sign with private key</li>
<li><strong>Hash Computation</strong>: Compute SHA-256 of signed document</li>
</ol>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create signed document
doc = agent.create_document(json.dumps({
    'title': 'Confidential Report',
    'content': 'Sensitive data here'
}))

# Document now includes jacsSignature and jacsSha256
</code></pre>
<h3 id="verifying-a-document"><a class="header" href="#verifying-a-document">Verifying a Document</a></h3>
<ol>
<li><strong>Hash Verification</strong>: Recompute hash and compare</li>
<li><strong>Signature Verification</strong>: Verify signature with public key</li>
<li><strong>Agent Verification</strong>: Optionally verify agent identity via DNS</li>
</ol>
<pre><code class="language-python">is_valid = agent.verify_document(doc_json)
is_signature_valid = agent.verify_signature(doc_json)
</code></pre>
<h2 id="key-management-2"><a class="header" href="#key-management-2">Key Management</a></h2>
<h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<p>JACS generates cryptographic key pairs during agent creation:</p>
<pre><code class="language-bash"># Keys are created in the configured key directory
jacs_keys/
‚îú‚îÄ‚îÄ private.pem    # Private key (keep secure!)
‚îî‚îÄ‚îÄ public.pem     # Public key (can be shared)
</code></pre>
<h3 id="key-protection"><a class="header" href="#key-protection">Key Protection</a></h3>
<p><strong>Encryption at Rest</strong>:</p>
<p>Private keys are encrypted using AES-256-GCM with a key derived via PBKDF2-HMAC-SHA256 (600,000 iterations). Never store the password in config files.</p>
<pre><code class="language-bash"># Set via environment variable only
export JACS_PRIVATE_KEY_PASSWORD="secure-password"
</code></pre>
<blockquote>
<p><strong>Important</strong>: The CLI can prompt for the password during <code>jacs init</code>, but scripts and servers must set <code>JACS_PRIVATE_KEY_PASSWORD</code> as an environment variable.</p>
</blockquote>
<p><strong>Password Entropy Requirements</strong>:</p>
<p>JACS enforces password entropy minimums for private key encryption. Password validation is performed at encryption time, and weak passwords are rejected with helpful error messages:</p>
<ul>
<li>Minimum <strong>28-bit entropy</strong> for passwords with 2+ character classes (mixed case, numbers, symbols)</li>
<li>Minimum <strong>35-bit entropy</strong> for single-character-class passwords (e.g., all lowercase)</li>
<li>Entropy is calculated based on character class diversity and length</li>
<li>Weak passwords result in immediate rejection during key encryption</li>
<li>Error messages guide users toward stronger password choices</li>
</ul>
<p>Example of rejected weak passwords:</p>
<ul>
<li><code>password</code> - Too common and predictable</li>
<li><code>12345678</code> - Insufficient character diversity</li>
<li><code>abc</code> - Too short</li>
</ul>
<p><strong>File Permissions</strong>:</p>
<pre><code class="language-bash">chmod 700 ./jacs_keys
chmod 600 ./jacs_keys/private.pem
</code></pre>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key Rotation</a></h3>
<p>Update agent version to rotate keys:</p>
<ol>
<li>Generate new key pair</li>
<li>Create new agent version</li>
<li>Sign new version with old key</li>
<li>Update configuration to use new keys</li>
</ol>
<h2 id="tls-certificate-validation"><a class="header" href="#tls-certificate-validation">TLS Certificate Validation</a></h2>
<p>JACS includes configurable TLS certificate validation for secure network communication.</p>
<h3 id="default-behavior-development"><a class="header" href="#default-behavior-development">Default Behavior (Development)</a></h3>
<p>By default, JACS warns about invalid TLS certificates but accepts them to facilitate development environments with self-signed certificates:</p>
<pre><code>WARNING: Invalid TLS certificate detected. Set JACS_STRICT_TLS=true for production.
</code></pre>
<h3 id="production-configuration"><a class="header" href="#production-configuration">Production Configuration</a></h3>
<p>For production deployments, enable strict TLS validation:</p>
<pre><code class="language-bash">export JACS_STRICT_TLS=true
</code></pre>
<p>When enabled, JACS will:</p>
<ul>
<li>Reject connections with invalid, expired, or self-signed certificates</li>
<li>Enforce proper certificate chain validation</li>
<li>Fail fast with clear error messages for certificate issues</li>
</ul>
<p><strong>Implementation</strong>: Certificate validation logic is located in <code>jacs/src/schema/utils.rs</code>.</p>
<h3 id="security-implications"><a class="header" href="#security-implications">Security Implications</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Behavior</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Default (dev)</td><td>Warn on invalid certs, allow connection</td><td>Local development, testing</td></tr>
<tr><td>Strict (<code>JACS_STRICT_TLS=true</code>)</td><td>Reject invalid certs</td><td>Production, staging</td></tr>
</tbody></table>
</div>
<p>For HAI registration verification endpoints, <code>HAI_API_URL</code> must use HTTPS. HTTP is only allowed for localhost test endpoints.</p>
<h2 id="signature-timestamp-validation"><a class="header" href="#signature-timestamp-validation">Signature Timestamp Validation</a></h2>
<p>JACS signatures include timestamps to prevent replay attacks and ensure temporal integrity.</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h3>
<ol>
<li><strong>Timestamp Inclusion</strong>: Every signature includes a UTC timestamp recording when it was created</li>
<li><strong>Future Timestamp Rejection</strong>: Signatures with timestamps more than 5 minutes in the future are rejected</li>
<li><strong>Optional Signature Expiration</strong>: Configurable via <code>JACS_MAX_SIGNATURE_AGE_SECONDS</code> (disabled by default since JACS documents are designed to be eternal)</li>
<li><strong>Validation</strong>: Timestamp validation occurs during signature verification</li>
</ol>
<h3 id="configuring-signature-expiration"><a class="header" href="#configuring-signature-expiration">Configuring Signature Expiration</a></h3>
<p>By default, signatures do not expire. JACS documents are designed to be idempotent and eternal. For use cases that require expiration:</p>
<pre><code class="language-bash"># Enable expiration (e.g., 90 days)
export JACS_MAX_SIGNATURE_AGE_SECONDS=7776000

# Default: no expiration (0)
export JACS_MAX_SIGNATURE_AGE_SECONDS=0
</code></pre>
<h3 id="protection-against-replay-attacks"><a class="header" href="#protection-against-replay-attacks">Protection Against Replay Attacks</a></h3>
<p>The 5-minute future tolerance window:</p>
<ul>
<li>Allows for reasonable clock skew between systems</li>
<li>Prevents attackers from creating signatures with future timestamps</li>
<li>Ensures signatures cannot be pre-generated for later fraudulent use</li>
</ul>
<pre><code class="language-json">{
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "signature": "...",
    "date": "2024-01-15T10:30:00Z"  // Must be within 5 min of verifier's clock
  }
}
</code></pre>
<h3 id="clock-synchronization"><a class="header" href="#clock-synchronization">Clock Synchronization</a></h3>
<p>For reliable timestamp validation across distributed systems:</p>
<ul>
<li>Ensure all agents use NTP or similar time synchronization</li>
<li>Monitor for clock drift in production environments</li>
<li>Consider the 5-minute tolerance when debugging verification failures</li>
</ul>
<h2 id="verification-claims"><a class="header" href="#verification-claims">Verification Claims</a></h2>
<p>Agents can claim a verification level that determines security requirements. This follows the principle: <strong>"If you claim it, you must prove it."</strong></p>
<h3 id="claim-levels"><a class="header" href="#claim-levels">Claim Levels</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Claim</th><th>Required Conditions</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>unverified</code> (default)</td><td>None</td><td>Relaxed DNS/TLS settings allowed; self-asserted identity</td></tr>
<tr><td><code>verified</code></td><td>Domain with DNSSEC</td><td>Strict TLS, strict DNS with DNSSEC validation required</td></tr>
<tr><td><code>verified-hai.ai</code></td><td>Above + HAI.ai registration</td><td>Must be registered and verified with HAI.ai</td></tr>
</tbody></table>
</div>
<h3 id="setting-a-verification-claim"><a class="header" href="#setting-a-verification-claim">Setting a Verification Claim</a></h3>
<p>Add the <code>jacsVerificationClaim</code> field to your agent definition:</p>
<pre><code class="language-json">{
  "jacsAgentType": "ai",
  "jacsVerificationClaim": "verified",
  "jacsAgentDomain": "myagent.example.com",
  "jacsServices": [...]
}
</code></pre>
<h3 id="claim-enforcement"><a class="header" href="#claim-enforcement">Claim Enforcement</a></h3>
<p>When an agent claims <code>verified</code> or <code>verified-hai.ai</code>:</p>
<ol>
<li><strong>Domain Required</strong>: The <code>jacsAgentDomain</code> field must be set</li>
<li><strong>Strict DNS</strong>: DNS lookup uses DNSSEC validation (no insecure fallback)</li>
<li><strong>DNS Required</strong>: Public key fingerprint must match DNS TXT record</li>
<li><strong>Strict TLS</strong>: TLS certificate validation is mandatory (no self-signed certs)</li>
</ol>
<p>For <code>verified-hai.ai</code> claims, additional enforcement:</p>
<ol start="5">
<li><strong>HAI.ai Registration</strong>: Agent must be registered at <a href="https://hai.ai">hai.ai</a></li>
<li><strong>Public Key Match</strong>: Registered public key must match the agent's key</li>
<li><strong>Network Required</strong>: Verification fails if HAI.ai API is unreachable</li>
</ol>
<h3 id="backward-compatibility"><a class="header" href="#backward-compatibility">Backward Compatibility</a></h3>
<ul>
<li>Agents without <code>jacsVerificationClaim</code> are treated as <code>unverified</code></li>
<li>Existing agents continue to work with their current DNS settings</li>
<li>No breaking changes for agents that don't opt into verified status</li>
</ul>
<h3 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h3>
<p>If verification fails, clear error messages explain what's wrong:</p>
<pre><code>Verification claim 'verified' failed: Verified agents must have jacsAgentDomain set.
Agents claiming 'verified' must meet the required security conditions.
</code></pre>
<pre><code>Verification claim 'verified-hai.ai' failed: Agent 'uuid' is not registered with HAI.ai.
Agents claiming 'verified-hai.ai' must be registered at https://hai.ai
</code></pre>
<h3 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h3>
<ol>
<li><strong>No Downgrade</strong>: Once an agent claims <code>verified</code>, it cannot be verified with relaxed settings</li>
<li><strong>Claim Changes</strong>: Changing the claim requires creating a new agent version</li>
<li><strong>Network Dependency</strong>: <code>verified-hai.ai</code> requires network access to HAI.ai</li>
<li><strong>Audit Trail</strong>: Verification claim and enforcement results are logged</li>
</ol>
<h2 id="dns-based-verification"><a class="header" href="#dns-based-verification">DNS-Based Verification</a></h2>
<p>JACS supports DNSSEC-validated identity verification:</p>
<h3 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h3>
<ol>
<li>Agent publishes public key fingerprint in DNS TXT record</li>
<li>Verifier queries DNS for <code>_v1.agent.jacs.&lt;domain&gt;.</code></li>
<li>DNSSEC validates the response authenticity</li>
<li>Fingerprint is compared against agent's public key</li>
</ol>
<h3 id="configuration-8"><a class="header" href="#configuration-8">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_agent_domain": "myagent.example.com",
  "jacs_dns_validate": true,
  "jacs_dns_strict": true
}
</code></pre>
<h3 id="security-levels"><a class="header" href="#security-levels">Security Levels</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs_dns_validate: false</code></td><td>No DNS verification</td></tr>
<tr><td><code>jacs_dns_validate: true</code></td><td>Attempt DNS verification, allow fallback</td></tr>
<tr><td><code>jacs_dns_strict: true</code></td><td>Require DNSSEC validation</td></tr>
<tr><td><code>jacs_dns_required: true</code></td><td>Fail if domain not present</td></tr>
</tbody></table>
</div>
<h2 id="trust-store-management"><a class="header" href="#trust-store-management">Trust Store Management</a></h2>
<p>JACS maintains a trust store for managing trusted agent relationships.</p>
<h3 id="trusting-agents"><a class="header" href="#trusting-agents">Trusting Agents</a></h3>
<p>Before trusting an agent, JACS performs public key hash verification:</p>
<pre><code class="language-python"># Trust an agent after verifying their public key hash
agent.trust_agent(agent_id, public_key_hash)
</code></pre>
<h3 id="untrusting-agents"><a class="header" href="#untrusting-agents">Untrusting Agents</a></h3>
<p>The <code>untrust_agent()</code> method properly handles the case when an agent is not in the trust store:</p>
<pre><code class="language-python">try:
    agent.untrust_agent(agent_id)
except AgentNotTrusted as e:
    # Agent was not in the trust store
    print(f"Agent {agent_id} was not trusted: {e}")
</code></pre>
<h3 id="trust-store-security"><a class="header" href="#trust-store-security">Trust Store Security</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Validation</th></tr></thead><tbody>
<tr><td><code>trust_agent()</code></td><td>UUID format validation, path traversal rejection, public key hash verification, self-signature verification before adding</td></tr>
<tr><td><code>untrust_agent()</code></td><td>UUID format validation, path containment check, returns <code>AgentNotTrusted</code> error if agent not found</td></tr>
<tr><td><code>get_trusted_agent()</code></td><td>UUID format validation, path containment check</td></tr>
<tr><td><code>is_trusted()</code></td><td>UUID format validation, safe lookup without side effects</td></tr>
<tr><td>Key cache (<code>load_public_key_from_cache</code>)</td><td><code>require_relative_path_safe()</code> rejects traversal in <code>publicKeyHash</code></td></tr>
<tr><td>Key cache (<code>save_public_key_to_cache</code>)</td><td><code>require_relative_path_safe()</code> rejects traversal in <code>publicKeyHash</code></td></tr>
</tbody></table>
</div>
<p><strong>Path Traversal Protection (v0.6.0)</strong>: All trust store operations that construct file paths from agent IDs or key hashes use defense-in-depth:</p>
<ol>
<li><strong>UUID format validation</strong>: Agent IDs must match <code>UUID:UUID</code> format (rejects special characters)</li>
<li><strong>Path character rejection</strong>: Explicit rejection of <code>..</code>, <code>/</code>, <code>\</code>, and null bytes</li>
<li><strong>Path containment check</strong>: For existing files, canonicalized paths are verified to stay within the trust store directory</li>
<li><strong><code>require_relative_path_safe()</code></strong>: Key hashes are validated to prevent traversal before constructing cache file paths</li>
</ol>
<h3 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h3>
<ol>
<li><strong>Verify Before Trust</strong>: Always verify an agent's public key hash through an out-of-band channel before trusting</li>
<li><strong>Audit Trust Changes</strong>: Log all trust store modifications for security auditing</li>
<li><strong>Periodic Review</strong>: Regularly review and prune the trust store</li>
</ol>
<h2 id="agreement-security"><a class="header" href="#agreement-security">Agreement Security</a></h2>
<p>Multi-party agreements provide additional security:</p>
<h3 id="agreement-structure-2"><a class="header" href="#agreement-structure-2">Agreement Structure</a></h3>
<pre><code class="language-json">{
  "jacsAgreement": {
    "agentIDs": ["agent-1", "agent-2", "agent-3"],
    "signatures": [
      {
        "agentID": "agent-1",
        "signature": "...",
        "responseType": "agree",
        "date": "2024-01-15T10:00:00Z"
      }
    ]
  },
  "jacsAgreementHash": "hash-at-agreement-time"
}
</code></pre>
<h3 id="agreement-guarantees"><a class="header" href="#agreement-guarantees">Agreement Guarantees</a></h3>
<ol>
<li><strong>Content Lock</strong>: <code>jacsAgreementHash</code> ensures all parties agreed to same content</li>
<li><strong>Individual Consent</strong>: Each signature records explicit agreement</li>
<li><strong>Response Types</strong>: Support for agree, disagree, or reject</li>
<li><strong>Timestamp</strong>: Records when each party signed</li>
</ol>
<h2 id="requestresponse-security"><a class="header" href="#requestresponse-security">Request/Response Security</a></h2>
<p>For MCP and HTTP communication:</p>
<h3 id="request-signing"><a class="header" href="#request-signing">Request Signing</a></h3>
<pre><code class="language-python">signed_request = agent.sign_request({
    'method': 'tools/call',
    'params': {'name': 'echo', 'arguments': {'text': 'hello'}}
})
</code></pre>
<p>The signed request includes:</p>
<ul>
<li>Full JACS document structure</li>
<li>Agent signature</li>
<li>Timestamp</li>
<li>Content hash</li>
</ul>
<h3 id="response-verification"><a class="header" href="#response-verification">Response Verification</a></h3>
<pre><code class="language-python">result = agent.verify_response(response_string)
payload = result.get('payload')
agent_id = result.get('agentId')  # Who signed the response
</code></pre>
<h2 id="algorithm-security"><a class="header" href="#algorithm-security">Algorithm Security</a></h2>
<h3 id="supported-algorithms-1"><a class="header" href="#supported-algorithms-1">Supported Algorithms</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Type</th><th>Security Level</th></tr></thead><tbody>
<tr><td><code>ring-Ed25519</code></td><td>Elliptic Curve</td><td>High (recommended)</td></tr>
<tr><td><code>RSA-PSS</code></td><td>RSA</td><td>High</td></tr>
<tr><td><code>pq-dilithium</code></td><td>Post-Quantum</td><td>Quantum-resistant</td></tr>
<tr><td><code>pq2025</code></td><td>Composite</td><td>Transitional</td></tr>
</tbody></table>
</div>
<h3 id="algorithm-selection"><a class="header" href="#algorithm-selection">Algorithm Selection</a></h3>
<p>Choose based on requirements:</p>
<ul>
<li><strong>General Use</strong>: <code>ring-Ed25519</code> - fast, secure, small signatures</li>
<li><strong>Legacy Systems</strong>: <code>RSA-PSS</code> - widely supported</li>
<li><strong>Future-Proofing</strong>: <code>pq-dilithium</code> - quantum-resistant</li>
<li><strong>Transition</strong>: <code>pq2025</code> - hybrid classical/post-quantum</li>
</ul>
<h2 id="security-best-practices-1"><a class="header" href="#security-best-practices-1">Security Best Practices</a></h2>
<h3 id="1-key-storage"><a class="header" href="#1-key-storage">1. Key Storage</a></h3>
<pre><code class="language-bash"># Never commit keys to version control
echo "jacs_keys/" &gt;&gt; .gitignore

# Secure file permissions
chmod 700 ./jacs_keys
chmod 600 ./jacs_keys/private.pem
</code></pre>
<h3 id="2-password-handling"><a class="header" href="#2-password-handling">2. Password Handling</a></h3>
<pre><code class="language-bash"># Use environment variables
export JACS_PRIVATE_KEY_PASSWORD="$(pass show jacs/key-password)"
</code></pre>
<h3 id="3-transport-security"><a class="header" href="#3-transport-security">3. Transport Security</a></h3>
<p>Always use TLS for network communication:</p>
<pre><code class="language-python"># HTTPS for web transport
client = JACSMCPClient("https://localhost:8000/sse")  # Good
# client = JACSMCPClient("http://localhost:8000/sse")  # Avoid in production
</code></pre>
<h3 id="4-verification-policies"><a class="header" href="#4-verification-policies">4. Verification Policies</a></h3>
<pre><code class="language-json">{
  "jacs_dns_strict": true,
  "jacs_dns_required": true,
  "jacs_enable_filesystem_quarantine": "true"
}
</code></pre>
<h3 id="5-audit-logging"><a class="header" href="#5-audit-logging">5. Audit Logging</a></h3>
<p>Enable observability for security auditing:</p>
<pre><code class="language-json">{
  "observability": {
    "logs": {
      "enabled": true,
      "level": "info"
    }
  }
}
</code></pre>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<h3 id="development-1"><a class="header" href="#development-1">Development</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Generate unique keys for each environment</li>
<li><input disabled="" type="checkbox"/>
Never commit private keys</li>
<li><input disabled="" type="checkbox"/>
Use test keys separate from production</li>
</ul>
<h3 id="production-1"><a class="header" href="#production-1">Production</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Encrypt private keys at rest</li>
<li><input disabled="" type="checkbox"/>
Use environment variables for secrets (never store <code>jacs_private_key_password</code> in config)</li>
<li><input disabled="" type="checkbox"/>
Enable DNS verification</li>
<li><input disabled="" type="checkbox"/>
Configure strict security mode</li>
<li><input disabled="" type="checkbox"/>
Enable audit logging</li>
<li><input disabled="" type="checkbox"/>
Use TLS for all network transport</li>
<li><input disabled="" type="checkbox"/>
Restrict key file permissions (0600 for keys, 0700 for key directory)</li>
<li><input disabled="" type="checkbox"/>
Implement key rotation policy</li>
<li><input disabled="" type="checkbox"/>
Set <code>JACS_STRICT_TLS=true</code> for certificate validation</li>
<li><input disabled="" type="checkbox"/>
Use strong passwords (28+ bit entropy, 35+ for single character class)</li>
<li><input disabled="" type="checkbox"/>
Enable signature timestamp validation</li>
<li><input disabled="" type="checkbox"/>
Verify public key hashes before trusting agents</li>
<li><input disabled="" type="checkbox"/>
Run <code>cargo audit</code> / <code>npm audit</code> / <code>pip audit</code> regularly for dependency vulnerabilities</li>
</ul>
<h3 id="verification-1"><a class="header" href="#verification-1">Verification</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Always verify documents before trusting</li>
<li><input disabled="" type="checkbox"/>
Verify agent signatures</li>
<li><input disabled="" type="checkbox"/>
Check agreement completeness</li>
<li><input disabled="" type="checkbox"/>
Validate DNS records when required</li>
</ul>
<h2 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations</a></h2>
<h3 id="supply-chain"><a class="header" href="#supply-chain">Supply Chain</a></h3>
<ul>
<li>Verify JACS packages are from official sources</li>
<li>Use package checksums</li>
<li>Keep dependencies updated</li>
</ul>
<h3 id="side-channels"><a class="header" href="#side-channels">Side Channels</a></h3>
<ul>
<li>Use constant-time comparison for signatures</li>
<li>Protect against timing attacks</li>
<li>Secure memory handling for keys</li>
</ul>
<h3 id="recovery"><a class="header" href="#recovery">Recovery</a></h3>
<ul>
<li>Backup key material securely</li>
<li>Document key recovery procedures</li>
<li>Plan for key compromise scenarios</li>
</ul>
<h2 id="troubleshooting-verification-claims"><a class="header" href="#troubleshooting-verification-claims">Troubleshooting Verification Claims</a></h2>
<h3 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common Issues and Solutions</a></h3>
<h4 id="verified-agents-must-have-jacsagentdomain-set"><a class="header" href="#verified-agents-must-have-jacsagentdomain-set">"Verified agents must have jacsAgentDomain set"</a></h4>
<p><strong>Problem</strong>: You set <code>jacsVerificationClaim</code> to <code>verified</code> but didn't specify a domain.</p>
<p><strong>Solution</strong>: Either add a domain or use unverified:</p>
<pre><code class="language-json">// Option 1: Add a domain (recommended for production)
{
  "jacsVerificationClaim": "verified",
  "jacsAgentDomain": "myagent.example.com"
}

// Option 2: Use unverified if DNS verification isn't needed
{
  "jacsVerificationClaim": "unverified"
}
</code></pre>
<h4 id="agent-is-not-registered-with-haiai"><a class="header" href="#agent-is-not-registered-with-haiai">"Agent is not registered with HAI.ai"</a></h4>
<p><strong>Problem</strong>: You're using <code>verified-hai.ai</code> but the agent isn't registered.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Register your agent at <a href="https://hai.ai">hai.ai</a></li>
<li>Or use <code>verified</code> for DNS-only verification:</li>
</ol>
<pre><code class="language-json">{
  "jacsVerificationClaim": "verified",
  "jacsAgentDomain": "myagent.example.com"
}
</code></pre>
<h4 id="cannot-downgrade-from-verified-to-unverified"><a class="header" href="#cannot-downgrade-from-verified-to-unverified">"Cannot downgrade from 'verified' to 'unverified'"</a></h4>
<p><strong>Problem</strong>: You're trying to change an existing agent's claim to a lower level.</p>
<p><strong>Solution</strong>: Verification claims cannot be downgraded for security. Options:</p>
<ol>
<li>Keep the current claim level</li>
<li>Create a new agent with the desired claim level</li>
<li>If this is a test/development scenario, start fresh</li>
</ol>
<pre><code class="language-bash"># Create a new agent instead
jacs create --type ai --claim unverified
</code></pre>
<h4 id="dns-fingerprint-mismatch"><a class="header" href="#dns-fingerprint-mismatch">"DNS fingerprint mismatch"</a></h4>
<p><strong>Problem</strong>: The public key hash in DNS doesn't match your agent's key.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Regenerate the DNS record with your current keys:
<pre><code class="language-bash">jacs dns-record
</code></pre>
</li>
<li>Update your DNS TXT record with the new value</li>
<li>Wait for DNS propagation (can take up to 48 hours)</li>
</ol>
<h4 id="strict-dnssec-validation-failed"><a class="header" href="#strict-dnssec-validation-failed">"Strict DNSSEC validation failed"</a></h4>
<p><strong>Problem</strong>: Your domain doesn't have DNSSEC enabled.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Enable DNSSEC with your domain registrar</li>
<li>Publish DS records at the parent zone</li>
<li>Or use <code>verified</code> with non-strict DNS (development only)</li>
</ol>
<h3 id="claim-level-reference"><a class="header" href="#claim-level-reference">Claim Level Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Claim</th><th>Security Level</th><th>Requirements</th></tr></thead><tbody>
<tr><td><code>unverified</code></td><td>0 (lowest)</td><td>None - self-asserted identity</td></tr>
<tr><td><code>verified</code></td><td>1</td><td>Domain + DNS TXT record + DNSSEC</td></tr>
<tr><td><code>verified-hai.ai</code></td><td>2 (highest)</td><td>Above + HAI.ai registration</td></tr>
</tbody></table>
</div>
<h3 id="upgrade-vs-downgrade-rules"><a class="header" href="#upgrade-vs-downgrade-rules">Upgrade vs Downgrade Rules</a></h3>
<ul>
<li><strong>Upgrades allowed</strong>: <code>unverified</code> ‚Üí <code>verified</code> ‚Üí <code>verified-hai.ai</code></li>
<li><strong>Downgrades blocked</strong>: Cannot go from higher to lower claim</li>
<li><strong>Same level allowed</strong>: Can update agent while keeping same claim</li>
</ul>
<h3 id="quick-diagnostic-commands"><a class="header" href="#quick-diagnostic-commands">Quick Diagnostic Commands</a></h3>
<pre><code class="language-bash"># Check your agent's current claim
jacs info | grep jacsVerificationClaim

# Verify DNS record is correct
jacs dns-check

# Test verification
jacs verify --agent your-agent-id:version
</code></pre>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="advanced/crypto.html">Cryptographic Algorithms</a> - Algorithm details</li>
<li><a href="advanced/../dns.html">DNS Verification</a> - DNS-based identity</li>
<li><a href="advanced/../schemas/configuration.html">Configuration</a> - Security configuration</li>
<li><a href="advanced/../rust/agreements.html">Agreements</a> - Multi-party agreements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-rotation-1"><a class="header" href="#key-rotation-1">Key Rotation</a></h1>
<p>Key rotation is the process of replacing an agent's cryptographic keys while preserving the ability to verify documents signed with previous keys. JACS implements version-aware key management to support secure key lifecycle operations.</p>
<h2 id="why-key-rotation-matters"><a class="header" href="#why-key-rotation-matters">Why Key Rotation Matters</a></h2>
<h3 id="key-compromise-recovery"><a class="header" href="#key-compromise-recovery">Key Compromise Recovery</a></h3>
<p>When a private key is compromised, the agent must be able to:</p>
<ul>
<li>Generate new keys and continue operating</li>
<li>Revoke trust in the compromised key</li>
<li>Maintain verifiability of documents signed before the compromise</li>
</ul>
<h3 id="cryptographic-agility"><a class="header" href="#cryptographic-agility">Cryptographic Agility</a></h3>
<p>Cryptographic algorithms evolve. Key rotation enables:</p>
<ul>
<li>Migration from older algorithms to newer ones</li>
<li>Transition to post-quantum cryptography when needed</li>
<li>Algorithm upgrades without breaking existing signatures</li>
</ul>
<h3 id="compliance-requirements"><a class="header" href="#compliance-requirements">Compliance Requirements</a></h3>
<p>Many security standards require periodic key rotation:</p>
<ul>
<li>PCI-DSS mandates regular key changes</li>
<li>SOC 2 requires key management policies</li>
<li>NIST guidelines recommend rotation schedules</li>
</ul>
<h2 id="agent-versioning"><a class="header" href="#agent-versioning">Agent Versioning</a></h2>
<p>JACS uses a versioned identity model where each key rotation creates a new agent version.</p>
<h3 id="version-format"><a class="header" href="#version-format">Version Format</a></h3>
<p>Agent identifiers follow the format: <code>{agent_id}:{version_uuid}</code></p>
<ul>
<li><strong>jacsId</strong>: The stable agent identity (UUID v4) - never changes</li>
<li><strong>jacsVersion</strong>: Current version UUID - changes on each update</li>
<li><strong>jacsPreviousVersion</strong>: Links to the prior version</li>
<li><strong>jacsOriginalVersion</strong>: The first version ever created</li>
</ul>
<pre><code class="language-json">{
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "jacsPreviousVersion": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
  "jacsOriginalVersion": "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
}
</code></pre>
<h3 id="version-chain"><a class="header" href="#version-chain">Version Chain</a></h3>
<p>Each version forms a linked chain back to the original:</p>
<pre><code>Original (v1) &lt;-- Previous (v2) &lt;-- Current (v3)
   |                 |                  |
 key-A             key-B              key-C
</code></pre>
<p>This chain provides an audit trail of all key changes and allows verification of any version.</p>
<h2 id="version-aware-verification"><a class="header" href="#version-aware-verification">Version-Aware Verification</a></h2>
<p>The critical insight enabling key rotation is that signatures contain both the agent ID and the version that created them.</p>
<h3 id="signature-structure"><a class="header" href="#signature-structure">Signature Structure</a></h3>
<pre><code class="language-json">{
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    "publicKeyHash": "sha256-of-public-key-A",
    "signingAlgorithm": "ring-Ed25519",
    "signature": "base64-encoded-signature",
    "date": "2024-01-15T10:00:00Z"
  }
}
</code></pre>
<h3 id="key-resolution-process"><a class="header" href="#key-resolution-process">Key Resolution Process</a></h3>
<p>When verifying a signature:</p>
<ol>
<li>Extract <code>agentVersion</code> and <code>publicKeyHash</code> from the signature</li>
<li>Look up the public key that was active for that version</li>
<li>Verify the signature using that historical key</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudocode for version-aware verification
fn verify_signature(doc: &amp;Document) -&gt; Result&lt;()&gt; {
    let sig = &amp;doc.jacs_signature;

    // Find the key that was active for this version
    let public_key = resolve_key_for_version(
        &amp;sig.agent_id,
        &amp;sig.agent_version,
        &amp;sig.public_key_hash,
    )?;

    // Verify with the historical key
    verify_with_key(&amp;doc, &amp;sig, &amp;public_key)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-lookup-priority"><a class="header" href="#key-lookup-priority">Key Lookup Priority</a></h3>
<p>The verification system tries multiple sources:</p>
<ol>
<li><strong>Local cache by hash</strong> - Fastest, key already stored locally</li>
<li><strong>Trust store by version</strong> - Most accurate for known agents</li>
<li><strong>Trust store by hash</strong> - Fallback for legacy entries</li>
<li><strong>DNS lookup</strong> - External verification, authoritative</li>
<li><strong>Fail</strong> - Key not found, verification impossible</li>
</ol>
<h2 id="key-rotation-process"><a class="header" href="#key-rotation-process">Key Rotation Process</a></h2>
<h3 id="step-by-step-rotation"><a class="header" href="#step-by-step-rotation">Step-by-Step Rotation</a></h3>
<ol>
<li><strong>Generate new key pair</strong> with the desired algorithm</li>
<li><strong>Create new agent version</strong> with updated key information</li>
<li><strong>Sign new version with old key</strong> (transition signature)</li>
<li><strong>Update DNS records</strong> to include new key fingerprint</li>
<li><strong>Store old public key</strong> for future verifications</li>
</ol>
<h3 id="transition-signature"><a class="header" href="#transition-signature">Transition Signature</a></h3>
<p>The transition signature proves the key rotation was authorized by the holder of the old key:</p>
<pre><code>JACS_KEY_ROTATION:{agent_id}:{old_key_hash}:{new_key_hash}:{timestamp}
</code></pre>
<p>This signed message:</p>
<ul>
<li>Proves continuity of ownership</li>
<li>Provides an audit trail</li>
<li>Binds old and new keys together cryptographically</li>
</ul>
<h3 id="cli-commands-planned"><a class="header" href="#cli-commands-planned">CLI Commands (Planned)</a></h3>
<blockquote>
<p><strong>Note</strong>: These CLI commands are planned for a future release. Currently, key rotation must be performed programmatically using the Rust API.</p>
</blockquote>
<pre><code class="language-bash"># Rotate keys with default algorithm (Coming Soon)
jacs agent rotate-keys

# Rotate to post-quantum algorithm (Coming Soon)
jacs agent rotate-keys --algorithm pq2025

# List key history (Coming Soon)
jacs agent keys list

# Revoke a compromised key (Coming Soon)
jacs agent keys revoke &lt;key-hash&gt;
</code></pre>
<h3 id="example-rotation-flow"><a class="header" href="#example-rotation-flow">Example Rotation Flow</a></h3>
<pre><code>Time T0: Agent created
  - jacsId: "abc-123"
  - jacsVersion: "v1-uuid"
  - jacsCurrentKeyHash: "hash-A"

Time T1: Agent signs document D1
  - D1.jacsSignature.agentVersion: "v1-uuid"
  - D1.jacsSignature.publicKeyHash: "hash-A"

Time T2: Key rotation
  - New keys generated with hash-B
  - jacsVersion: "v2-uuid"
  - jacsKeyHistory: [{ hash: "hash-A", status: "rotated" }]
  - jacsCurrentKeyHash: "hash-B"

Time T3: Verify D1
  - Extract agentVersion "v1-uuid" and hash "hash-A"
  - Look up key: find "hash-A" with status "rotated"
  - Verification succeeds (old key still valid for old docs)

Time T4: Agent signs document D2
  - D2.jacsSignature.agentVersion: "v2-uuid"
  - D2.jacsSignature.publicKeyHash: "hash-B"
</code></pre>
<h2 id="trust-store-with-version-history"><a class="header" href="#trust-store-with-version-history">Trust Store with Version History</a></h2>
<p>The trust store maintains a history of all public keys for each trusted agent.</p>
<h3 id="trustedagent-structure"><a class="header" href="#trustedagent-structure">TrustedAgent Structure</a></h3>
<pre><code class="language-json">{
  "agent_id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Example Agent",
  "trusted_at": "2024-01-15T10:00:00Z",
  "current_key_hash": "abc123...",
  "domain": "agent.example.com",
  "key_history": [
    {
      "public_key_hash": "xyz789...",
      "public_key_pem": "-----BEGIN PUBLIC KEY-----\n...",
      "signing_algorithm": "ring-Ed25519",
      "trusted_at": "2024-01-01T00:00:00Z",
      "first_version": "11111111-1111-1111-1111-111111111111",
      "last_version": "22222222-2222-2222-2222-222222222222",
      "status": "rotated"
    },
    {
      "public_key_hash": "abc123...",
      "public_key_pem": "-----BEGIN PUBLIC KEY-----\n...",
      "signing_algorithm": "ring-Ed25519",
      "trusted_at": "2024-01-15T10:00:00Z",
      "first_version": "33333333-3333-3333-3333-333333333333",
      "last_version": null,
      "status": "active"
    }
  ]
}
</code></pre>
<h3 id="key-status-values"><a class="header" href="#key-status-values">Key Status Values</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td><code>active</code></td><td>Currently in use for signing</td></tr>
<tr><td><code>rotated</code></td><td>Superseded by newer key, still valid for old signatures</td></tr>
<tr><td><code>revoked</code></td><td>Compromised, signatures should not be trusted</td></tr>
<tr><td><code>expired</code></td><td>Past validity period</td></tr>
</tbody></table>
</div>
<h3 id="looking-up-keys"><a class="header" href="#looking-up-keys">Looking Up Keys</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TrustedAgent {
    /// Get the public key that was active for a specific agent version
    fn get_key_for_version(&amp;self, version: &amp;str) -&gt; Option&lt;&amp;KeyEntry&gt; {
        self.key_history.iter().find(|entry| {
            match (&amp;entry.first_version, &amp;entry.last_version) {
                (Some(first), Some(last)) =&gt; {
                    version &gt;= first &amp;&amp; version &lt;= last
                }
                (Some(first), None) =&gt; {
                    version &gt;= first  // Current key
                }
                _ =&gt; false
            }
        })
    }

    /// Get the public key by its hash
    fn get_key_by_hash(&amp;self, hash: &amp;str) -&gt; Option&lt;&amp;KeyEntry&gt; {
        self.key_history.iter().find(|e| e.public_key_hash == hash)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dns-support-for-key-versions"><a class="header" href="#dns-support-for-key-versions">DNS Support for Key Versions</a></h2>
<p>DNS records can advertise multiple key versions for an agent.</p>
<h3 id="multi-version-dns-records"><a class="header" href="#multi-version-dns-records">Multi-Version DNS Records</a></h3>
<p>Each key version gets its own TXT record:</p>
<pre><code>; Current key
_v1.agent.jacs.example.com. 3600 IN TXT "v=hai.ai; jacs_agent_id={id}; ver=current; alg=SHA-256; hash={hash1}"

; Previous key (still valid for old signatures)
_v1.agent.jacs.example.com. 3600 IN TXT "v=hai.ai; jacs_agent_id={id}; ver=rotated; valid_until=2025-01-15; hash={hash2}"
</code></pre>
<h3 id="dns-record-generation"><a class="header" href="#dns-record-generation">DNS Record Generation</a></h3>
<pre><code class="language-bash"># Generate DNS records for all active keys
jacs agent dns --all-keys
</code></pre>
<h2 id="security-considerations-5"><a class="header" href="#security-considerations-5">Security Considerations</a></h2>
<h3 id="key-revocation"><a class="header" href="#key-revocation">Key Revocation</a></h3>
<p>When a key is compromised:</p>
<ol>
<li><strong>Mark as revoked</strong> in the agent's key history</li>
<li><strong>Update DNS</strong> to include revocation status</li>
<li><strong>Signatures fail verification</strong> when made with revoked keys</li>
<li><strong>Notify trusted peers</strong> if possible</li>
</ol>
<h3 id="overlap-period"><a class="header" href="#overlap-period">Overlap Period</a></h3>
<p>During rotation, both old and new keys may be valid:</p>
<ul>
<li>New documents should be signed with the new key</li>
<li>Old documents remain verifiable with the old key</li>
<li>DNS may advertise both keys during transition</li>
</ul>
<h3 id="secure-deletion"><a class="header" href="#secure-deletion">Secure Deletion</a></h3>
<p>After rotation:</p>
<ul>
<li>Old private keys should be securely deleted</li>
<li>Only public keys are retained for verification</li>
<li>Key metadata must be protected from modification</li>
</ul>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="rotation-schedule"><a class="header" href="#rotation-schedule">Rotation Schedule</a></h3>
<ul>
<li><strong>Regular rotation</strong>: Quarterly or annually for compliance</li>
<li><strong>Algorithm upgrade</strong>: When transitioning to stronger cryptography</li>
<li><strong>Incident response</strong>: Immediately after suspected compromise</li>
</ul>
<h3 id="pre-rotation-checklist"><a class="header" href="#pre-rotation-checklist">Pre-Rotation Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Backup current agent state</li>
<li><input disabled="" type="checkbox"/>
Verify all systems can handle new key format</li>
<li><input disabled="" type="checkbox"/>
Plan DNS propagation time</li>
<li><input disabled="" type="checkbox"/>
Notify dependent systems of upcoming change</li>
</ul>
<h3 id="post-rotation-checklist"><a class="header" href="#post-rotation-checklist">Post-Rotation Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Verify new key is active</li>
<li><input disabled="" type="checkbox"/>
Confirm old documents still verify</li>
<li><input disabled="" type="checkbox"/>
Update DNS records</li>
<li><input disabled="" type="checkbox"/>
Securely delete old private key</li>
<li><input disabled="" type="checkbox"/>
Test signing with new key</li>
</ul>
<h2 id="see-also-14"><a class="header" href="#see-also-14">See Also</a></h2>
<ul>
<li><a href="advanced/security.html">Security Model</a> - Overall security architecture</li>
<li><a href="advanced/crypto.html">Cryptographic Algorithms</a> - Algorithm details</li>
<li><a href="advanced/../rust/dns.html">DNS Verification</a> - DNS-based identity verification</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-algorithms-2"><a class="header" href="#cryptographic-algorithms-2">Cryptographic Algorithms</a></h1>
<p>JACS supports multiple cryptographic algorithms for digital signatures, providing flexibility for different security requirements and future-proofing against quantum computing threats.</p>
<h2 id="supported-algorithms-2"><a class="header" href="#supported-algorithms-2">Supported Algorithms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Config Value</th><th>Type</th><th>Key Size</th><th>Signature Size</th><th>Recommended Use</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>ring-Ed25519</code></td><td>Elliptic Curve</td><td>32 bytes</td><td>64 bytes</td><td>General purpose (default)</td></tr>
<tr><td>RSA-PSS</td><td><code>RSA-PSS</code></td><td>RSA</td><td>2048-4096 bits</td><td>256-512 bytes</td><td>Legacy systems</td></tr>
<tr><td>Dilithium</td><td><code>pq-dilithium</code></td><td>Lattice-based</td><td>~1.3 KB</td><td>~2.4 KB</td><td>Post-quantum</td></tr>
<tr><td>PQ2025</td><td><code>pq2025</code></td><td>Hybrid</td><td>~1.3 KB</td><td>~2.5 KB</td><td>Transitional</td></tr>
</tbody></table>
</div>
<h2 id="ed25519-ring-ed25519"><a class="header" href="#ed25519-ring-ed25519">Ed25519 (ring-Ed25519)</a></h2>
<p>The recommended algorithm for most use cases.</p>
<h3 id="overview-9"><a class="header" href="#overview-9">Overview</a></h3>
<p>Ed25519 is an elliptic curve signature scheme using Curve25519. JACS uses the <code>ring</code> cryptographic library implementation.</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li><strong>Speed</strong>: Extremely fast signing and verification</li>
<li><strong>Key Size</strong>: 32-byte private key, 32-byte public key</li>
<li><strong>Signature Size</strong>: 64 bytes</li>
<li><strong>Security Level</strong>: ~128 bits (classical)</li>
</ul>
<h3 id="configuration-9"><a class="header" href="#configuration-9">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<h3 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h3>
<ul>
<li>General agent communication</li>
<li>MCP message signing</li>
<li>HTTP request/response signing</li>
<li>Document signing</li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')  # Using ring-Ed25519

# Sign a message
signature = agent.sign_string("Hello, World!")
print(f"Signature (64 bytes): {len(signature)} characters base64")
</code></pre>
<h2 id="rsa-pss-2"><a class="header" href="#rsa-pss-2">RSA-PSS</a></h2>
<p>Industry-standard RSA with Probabilistic Signature Scheme padding.</p>
<h3 id="overview-10"><a class="header" href="#overview-10">Overview</a></h3>
<p>RSA-PSS provides compatibility with systems that require RSA signatures. JACS uses 2048-bit or larger keys.</p>
<h3 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h3>
<ul>
<li><strong>Speed</strong>: Slower than Ed25519</li>
<li><strong>Key Size</strong>: 2048-4096 bits</li>
<li><strong>Signature Size</strong>: Same as key size (256-512 bytes)</li>
<li><strong>Security Level</strong>: ~112-128 bits (2048-bit key)</li>
</ul>
<h3 id="configuration-10"><a class="header" href="#configuration-10">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "RSA-PSS"
}
</code></pre>
<h3 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h3>
<ul>
<li>Integration with legacy systems</li>
<li>Compliance requirements mandating RSA</li>
<li>Interoperability with enterprise PKI</li>
</ul>
<h3 id="considerations"><a class="header" href="#considerations">Considerations</a></h3>
<ul>
<li>Larger signatures increase document size</li>
<li>Slower than Ed25519</li>
<li>Larger keys needed for equivalent security</li>
</ul>
<h2 id="dilithium-pq-dilithium"><a class="header" href="#dilithium-pq-dilithium">Dilithium (pq-dilithium)</a></h2>
<p>NIST-standardized post-quantum digital signature algorithm.</p>
<h3 id="overview-11"><a class="header" href="#overview-11">Overview</a></h3>
<p>Dilithium is a lattice-based signature scheme selected by NIST for post-quantum cryptography standardization. It provides security against both classical and quantum computers.</p>
<h3 id="characteristics-2"><a class="header" href="#characteristics-2">Characteristics</a></h3>
<ul>
<li><strong>Speed</strong>: Moderate (faster than RSA, slower than Ed25519)</li>
<li><strong>Key Size</strong>: ~1.3 KB public key, ~2.5 KB private key</li>
<li><strong>Signature Size</strong>: ~2.4 KB</li>
<li><strong>Security Level</strong>: NIST Level 3 (quantum-resistant)</li>
</ul>
<h3 id="configuration-11"><a class="header" href="#configuration-11">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
<h3 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h3>
<ul>
<li>Long-term document security</li>
<li>Protection against future quantum attacks</li>
<li>High-security applications</li>
<li>Government/defense requirements</li>
</ul>
<h3 id="considerations-1"><a class="header" href="#considerations-1">Considerations</a></h3>
<ul>
<li>Larger signatures and keys than classical algorithms</li>
<li>Newer algorithm (less battle-tested)</li>
<li>May be required for future compliance</li>
</ul>
<h2 id="pq2025-hybrid"><a class="header" href="#pq2025-hybrid">PQ2025 (Hybrid)</a></h2>
<p>Transitional hybrid scheme combining classical and post-quantum algorithms.</p>
<h3 id="overview-12"><a class="header" href="#overview-12">Overview</a></h3>
<p>PQ2025 combines Ed25519 with Dilithium, providing security even if one algorithm is broken. This approach is recommended by security researchers during the quantum transition period.</p>
<h3 id="characteristics-3"><a class="header" href="#characteristics-3">Characteristics</a></h3>
<ul>
<li><strong>Speed</strong>: Slower (two signatures computed)</li>
<li><strong>Key Size</strong>: Combined Ed25519 + Dilithium</li>
<li><strong>Signature Size</strong>: ~2.5 KB (combined)</li>
<li><strong>Security Level</strong>: Max of both algorithms</li>
</ul>
<h3 id="configuration-12"><a class="header" href="#configuration-12">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq2025"
}
</code></pre>
<h3 id="use-cases-4"><a class="header" href="#use-cases-4">Use Cases</a></h3>
<ul>
<li>Transitioning to post-quantum</li>
<li>Maximum security requirements</li>
<li>Uncertainty about algorithm security</li>
<li>Long-lived documents</li>
</ul>
<h3 id="considerations-2"><a class="header" href="#considerations-2">Considerations</a></h3>
<ul>
<li>Largest signatures</li>
<li>Slowest signing/verification</li>
<li>Best for paranoid security requirements</li>
</ul>
<h2 id="algorithm-selection-guide"><a class="header" href="#algorithm-selection-guide">Algorithm Selection Guide</a></h2>
<h3 id="decision-matrix"><a class="header" href="#decision-matrix">Decision Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Recommended Algorithm</th></tr></thead><tbody>
<tr><td>Best performance</td><td><code>ring-Ed25519</code></td></tr>
<tr><td>Smallest signatures</td><td><code>ring-Ed25519</code></td></tr>
<tr><td>Legacy compatibility</td><td><code>RSA-PSS</code></td></tr>
<tr><td>Quantum resistance</td><td><code>pq-dilithium</code></td></tr>
<tr><td>Maximum security</td><td><code>pq2025</code></td></tr>
<tr><td>General purpose</td><td><code>ring-Ed25519</code></td></tr>
</tbody></table>
</div>
<h3 id="by-use-case"><a class="header" href="#by-use-case">By Use Case</a></h3>
<p><strong>Web APIs and MCP</strong>:</p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p>Fast signing is critical for real-time communication.</p>
<p><strong>Legal/Financial Documents</strong>:</p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
<p>Long-term validity requires quantum resistance.</p>
<p><strong>Enterprise Integration</strong>:</p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "RSA-PSS"
}
</code></pre>
<p>Compatibility with existing PKI infrastructure.</p>
<p><strong>High-Security</strong>:</p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq2025"
}
</code></pre>
<p>Belt-and-suspenders approach for maximum protection.</p>
<h2 id="key-generation-1"><a class="header" href="#key-generation-1">Key Generation</a></h2>
<p>Keys are generated automatically when creating an agent:</p>
<pre><code class="language-bash"># Directory structure after agent creation
jacs_keys/
‚îú‚îÄ‚îÄ private.pem    # Algorithm-specific private key
‚îî‚îÄ‚îÄ public.pem     # Algorithm-specific public key
</code></pre>
<h3 id="key-formats"><a class="header" href="#key-formats">Key Formats</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Private Key Format</th><th>Public Key Format</th></tr></thead><tbody>
<tr><td>ring-Ed25519</td><td>PEM (PKCS#8)</td><td>PEM (SPKI)</td></tr>
<tr><td>RSA-PSS</td><td>PEM (PKCS#8)</td><td>PEM (SPKI)</td></tr>
<tr><td>pq-dilithium</td><td>PEM (custom)</td><td>PEM (custom)</td></tr>
<tr><td>pq2025</td><td>PEM (combined)</td><td>PEM (combined)</td></tr>
</tbody></table>
</div>
<h2 id="signature-structure-1"><a class="header" href="#signature-structure-1">Signature Structure</a></h2>
<p>Signatures in JACS documents include algorithm metadata:</p>
<pre><code class="language-json">{
  "jacsSignature": {
    "agentID": "550e8400-e29b-41d4-a716-446655440000",
    "agentVersion": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "date": "2024-01-15T10:30:00Z",
    "signature": "base64-encoded-signature",
    "publicKeyHash": "sha256-of-public-key",
    "signingAlgorithm": "ring-Ed25519",
    "fields": ["jacsId", "jacsVersion", "content"]
  }
}
</code></pre>
<p>The <code>signingAlgorithm</code> field enables verifiers to use the correct verification method.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<p>JACS uses SHA-256 for all hash operations:</p>
<ul>
<li>Document content hashing (<code>jacsSha256</code>)</li>
<li>Public key fingerprints (<code>publicKeyHash</code>)</li>
<li>Agreement content locking (<code>jacsAgreementHash</code>)</li>
</ul>
<pre><code class="language-json">{
  "jacsSha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
}
</code></pre>
<h2 id="algorithm-migration"><a class="header" href="#algorithm-migration">Algorithm Migration</a></h2>
<p>To migrate to a new algorithm:</p>
<ol>
<li>
<p><strong>Generate New Keys</strong></p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
</li>
<li>
<p><strong>Create New Agent Version</strong></p>
<pre><code class="language-python"># Load with old algorithm
agent.load('./old-config.json')

# Update to new algorithm and generate new version
new_agent = agent.update_agent(json.dumps({
    # ... agent data with new keys
}))
</code></pre>
</li>
<li>
<p><strong>Update Configuration</strong></p>
<pre><code class="language-json">{
  "jacs_agent_id_and_version": "agent-id:new-version",
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
</li>
<li>
<p><strong>Maintain Backward Compatibility</strong></p>
<ul>
<li>Keep old agent versions for verifying old documents</li>
<li>Old signatures remain valid with old public keys</li>
</ul>
</li>
</ol>
<h2 id="performance-comparison"><a class="header" href="#performance-comparison">Performance Comparison</a></h2>
<p>Approximate performance (varies by hardware):</p>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Sign (ops/sec)</th><th>Verify (ops/sec)</th><th>Key Gen (ms)</th></tr></thead><tbody>
<tr><td>ring-Ed25519</td><td>~50,000</td><td>~20,000</td><td>&lt;1</td></tr>
<tr><td>RSA-PSS (2048)</td><td>~1,000</td><td>~30,000</td><td>~100</td></tr>
<tr><td>pq-dilithium</td><td>~5,000</td><td>~10,000</td><td>~1</td></tr>
<tr><td>pq2025</td><td>~4,000</td><td>~8,000</td><td>~2</td></tr>
</tbody></table>
</div>
<h2 id="security-considerations-6"><a class="header" href="#security-considerations-6">Security Considerations</a></h2>
<h3 id="algorithm-agility"><a class="header" href="#algorithm-agility">Algorithm Agility</a></h3>
<p>JACS documents include the signing algorithm, enabling:</p>
<ul>
<li>Verification with correct algorithm</li>
<li>Graceful algorithm transitions</li>
<li>Multi-algorithm environments</li>
</ul>
<h3 id="forward-secrecy"><a class="header" href="#forward-secrecy">Forward Secrecy</a></h3>
<p>Signatures don't provide forward secrecy. For confidentiality:</p>
<ul>
<li>Use TLS for transport</li>
<li>Consider additional encryption layers</li>
</ul>
<h3 id="key-compromise"><a class="header" href="#key-compromise">Key Compromise</a></h3>
<p>If a private key is compromised:</p>
<ol>
<li>Generate new key pair</li>
<li>Create new agent version</li>
<li>Revoke trust in compromised version</li>
<li>Re-sign critical documents</li>
</ol>
<h2 id="see-also-15"><a class="header" href="#see-also-15">See Also</a></h2>
<ul>
<li><a href="advanced/security.html">Security Model</a> - Overall security architecture</li>
<li><a href="advanced/../schemas/configuration.html">Configuration</a> - Algorithm configuration</li>
<li><a href="advanced/../dns.html">DNS Verification</a> - Public key fingerprint verification</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-backends-3"><a class="header" href="#storage-backends-3">Storage Backends</a></h1>
<p>JACS supports multiple storage backends for persisting documents and agents. This flexibility allows deployment in various environments from local development to cloud infrastructure.</p>
<h2 id="available-backends"><a class="header" href="#available-backends">Available Backends</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Backend</th><th>Config Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Filesystem</td><td><code>fs</code></td><td>Local file storage (default)</td></tr>
<tr><td>AWS S3</td><td><code>aws</code></td><td>Amazon S3 object storage</td></tr>
<tr><td>HAI Cloud</td><td><code>hai</code></td><td>HAI managed storage</td></tr>
<tr><td>PostgreSQL</td><td><code>database</code></td><td>PostgreSQL with JSONB queries (requires <code>database</code> feature)</td></tr>
</tbody></table>
</div>
<h2 id="configuration-13"><a class="header" href="#configuration-13">Configuration</a></h2>
<p>Set the storage backend in your configuration:</p>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data"
}
</code></pre>
<h2 id="filesystem-storage-fs"><a class="header" href="#filesystem-storage-fs">Filesystem Storage (fs)</a></h2>
<p>The default storage backend, storing documents as JSON files on the local filesystem.</p>
<h3 id="configuration-14"><a class="header" href="#configuration-14">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data"
}
</code></pre>
<h3 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h3>
<pre><code>jacs_data/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îî‚îÄ‚îÄ {agent-id}/
‚îÇ       ‚îî‚îÄ‚îÄ {version-id}.json
‚îú‚îÄ‚îÄ documents/
‚îÇ   ‚îî‚îÄ‚îÄ {document-id}/
‚îÇ       ‚îî‚îÄ‚îÄ {version-id}.json
‚îî‚îÄ‚îÄ files/
    ‚îî‚îÄ‚îÄ {attachment-hash}
</code></pre>
<h3 id="use-cases-5"><a class="header" href="#use-cases-5">Use Cases</a></h3>
<ul>
<li>Local development</li>
<li>Single-server deployments</li>
<li>Testing and prototyping</li>
<li>Air-gapped environments</li>
</ul>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<ul>
<li>Simple setup</li>
<li>No network dependencies</li>
<li>Fast local access</li>
<li>Easy backup and migration</li>
</ul>
<h3 id="considerations-3"><a class="header" href="#considerations-3">Considerations</a></h3>
<ul>
<li>Not suitable for distributed systems</li>
<li>Limited by local disk space</li>
<li>Single point of failure</li>
</ul>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')  # Using filesystem storage

# Documents are saved to jacs_data/documents/
doc = agent.create_document(json.dumps({
    'title': 'My Document'
}))
# Saved to: jacs_data/documents/{doc-id}/{version-id}.json
</code></pre>
<h2 id="aws-s3-storage-aws"><a class="header" href="#aws-s3-storage-aws">AWS S3 Storage (aws)</a></h2>
<p>Cloud object storage using Amazon S3.</p>
<h3 id="configuration-15"><a class="header" href="#configuration-15">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "aws",
  "jacs_data_directory": "s3://my-jacs-bucket/data"
}
</code></pre>
<h3 id="environment-variables-7"><a class="header" href="#environment-variables-7">Environment Variables</a></h3>
<pre><code class="language-bash">export AWS_ACCESS_KEY_ID="your-access-key"
export AWS_SECRET_ACCESS_KEY="your-secret-key"
export AWS_REGION="us-east-1"
</code></pre>
<h3 id="bucket-structure"><a class="header" href="#bucket-structure">Bucket Structure</a></h3>
<pre><code>my-jacs-bucket/
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {agent-id}/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ {version-id}.json
‚îÇ   ‚îú‚îÄ‚îÄ documents/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {document-id}/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ {version-id}.json
‚îÇ   ‚îî‚îÄ‚îÄ files/
‚îÇ       ‚îî‚îÄ‚îÄ {attachment-hash}
</code></pre>
<h3 id="use-cases-6"><a class="header" href="#use-cases-6">Use Cases</a></h3>
<ul>
<li>Production deployments</li>
<li>Distributed systems</li>
<li>High availability requirements</li>
<li>Large document volumes</li>
</ul>
<h3 id="advantages-1"><a class="header" href="#advantages-1">Advantages</a></h3>
<ul>
<li>Scalable storage</li>
<li>High durability (99.999999999%)</li>
<li>Geographic redundancy</li>
<li>Built-in versioning support</li>
</ul>
<h3 id="considerations-4"><a class="header" href="#considerations-4">Considerations</a></h3>
<ul>
<li>Requires AWS account</li>
<li>Network latency</li>
<li>Storage costs</li>
<li>IAM configuration needed</li>
</ul>
<h3 id="iam-policy"><a class="header" href="#iam-policy">IAM Policy</a></h3>
<p>Minimum required permissions:</p>
<pre><code class="language-json">{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::my-jacs-bucket",
        "arn:aws:s3:::my-jacs-bucket/*"
      ]
    }
  ]
}
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-python">import jacs
import json
import os

# Set AWS credentials
os.environ['AWS_ACCESS_KEY_ID'] = 'your-key'
os.environ['AWS_SECRET_ACCESS_KEY'] = 'your-secret'
os.environ['AWS_REGION'] = 'us-east-1'

agent = jacs.JacsAgent()
agent.load('./jacs.s3.config.json')

# Documents are saved to S3
doc = agent.create_document(json.dumps({
    'title': 'Cloud Document'
}))
</code></pre>
<h2 id="hai-cloud-storage-hai"><a class="header" href="#hai-cloud-storage-hai">HAI Cloud Storage (hai)</a></h2>
<p>Managed storage provided by HAI.</p>
<h3 id="configuration-16"><a class="header" href="#configuration-16">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "hai"
}
</code></pre>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>Managed infrastructure</li>
<li>Built-in agent registry</li>
<li>Cross-organization document sharing</li>
<li>Integrated DNS verification</li>
</ul>
<h3 id="use-cases-7"><a class="header" href="#use-cases-7">Use Cases</a></h3>
<ul>
<li>Multi-agent ecosystems</li>
<li>Cross-organization collaboration</li>
<li>Managed deployments</li>
<li>Integration with HAI services</li>
</ul>
<h2 id="postgresql-database-storage-database"><a class="header" href="#postgresql-database-storage-database">PostgreSQL Database Storage (database)</a></h2>
<p>The <code>database</code> storage backend stores JACS documents in PostgreSQL, enabling JSONB queries, pagination, and agent-based lookups while preserving cryptographic signatures.</p>
<p>This backend is behind a compile-time feature flag and requires the <code>database</code> Cargo feature to be enabled.</p>
<h3 id="compile-time-setup"><a class="header" href="#compile-time-setup">Compile-Time Setup</a></h3>
<pre><code class="language-bash"># Build with database support
cargo build --features database

# Run tests with database support (requires Docker for testcontainers)
cargo test --features database-tests
</code></pre>
<h3 id="configuration-17"><a class="header" href="#configuration-17">Configuration</a></h3>
<pre><code class="language-json">{
  "jacs_default_storage": "database"
}
</code></pre>
<p>Environment variables (12-Factor compliant):</p>
<pre><code class="language-bash">export JACS_DATABASE_URL="postgres://user:password@localhost:5432/jacs"
export JACS_DATABASE_MAX_CONNECTIONS=10       # optional, default 10
export JACS_DATABASE_MIN_CONNECTIONS=1        # optional, default 1
export JACS_DATABASE_CONNECT_TIMEOUT_SECS=30  # optional, default 30
</code></pre>
<h3 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h3>
<p>JACS uses a <strong>TEXT + JSONB dual-column</strong> strategy:</p>
<ul>
<li><strong><code>raw_contents</code> (TEXT)</strong>: Stores the exact JSON bytes as-is. This is used when retrieving documents to preserve cryptographic signatures (PostgreSQL JSONB normalizes key ordering, which would break signatures).</li>
<li><strong><code>file_contents</code> (JSONB)</strong>: Stores the same document as JSONB for efficient queries, field extraction, and indexing.</li>
</ul>
<h3 id="table-schema"><a class="header" href="#table-schema">Table Schema</a></h3>
<pre><code class="language-sql">CREATE TABLE jacs_document (
    jacs_id TEXT NOT NULL,
    jacs_version TEXT NOT NULL,
    agent_id TEXT,
    jacs_type TEXT NOT NULL,
    raw_contents TEXT NOT NULL,
    file_contents JSONB NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (jacs_id, jacs_version)
);
</code></pre>
<h3 id="append-only-model"><a class="header" href="#append-only-model">Append-Only Model</a></h3>
<p>Documents are <strong>immutable once stored</strong>. New versions create new rows keyed by <code>(jacs_id, jacs_version)</code>. There are no UPDATE operations on existing rows. Inserting a duplicate <code>(jacs_id, jacs_version)</code> is silently ignored (<code>ON CONFLICT DO NOTHING</code>).</p>
<h3 id="query-capabilities"><a class="header" href="#query-capabilities">Query Capabilities</a></h3>
<p>The database backend provides additional query methods beyond basic CRUD:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>query_by_type(type, limit, offset)</code></td><td>Paginated queries by document type</td></tr>
<tr><td><code>query_by_field(field, value, type, limit, offset)</code></td><td>JSONB field queries</td></tr>
<tr><td><code>count_by_type(type)</code></td><td>Count documents by type</td></tr>
<tr><td><code>get_versions(id)</code></td><td>All versions of a document</td></tr>
<tr><td><code>get_latest(id)</code></td><td>Most recent version</td></tr>
<tr><td><code>query_by_agent(agent_id, type, limit, offset)</code></td><td>Documents by signing agent</td></tr>
</tbody></table>
</div>
<h3 id="rust-api-example"><a class="header" href="#rust-api-example">Rust API Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::storage::{DatabaseStorage, DatabaseDocumentTraits, StorageDocumentTraits};

// Create storage (requires tokio runtime)
let storage = DatabaseStorage::new(
    "postgres://localhost/jacs",
    Some(10),  // max connections
    Some(1),   // min connections
    Some(30),  // timeout seconds
)?;

// Run migrations (creates table + indexes)
storage.run_migrations()?;

// Store a document
storage.store_document(&amp;doc)?;

// Query by type with pagination
let commitments = storage.query_by_type("commitment", 10, 0)?;

// Query by JSONB field
let active = storage.query_by_field(
    "jacsCommitmentStatus", "active", Some("commitment"), 10, 0
)?;

// Get latest version
let latest = storage.get_latest("some-document-id")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="security-note"><a class="header" href="#security-note">Security Note</a></h3>
<p>Even when using database storage, <strong>keys are always loaded from the filesystem or keyservers</strong> -- never from the database or configuration providers. The database stores only signed documents.</p>
<h3 id="use-cases-8"><a class="header" href="#use-cases-8">Use Cases</a></h3>
<ul>
<li>Production deployments requiring complex queries</li>
<li>Multi-agent systems with shared document visibility</li>
<li>Applications needing pagination and aggregation</li>
<li>Environments where JSONB indexing provides significant query performance</li>
</ul>
<h3 id="considerations-5"><a class="header" href="#considerations-5">Considerations</a></h3>
<ul>
<li>Requires PostgreSQL 14+</li>
<li>Requires tokio runtime (not available in WASM)</li>
<li>Compile-time feature flag (<code>database</code>)</li>
<li>Network dependency on PostgreSQL server</li>
</ul>
<h2 id="in-memory-storage"><a class="header" href="#in-memory-storage">In-Memory Storage</a></h2>
<p>For testing and temporary operations, documents can be created without saving:</p>
<pre><code class="language-python"># Create document without saving
doc = agent.create_document(
    json.dumps({'temp': 'data'}),
    no_save=True  # Don't persist
)
</code></pre>
<pre><code class="language-javascript">const doc = agent.createDocument(
  JSON.stringify({ temp: 'data' }),
  null,  // custom_schema
  null,  // output_filename
  true   // no_save = true
);
</code></pre>
<h2 id="storage-selection-guide"><a class="header" href="#storage-selection-guide">Storage Selection Guide</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Recommended Backend</th></tr></thead><tbody>
<tr><td>Development</td><td><code>fs</code></td></tr>
<tr><td>Single server</td><td><code>fs</code></td></tr>
<tr><td>Complex queries needed</td><td><code>database</code></td></tr>
<tr><td>Multi-agent with shared queries</td><td><code>database</code></td></tr>
<tr><td>Cloud deployment</td><td><code>aws</code></td></tr>
<tr><td>High availability</td><td><code>aws</code></td></tr>
<tr><td>Multi-organization</td><td><code>hai</code></td></tr>
<tr><td>Testing</td><td>In-memory (no_save)</td></tr>
</tbody></table>
</div>
<h2 id="file-storage"><a class="header" href="#file-storage">File Storage</a></h2>
<h3 id="embedded-files"><a class="header" href="#embedded-files">Embedded Files</a></h3>
<p>Files can be embedded directly in documents:</p>
<pre><code class="language-python">doc = agent.create_document(
    json.dumps({'report': 'Monthly Report'}),
    attachments='./report.pdf',
    embed=True
)
</code></pre>
<p>The file contents are base64-encoded and stored in <code>jacsFiles</code>.</p>
<h3 id="external-files"><a class="header" href="#external-files">External Files</a></h3>
<p>Or reference files without embedding:</p>
<pre><code class="language-python">doc = agent.create_document(
    json.dumps({'report': 'Monthly Report'}),
    attachments='./report.pdf',
    embed=False
)
</code></pre>
<p>Only the file path and hash are stored. The file must be available when the document is accessed.</p>
<h2 id="data-migration"><a class="header" href="#data-migration">Data Migration</a></h2>
<h3 id="filesystem-to-s3"><a class="header" href="#filesystem-to-s3">Filesystem to S3</a></h3>
<pre><code class="language-python">import jacs
import json
import os

# Load from filesystem
fs_agent = jacs.JacsAgent()
fs_agent.load('./jacs.fs.config.json')

# Read all documents
# (implementation depends on your document tracking)

# Configure S3
s3_agent = jacs.JacsAgent()
s3_agent.load('./jacs.s3.config.json')

# Re-create documents in S3
for doc_json in documents:
    doc = json.loads(doc_json)
    # Remove existing signatures for re-signing
    del doc['jacsSignature']
    del doc['jacsSha256']
    s3_agent.create_document(json.dumps(doc))
</code></pre>
<h3 id="exportimport"><a class="header" href="#exportimport">Export/Import</a></h3>
<p>For manual migration:</p>
<pre><code class="language-bash"># Export from filesystem
tar -czf jacs_backup.tar.gz ./jacs_data

# Import to new location
tar -xzf jacs_backup.tar.gz -C /new/location
</code></pre>
<h2 id="backup-and-recovery"><a class="header" href="#backup-and-recovery">Backup and Recovery</a></h2>
<h3 id="filesystem-backup"><a class="header" href="#filesystem-backup">Filesystem Backup</a></h3>
<pre><code class="language-bash"># Regular backups
rsync -av ./jacs_data/ /backup/jacs_data/

# Or with timestamp
tar -czf jacs_backup_$(date +%Y%m%d).tar.gz ./jacs_data
</code></pre>
<h3 id="s3-backup"><a class="header" href="#s3-backup">S3 Backup</a></h3>
<p>Enable S3 versioning for automatic backups:</p>
<pre><code class="language-bash">aws s3api put-bucket-versioning \
    --bucket my-jacs-bucket \
    --versioning-configuration Status=Enabled
</code></pre>
<h3 id="cross-region-replication"><a class="header" href="#cross-region-replication">Cross-Region Replication</a></h3>
<p>For disaster recovery with S3:</p>
<pre><code class="language-bash">aws s3api put-bucket-replication \
    --bucket my-jacs-bucket \
    --replication-configuration file://replication.json
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="filesystem"><a class="header" href="#filesystem">Filesystem</a></h3>
<ul>
<li>Use SSD storage</li>
<li>Consider separate disk for jacs_data</li>
<li>Enable filesystem caching</li>
</ul>
<h3 id="s3"><a class="header" href="#s3">S3</a></h3>
<ul>
<li>Use regional endpoints</li>
<li>Enable transfer acceleration for global access</li>
<li>Consider S3 Intelligent-Tiering for cost optimization</li>
</ul>
<h3 id="caching-1"><a class="header" href="#caching-1">Caching</a></h3>
<p>Implement application-level caching for frequently accessed documents:</p>
<pre><code class="language-python">import functools

@functools.lru_cache(maxsize=100)
def get_document(doc_id, version_id):
    return agent.get_document(f"{doc_id}:{version_id}")
</code></pre>
<h2 id="security-considerations-7"><a class="header" href="#security-considerations-7">Security Considerations</a></h2>
<h3 id="filesystem-1"><a class="header" href="#filesystem-1">Filesystem</a></h3>
<pre><code class="language-bash"># Restrict permissions
chmod 700 ./jacs_data
chmod 600 ./jacs_data/**/*.json
</code></pre>
<h3 id="s3-1"><a class="header" href="#s3-1">S3</a></h3>
<ul>
<li>Enable encryption at rest (SSE-S3 or SSE-KMS)</li>
<li>Use VPC endpoints for private access</li>
<li>Enable access logging</li>
<li>Configure bucket policies carefully</li>
</ul>
<pre><code class="language-json">{
  "jacs_data_directory": "s3://my-jacs-bucket/data",
  "aws_s3_encryption": "AES256"
}
</code></pre>
<h2 id="see-also-16"><a class="header" href="#see-also-16">See Also</a></h2>
<ul>
<li><a href="advanced/../schemas/configuration.html">Configuration</a> - Storage configuration options</li>
<li><a href="advanced/security.html">Security Model</a> - Storage security</li>
<li><a href="advanced/../getting-started/quickstart.html">Quick Start</a> - Initial setup</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-schemas"><a class="header" href="#custom-schemas">Custom Schemas</a></h1>
<p>JACS allows you to define custom document schemas that extend the base header schema, enabling type-safe, validated documents for your specific use cases.</p>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>Custom schemas:</p>
<ul>
<li>Inherit all JACS header fields (jacsId, jacsVersion, jacsSignature, etc.)</li>
<li>Add domain-specific fields with validation</li>
<li>Enable IDE autocompletion and type checking</li>
<li>Ensure document consistency across your application</li>
</ul>
<h2 id="creating-a-custom-schema"><a class="header" href="#creating-a-custom-schema">Creating a Custom Schema</a></h2>
<h3 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h3>
<p>Custom schemas extend the JACS header using <code>allOf</code>:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://example.com/schemas/invoice.schema.json",
  "title": "Invoice",
  "description": "Invoice document with JACS signing",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "invoiceNumber": {
          "type": "string",
          "description": "Unique invoice identifier"
        },
        "amount": {
          "type": "number",
          "minimum": 0
        },
        "currency": {
          "type": "string",
          "enum": ["USD", "EUR", "GBP"]
        }
      },
      "required": ["invoiceNumber", "amount"]
    }
  ]
}
</code></pre>
<h3 id="step-by-step-guide"><a class="header" href="#step-by-step-guide">Step-by-Step Guide</a></h3>
<ol>
<li><strong>Create the schema file</strong></li>
</ol>
<pre><code class="language-json">// schemas/order.schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://mycompany.com/schemas/order.schema.json",
  "title": "Order",
  "description": "E-commerce order document",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "string",
          "pattern": "^ORD-[0-9]{6}$"
        },
        "customer": {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "email": { "type": "string", "format": "email" }
          },
          "required": ["name", "email"]
        },
        "items": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "properties": {
              "sku": { "type": "string" },
              "quantity": { "type": "integer", "minimum": 1 },
              "price": { "type": "number", "minimum": 0 }
            },
            "required": ["sku", "quantity", "price"]
          }
        },
        "total": {
          "type": "number",
          "minimum": 0
        },
        "status": {
          "type": "string",
          "enum": ["pending", "processing", "shipped", "delivered", "cancelled"]
        }
      },
      "required": ["orderId", "customer", "items", "total", "status"]
    }
  ]
}
</code></pre>
<ol start="2">
<li><strong>Use the schema when creating documents</strong></li>
</ol>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

order = agent.create_document(
    json.dumps({
        'orderId': 'ORD-123456',
        'customer': {
            'name': 'Jane Smith',
            'email': 'jane@example.com'
        },
        'items': [
            {'sku': 'WIDGET-001', 'quantity': 2, 'price': 29.99}
        ],
        'total': 59.98,
        'status': 'pending'
    }),
    custom_schema='./schemas/order.schema.json'
)
</code></pre>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');

const order = agent.createDocument(
  JSON.stringify({
    orderId: 'ORD-123456',
    customer: {
      name: 'Jane Smith',
      email: 'jane@example.com'
    },
    items: [
      { sku: 'WIDGET-001', quantity: 2, price: 29.99 }
    ],
    total: 59.98,
    status: 'pending'
  }),
  './schemas/order.schema.json'
);
</code></pre>
<h2 id="schema-best-practices"><a class="header" href="#schema-best-practices">Schema Best Practices</a></h2>
<h3 id="use-meaningful-ids"><a class="header" href="#use-meaningful-ids">Use Meaningful IDs</a></h3>
<pre><code class="language-json">{
  "$id": "https://mycompany.com/schemas/v1/order.schema.json"
}
</code></pre>
<p>Include version in the path for schema evolution.</p>
<h3 id="document-everything"><a class="header" href="#document-everything">Document Everything</a></h3>
<pre><code class="language-json">{
  "properties": {
    "status": {
      "type": "string",
      "description": "Current order status in the fulfillment workflow",
      "enum": ["pending", "processing", "shipped", "delivered", "cancelled"]
    }
  }
}
</code></pre>
<h3 id="use-appropriate-validation"><a class="header" href="#use-appropriate-validation">Use Appropriate Validation</a></h3>
<pre><code class="language-json">{
  "properties": {
    "email": {
      "type": "string",
      "format": "email"
    },
    "phone": {
      "type": "string",
      "pattern": "^\\+?[1-9]\\d{1,14}$"
    },
    "quantity": {
      "type": "integer",
      "minimum": 1,
      "maximum": 1000
    }
  }
}
</code></pre>
<h3 id="group-related-fields"><a class="header" href="#group-related-fields">Group Related Fields</a></h3>
<pre><code class="language-json">{
  "properties": {
    "shipping": {
      "type": "object",
      "properties": {
        "address": { "type": "string" },
        "city": { "type": "string" },
        "country": { "type": "string" },
        "postalCode": { "type": "string" }
      }
    },
    "billing": {
      "type": "object",
      "properties": {
        "address": { "type": "string" },
        "city": { "type": "string" },
        "country": { "type": "string" },
        "postalCode": { "type": "string" }
      }
    }
  }
}
</code></pre>
<h2 id="advanced-schema-features"><a class="header" href="#advanced-schema-features">Advanced Schema Features</a></h2>
<h3 id="conditional-validation"><a class="header" href="#conditional-validation">Conditional Validation</a></h3>
<p>Different requirements based on field values:</p>
<pre><code class="language-json">{
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "paymentMethod": {
          "type": "string",
          "enum": ["credit_card", "bank_transfer", "crypto"]
        }
      }
    }
  ],
  "if": {
    "properties": {
      "paymentMethod": { "const": "credit_card" }
    }
  },
  "then": {
    "properties": {
      "cardLastFour": {
        "type": "string",
        "pattern": "^[0-9]{4}$"
      }
    },
    "required": ["cardLastFour"]
  }
}
</code></pre>
<h3 id="reusable-definitions"><a class="header" href="#reusable-definitions">Reusable Definitions</a></h3>
<pre><code class="language-json">{
  "$defs": {
    "address": {
      "type": "object",
      "properties": {
        "street": { "type": "string" },
        "city": { "type": "string" },
        "country": { "type": "string" },
        "postalCode": { "type": "string" }
      },
      "required": ["street", "city", "country"]
    }
  },
  "properties": {
    "shippingAddress": { "$ref": "#/$defs/address" },
    "billingAddress": { "$ref": "#/$defs/address" }
  }
}
</code></pre>
<h3 id="array-constraints"><a class="header" href="#array-constraints">Array Constraints</a></h3>
<pre><code class="language-json">{
  "properties": {
    "tags": {
      "type": "array",
      "items": { "type": "string" },
      "minItems": 1,
      "maxItems": 10,
      "uniqueItems": true
    }
  }
}
</code></pre>
<h3 id="pattern-properties"><a class="header" href="#pattern-properties">Pattern Properties</a></h3>
<p>For dynamic field names:</p>
<pre><code class="language-json">{
  "properties": {
    "metadata": {
      "type": "object",
      "patternProperties": {
        "^x-": { "type": "string" }
      },
      "additionalProperties": false
    }
  }
}
</code></pre>
<h2 id="schema-inheritance"><a class="header" href="#schema-inheritance">Schema Inheritance</a></h2>
<h3 id="extending-custom-schemas"><a class="header" href="#extending-custom-schemas">Extending Custom Schemas</a></h3>
<p>Create schema hierarchies:</p>
<pre><code class="language-json">// schemas/base-transaction.schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://example.com/schemas/base-transaction.schema.json",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "transactionId": { "type": "string" },
        "timestamp": { "type": "string", "format": "date-time" },
        "amount": { "type": "number" }
      },
      "required": ["transactionId", "timestamp", "amount"]
    }
  ]
}
</code></pre>
<pre><code class="language-json">// schemas/payment.schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://example.com/schemas/payment.schema.json",
  "allOf": [
    { "$ref": "https://example.com/schemas/base-transaction.schema.json" },
    {
      "type": "object",
      "properties": {
        "paymentMethod": { "type": "string" },
        "processorId": { "type": "string" }
      },
      "required": ["paymentMethod"]
    }
  ]
}
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<h3 id="python-validation"><a class="header" href="#python-validation">Python Validation</a></h3>
<pre><code class="language-python">import jacs
import json

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

try:
    # This will fail validation - missing required field
    doc = agent.create_document(
        json.dumps({
            'orderId': 'ORD-123456'
            # Missing: customer, items, total, status
        }),
        custom_schema='./schemas/order.schema.json'
    )
except Exception as e:
    print(f"Validation failed: {e}")
</code></pre>
<h3 id="nodejs-validation"><a class="header" href="#nodejs-validation">Node.js Validation</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
agent.load('./jacs.config.json');

try {
  // This will fail - invalid enum value
  const doc = agent.createDocument(
    JSON.stringify({
      orderId: 'ORD-123456',
      customer: { name: 'Jane', email: 'jane@example.com' },
      items: [{ sku: 'A', quantity: 1, price: 10 }],
      total: 10,
      status: 'invalid_status'  // Not in enum
    }),
    './schemas/order.schema.json'
  );
} catch (error) {
  console.error('Validation failed:', error.message);
}
</code></pre>
<h2 id="example-schemas"><a class="header" href="#example-schemas">Example Schemas</a></h2>
<h3 id="medical-record"><a class="header" href="#medical-record">Medical Record</a></h3>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://healthcare.example.com/schemas/medical-record.schema.json",
  "title": "Medical Record",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "patientId": { "type": "string" },
        "recordType": {
          "type": "string",
          "enum": ["visit", "lab_result", "prescription", "diagnosis"]
        },
        "provider": {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "npi": { "type": "string", "pattern": "^[0-9]{10}$" }
          }
        },
        "date": { "type": "string", "format": "date" },
        "notes": { "type": "string" },
        "confidential": { "type": "boolean", "default": true }
      },
      "required": ["patientId", "recordType", "provider", "date"]
    }
  ]
}
</code></pre>
<h3 id="legal-contract"><a class="header" href="#legal-contract">Legal Contract</a></h3>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://legal.example.com/schemas/contract.schema.json",
  "title": "Legal Contract",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "contractNumber": { "type": "string" },
        "parties": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "role": { "type": "string" },
              "agentId": { "type": "string", "format": "uuid" }
            }
          }
        },
        "effectiveDate": { "type": "string", "format": "date" },
        "expirationDate": { "type": "string", "format": "date" },
        "terms": { "type": "string" },
        "jurisdiction": { "type": "string" }
      },
      "required": ["contractNumber", "parties", "effectiveDate", "terms"]
    }
  ]
}
</code></pre>
<h3 id="iot-sensor-reading"><a class="header" href="#iot-sensor-reading">IoT Sensor Reading</a></h3>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://iot.example.com/schemas/sensor-reading.schema.json",
  "title": "Sensor Reading",
  "allOf": [
    { "$ref": "https://hai.ai/schemas/header/v1/header.schema.json" },
    {
      "type": "object",
      "properties": {
        "deviceId": { "type": "string" },
        "sensorType": {
          "type": "string",
          "enum": ["temperature", "humidity", "pressure", "motion"]
        },
        "value": { "type": "number" },
        "unit": { "type": "string" },
        "timestamp": { "type": "string", "format": "date-time" },
        "location": {
          "type": "object",
          "properties": {
            "latitude": { "type": "number" },
            "longitude": { "type": "number" }
          }
        }
      },
      "required": ["deviceId", "sensorType", "value", "timestamp"]
    }
  ]
}
</code></pre>
<h2 id="schema-versioning"><a class="header" href="#schema-versioning">Schema Versioning</a></h2>
<h3 id="version-in-path"><a class="header" href="#version-in-path">Version in Path</a></h3>
<pre><code class="language-json">{
  "$id": "https://example.com/schemas/v1/order.schema.json"
}
</code></pre>
<h3 id="version-field"><a class="header" href="#version-field">Version Field</a></h3>
<pre><code class="language-json">{
  "properties": {
    "schemaVersion": {
      "type": "string",
      "const": "1.0.0"
    }
  }
}
</code></pre>
<h3 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h3>
<ol>
<li>Create new schema version</li>
<li>Update application to support both versions</li>
<li>Migrate existing documents</li>
<li>Deprecate old version</li>
</ol>
<h2 id="see-also-17"><a class="header" href="#see-also-17">See Also</a></h2>
<ul>
<li><a href="advanced/../schemas/overview.html">JSON Schemas Overview</a> - Built-in schemas</li>
<li><a href="advanced/../schemas/document.html">Document Schema</a> - Header fields</li>
<li><a href="advanced/../schemas/configuration.html">Configuration</a> - Schema configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-2"><a class="header" href="#testing-2">Testing</a></h1>
<p>This chapter covers testing strategies for applications that use JACS, including unit testing, integration testing, and mocking approaches.</p>
<h2 id="testing-fundamentals"><a class="header" href="#testing-fundamentals">Testing Fundamentals</a></h2>
<h3 id="test-agent-setup"><a class="header" href="#test-agent-setup">Test Agent Setup</a></h3>
<p>Create dedicated test configurations to isolate tests from production:</p>
<pre><code class="language-json">// jacs.test.config.json
{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./test_data",
  "jacs_key_directory": "./test_keys",
  "jacs_agent_private_key_filename": "test_private.pem",
  "jacs_agent_public_key_filename": "test_public.pem",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_default_storage": "fs"
}
</code></pre>
<h3 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h3>
<p>Set up test fixtures before running tests:</p>
<p><strong>Python (pytest)</strong>:</p>
<pre><code class="language-python">import pytest
import jacs
import tempfile
import shutil

@pytest.fixture
def test_agent():
    """Create a test agent with temporary directories."""
    temp_dir = tempfile.mkdtemp()
    data_dir = f"{temp_dir}/data"
    key_dir = f"{temp_dir}/keys"

    # Initialize directories
    import os
    os.makedirs(data_dir)
    os.makedirs(key_dir)

    # Create test config
    config = {
        "jacs_data_directory": data_dir,
        "jacs_key_directory": key_dir,
        "jacs_agent_key_algorithm": "ring-Ed25519",
        "jacs_default_storage": "fs"
    }

    config_path = f"{temp_dir}/jacs.config.json"
    with open(config_path, 'w') as f:
        import json
        json.dump(config, f)

    agent = jacs.JacsAgent()
    agent.load(config_path)

    yield agent

    # Cleanup
    shutil.rmtree(temp_dir)

def test_create_document(test_agent):
    """Test document creation."""
    import json
    doc = test_agent.create_document(json.dumps({
        'title': 'Test Document'
    }))

    assert doc is not None
    parsed = json.loads(doc)
    assert 'jacsId' in parsed
    assert 'jacsSignature' in parsed
</code></pre>
<p><strong>Node.js (Jest)</strong>:</p>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';
import path from 'path';
import os from 'os';

describe('JACS Document Tests', () =&gt; {
  let agent;
  let tempDir;

  beforeAll(() =&gt; {
    // Create temp directory
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'jacs-test-'));
    const dataDir = path.join(tempDir, 'data');
    const keyDir = path.join(tempDir, 'keys');

    fs.mkdirSync(dataDir);
    fs.mkdirSync(keyDir);

    // Create test config
    const config = {
      jacs_data_directory: dataDir,
      jacs_key_directory: keyDir,
      jacs_agent_key_algorithm: 'ring-Ed25519',
      jacs_default_storage: 'fs'
    };

    const configPath = path.join(tempDir, 'jacs.config.json');
    fs.writeFileSync(configPath, JSON.stringify(config));

    agent = new JacsAgent();
    agent.load(configPath);
  });

  afterAll(() =&gt; {
    // Cleanup
    fs.rmSync(tempDir, { recursive: true });
  });

  test('creates a signed document', () =&gt; {
    const doc = agent.createDocument(JSON.stringify({
      title: 'Test Document'
    }));

    const parsed = JSON.parse(doc);
    expect(parsed.jacsId).toBeDefined();
    expect(parsed.jacsSignature).toBeDefined();
  });
});
</code></pre>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<h3 id="testing-document-operations"><a class="header" href="#testing-document-operations">Testing Document Operations</a></h3>
<pre><code class="language-python">import pytest
import jacs
import json

def test_document_verification(test_agent):
    """Test that created documents verify correctly."""
    doc = test_agent.create_document(json.dumps({
        'content': 'Test content'
    }))

    is_valid = test_agent.verify_document(doc)
    assert is_valid is True

def test_document_tampering_detected(test_agent):
    """Test that tampered documents fail verification."""
    doc = test_agent.create_document(json.dumps({
        'content': 'Original content'
    }))

    # Tamper with the document
    parsed = json.loads(doc)
    parsed['content'] = 'Tampered content'
    tampered = json.dumps(parsed)

    is_valid = test_agent.verify_document(tampered)
    assert is_valid is False

def test_signature_verification(test_agent):
    """Test signature verification."""
    doc = test_agent.create_document(json.dumps({
        'data': 'test'
    }))

    is_valid = test_agent.verify_signature(doc)
    assert is_valid is True
</code></pre>
<h3 id="testing-agreements"><a class="header" href="#testing-agreements">Testing Agreements</a></h3>
<pre><code class="language-python">def test_agreement_creation(test_agent):
    """Test creating a document with agreement."""
    doc = test_agent.create_document(json.dumps({
        'contract': 'Service Agreement'
    }))

    # Add agreement
    doc_with_agreement = test_agent.create_agreement(
        doc,
        ['agent-1-id', 'agent-2-id'],
        question='Do you agree to these terms?',
        context='Test agreement'
    )

    parsed = json.loads(doc_with_agreement)
    assert 'jacsAgreement' in parsed
    assert len(parsed['jacsAgreement']['agentIDs']) == 2

def test_agreement_signing(test_agent):
    """Test signing an agreement."""
    doc = test_agent.create_document(json.dumps({
        'contract': 'Test'
    }))

    agent_json = test_agent.load('./jacs.test.config.json')
    agent_data = json.loads(agent_json)
    agent_id = agent_data['jacsId']

    doc_with_agreement = test_agent.create_agreement(
        doc,
        [agent_id],
        question='Agree?'
    )

    signed = test_agent.sign_agreement(doc_with_agreement)

    status_json = test_agent.check_agreement(signed)
    status = json.loads(status_json)

    assert status['complete'] is True
</code></pre>
<h3 id="agreement-completion-semantics-strict"><a class="header" href="#agreement-completion-semantics-strict">Agreement Completion Semantics (Strict)</a></h3>
<p><code>check_agreement()</code> is intentionally strict: it should fail until <strong>all</strong> required signers have signed. Add explicit tests for each state:</p>
<ol>
<li>Unsigned agreement: must fail.</li>
<li>Partially signed agreement: must still fail.</li>
<li>Fully signed agreement: must pass with <code>complete == true</code>.</li>
</ol>
<p>This prevents accidental "partial approval" workflows in production.</p>
<h3 id="two-agent-agreement-harness-separate-agents"><a class="header" href="#two-agent-agreement-harness-separate-agents">Two-Agent Agreement Harness (Separate Agents)</a></h3>
<p>For realistic interoperability tests, use <strong>two separate agents</strong> with:</p>
<ul>
<li>Separate key directories (<code>agent1/keys</code>, <code>agent2/keys</code>)</li>
<li>Shared data directory (<code>shared-data</code>) so both public keys are locally resolvable</li>
<li>Relative paths from a temporary test working directory</li>
</ul>
<p><strong>Python (pytest)</strong>:</p>
<pre><code class="language-python">def test_two_party_agreement_requires_both_signatures(tmp_path):
    import os
    import pytest
    import jacs.simple as simple

    (tmp_path / "shared-data").mkdir()
    (tmp_path / "agent1").mkdir()
    (tmp_path / "agent2").mkdir()

    original_cwd = os.getcwd()
    try:
        os.chdir(tmp_path)
        a1 = simple.create(
            name="agent-1",
            password="TestP@ss123!#",
            algorithm="ring-Ed25519",
            data_directory="shared-data",
            key_directory="agent1/keys",
            config_path="agent1/jacs.config.json",
        )
        a2 = simple.create(
            name="agent-2",
            password="TestP@ss123!#",
            algorithm="ring-Ed25519",
            data_directory="shared-data",
            key_directory="agent2/keys",
            config_path="agent2/jacs.config.json",
        )

        simple.load("agent1/jacs.config.json")
        agreement = simple.create_agreement(
            {"proposal": "two-party-approval"},
            [a1.agent_id, a2.agent_id],
            question="Approve?",
        )

        with pytest.raises(Exception):
            simple.check_agreement(agreement)
        signed_by_a1 = simple.sign_agreement(agreement)
        with pytest.raises(Exception):
            simple.check_agreement(signed_by_a1)

        simple.load("agent2/jacs.config.json")
        signed_by_both = simple.sign_agreement(signed_by_a1)
        status = simple.check_agreement(signed_by_both)
        assert status.complete is True
    finally:
        os.chdir(original_cwd)
</code></pre>
<p><strong>Node.js (Mocha/Jest style)</strong>:</p>
<pre><code class="language-javascript">const root = fs.mkdtempSync(path.join(os.tmpdir(), 'jacs-two-agent-'));
const originalCwd = process.cwd();
try {
  process.chdir(root);
  fs.mkdirSync('agent1', { recursive: true });
  fs.mkdirSync('agent2', { recursive: true });

  simpleA.create({
    name: 'agent-a',
    password: 'TestP@ss123!#',
    algorithm: 'ring-Ed25519',
    dataDirectory: 'shared-data',
    keyDirectory: 'agent1/keys',
    configPath: 'agent1/jacs.config.json'
  });
  simpleB.create({
    name: 'agent-b',
    password: 'TestP@ss123!#',
    algorithm: 'ring-Ed25519',
    dataDirectory: 'shared-data',
    keyDirectory: 'agent2/keys',
    configPath: 'agent2/jacs.config.json'
  });

  simpleA.load('agent1/jacs.config.json');
  simpleB.load('agent2/jacs.config.json');
  const infoA = simpleA.getAgentInfo();
  const infoB = simpleB.getAgentInfo();

  const agreement = simpleA.createAgreement(
    { proposal: 'two-party-approval' },
    [infoA.agentId, infoB.agentId]
  );

  expect(() =&gt; simpleA.checkAgreement(agreement)).to.throw();
  const signedByA = simpleA.signAgreement(agreement);
  expect(() =&gt; simpleA.checkAgreement(signedByA)).to.throw();

  const signedByBoth = simpleB.signAgreement(signedByA);
  const status = simpleB.checkAgreement(signedByBoth);
  expect(status.complete).to.equal(true);
} finally {
  process.chdir(originalCwd);
  fs.rmSync(root, { recursive: true, force: true });
}
</code></pre>
<h3 id="testing-requestresponse-signing"><a class="header" href="#testing-requestresponse-signing">Testing Request/Response Signing</a></h3>
<pre><code class="language-python">def test_request_signing(test_agent):
    """Test signing a request payload."""
    payload = {
        'method': 'tools/call',
        'params': {'name': 'test_tool'}
    }

    signed = test_agent.sign_request(payload)
    assert signed is not None

    # Verify the signed request
    result = test_agent.verify_response(signed)
    assert result is not None
    assert 'payload' in result
</code></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="testing-mcp-integration"><a class="header" href="#testing-mcp-integration">Testing MCP Integration</a></h3>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">import pytest
import asyncio
from jacs.mcp import JACSMCPServer, JACSMCPClient
from fastmcp import FastMCP

@pytest.fixture
def mcp_server(test_agent):
    """Create a test MCP server."""
    mcp = FastMCP("Test Server")

    @mcp.tool()
    def echo(text: str) -&gt; str:
        return f"Echo: {text}"

    return JACSMCPServer(mcp)

@pytest.mark.asyncio
async def test_mcp_tool_call(mcp_server, test_agent):
    """Test calling an MCP tool with JACS authentication."""
    # This would require setting up actual server/client connection
    # For unit testing, test the signing/verification separately
    pass
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-javascript">import { JACSExpressMiddleware } from '@hai.ai/jacs/http';
import express from 'express';
import request from 'supertest';

describe('JACS Express Middleware', () =&gt; {
  let app;
  let agent;

  beforeAll(() =&gt; {
    app = express();
    app.use('/api', express.text({ type: '*/*' }));
    app.use('/api', JACSExpressMiddleware({
      configPath: './jacs.test.config.json'
    }));

    app.post('/api/echo', (req, res) =&gt; {
      res.send({ echo: req.jacsPayload });
    });

    agent = new JacsAgent();
    agent.load('./jacs.test.config.json');
  });

  test('accepts valid JACS requests', async () =&gt; {
    const signedRequest = agent.signRequest({
      message: 'Hello'
    });

    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send(signedRequest);

    expect(response.status).toBe(200);
  });

  test('rejects invalid requests', async () =&gt; {
    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send('{"invalid": "request"}');

    expect(response.status).toBe(400);
  });
});
</code></pre>
<h3 id="testing-http-endpoints"><a class="header" href="#testing-http-endpoints">Testing HTTP Endpoints</a></h3>
<pre><code class="language-python">import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient
import jacs
import json

app = FastAPI()

@app.post("/api/document")
async def create_doc(request_body: str):
    agent = jacs.JacsAgent()
    agent.load('./jacs.test.config.json')

    result = agent.verify_response(request_body)
    if result:
        # Process the verified payload
        return {"status": "success", "payload": result.get("payload")}
    return {"status": "error"}

@pytest.fixture
def client():
    return TestClient(app)

def test_endpoint_accepts_signed_request(client, test_agent):
    """Test that endpoint accepts properly signed requests."""
    signed = test_agent.sign_request({
        'action': 'create',
        'data': {'title': 'Test'}
    })

    response = client.post("/api/document", content=signed)
    assert response.status_code == 200
</code></pre>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<h3 id="mocking-jacs-agent"><a class="header" href="#mocking-jacs-agent">Mocking JACS Agent</a></h3>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">from unittest.mock import Mock, patch
import json

def test_with_mocked_agent():
    """Test with a mocked JACS agent."""
    mock_agent = Mock()

    # Mock create_document to return a fake signed document
    mock_agent.create_document.return_value = json.dumps({
        'jacsId': 'mock-id',
        'jacsVersion': 'mock-version',
        'content': 'test',
        'jacsSignature': {'signature': 'mock-sig'}
    })

    # Mock verify_document to always return True
    mock_agent.verify_document.return_value = True

    # Use the mock in your tests
    doc = mock_agent.create_document(json.dumps({'content': 'test'}))
    assert mock_agent.verify_document(doc) is True
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-javascript">// Mock for testing
const mockAgent = {
  createDocument: jest.fn().mockReturnValue(JSON.stringify({
    jacsId: 'mock-id',
    jacsVersion: 'mock-version',
    content: 'test',
    jacsSignature: { signature: 'mock-sig' }
  })),
  verifyDocument: jest.fn().mockReturnValue(true),
  signRequest: jest.fn().mockImplementation((payload) =&gt;
    JSON.stringify({ payload, jacsSignature: { signature: 'mock' } })
  ),
  verifyResponse: jest.fn().mockImplementation((response) =&gt;
    ({ payload: JSON.parse(response).payload })
  )
};

test('uses mocked agent', () =&gt; {
  const doc = mockAgent.createDocument(JSON.stringify({ test: true }));
  expect(mockAgent.createDocument).toHaveBeenCalled();
  expect(mockAgent.verifyDocument(doc)).toBe(true);
});
</code></pre>
<h3 id="mocking-mcp-transport"><a class="header" href="#mocking-mcp-transport">Mocking MCP Transport</a></h3>
<pre><code class="language-javascript">// Mock transport for MCP testing
class MockTransport {
  constructor() {
    this.messages = [];
  }

  send(message) {
    this.messages.push(message);
  }

  async receive() {
    return this.messages.shift();
  }
}

test('MCP client with mock transport', async () =&gt; {
  const mockTransport = new MockTransport();
  // Use mock transport in tests
});
</code></pre>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="rust-coverage"><a class="header" href="#rust-coverage">Rust Coverage</a></h3>
<p>For Rust coverage, we recommend <strong>cargo-llvm-cov</strong> for its cross-platform support and accuracy with cryptographic code.</p>
<p><strong>Installation:</strong></p>
<pre><code class="language-bash">cargo install cargo-llvm-cov
</code></pre>
<p><strong>Running coverage:</strong></p>
<pre><code class="language-bash"># Print coverage summary to stdout
cargo llvm-cov

# Generate and open HTML report in browser
cargo llvm-cov --open

# With specific features enabled
cargo llvm-cov --features cli

# Export LCOV format for CI integration
cargo llvm-cov --lcov --output-path lcov.info
</code></pre>
<p><strong>Why cargo-llvm-cov?</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Factor</th><th>cargo-llvm-cov</th><th>tarpaulin</th></tr></thead><tbody>
<tr><td>Platform support</td><td>Linux, macOS, Windows</td><td>Linux primarily</td></tr>
<tr><td>Accuracy</td><td>LLVM source-based (highly accurate)</td><td>Ptrace-based (some inaccuracies)</td></tr>
<tr><td>Coverage types</td><td>Line, region, branch</td><td>Line primarily</td></tr>
</tbody></table>
</div>
<p>For CI integration, export to LCOV format and upload to Codecov or similar services.</p>
<h3 id="python-coverage"><a class="header" href="#python-coverage">Python Coverage</a></h3>
<pre><code class="language-bash"># Run tests with coverage
pytest --cov=myapp --cov-report=html tests/

# View coverage report
open htmlcov/index.html
</code></pre>
<h3 id="nodejs-coverage"><a class="header" href="#nodejs-coverage">Node.js Coverage</a></h3>
<pre><code class="language-bash"># Run tests with coverage
npm test -- --coverage

# Or with Jest directly
jest --coverage
</code></pre>
<h2 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Generate test keys
        run: |
          mkdir -p test_keys test_data
          # Generate test keys (implementation depends on your setup)

      - name: Run tests
        run: npm test

      - name: Upload coverage
        uses: codecov/codecov-action@v3
</code></pre>
<h3 id="test-environment-variables"><a class="header" href="#test-environment-variables">Test Environment Variables</a></h3>
<pre><code class="language-bash"># Set test environment
export JACS_TEST_MODE=1
export JACS_TEST_CONFIG=./jacs.test.config.json
</code></pre>
<h2 id="raii-test-fixtures-rust"><a class="header" href="#raii-test-fixtures-rust">RAII Test Fixtures (Rust)</a></h2>
<p>For Rust tests that modify global state (environment variables, file system, etc.), use RAII guards to ensure cleanup even on panic. This pattern is essential for test isolation and reliability.</p>
<h3 id="trusttestguard-pattern"><a class="header" href="#trusttestguard-pattern">TrustTestGuard Pattern</a></h3>
<p>The JACS codebase uses a <code>TrustTestGuard</code> pattern for tests that modify the HOME environment variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
use tempfile::TempDir;

/// RAII guard for test isolation that ensures HOME is restored even on panic.
struct TrustTestGuard {
    _temp_dir: TempDir,
    original_home: Option&lt;String&gt;,
}

impl TrustTestGuard {
    fn new() -&gt; Self {
        // Save original HOME before modifying
        let original_home = env::var("HOME").ok();

        let temp_dir = TempDir::new().expect("Failed to create temp directory");

        // SAFETY: Only used in #[serial] tests - no concurrent access
        unsafe {
            env::set_var("HOME", temp_dir.path().to_str().unwrap());
        }

        Self {
            _temp_dir: temp_dir,
            original_home,
        }
    }
}

impl Drop for TrustTestGuard {
    fn drop(&amp;mut self) {
        // Restore original HOME even during panic unwinding
        unsafe {
            match &amp;self.original_home {
                Some(home) =&gt; env::set_var("HOME", home),
                None =&gt; env::remove_var("HOME"),
            }
        }
    }
}

// Usage in tests:
#[test]
#[serial]  // Use serial_test crate to prevent parallel execution
fn test_with_isolated_home() {
    let _guard = TrustTestGuard::new();  // Setup

    // Test code here - HOME points to temp directory

    // Guard automatically restores HOME on drop, even if test panics
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key benefits:</strong></p>
<ul>
<li><strong>Panic safety</strong>: Cleanup runs even if the test panics</li>
<li><strong>No manual cleanup</strong>: Drop trait handles restoration automatically</li>
<li><strong>Environment isolation</strong>: Each test gets a fresh temporary directory</li>
<li><strong>Composable</strong>: Multiple guards can be combined for complex setups</li>
</ul>
<h2 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h2>
<p>For cryptographic code, property-based testing helps verify invariants that hold across many random inputs. We recommend <a href="https://crates.io/crates/proptest">proptest</a> for Rust.</p>
<h3 id="key-properties-to-test"><a class="header" href="#key-properties-to-test">Key Properties to Test</a></h3>
<ol>
<li><strong>Round-trip</strong>: Sign then verify should always succeed</li>
<li><strong>Tamper detection</strong>: Modified content should fail verification</li>
<li><strong>Key independence</strong>: Different keys produce different signatures</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn signature_roundtrip(content in ".*") {
        let signed = sign_content(&amp;content)?;
        prop_assert!(verify_signature(&amp;signed).is_ok());
    }

    #[test]
    fn tamper_detection(content in ".*", tamper_pos in 0usize..1000) {
        let signed = sign_content(&amp;content)?;
        let tampered = tamper_at_position(&amp;signed, tamper_pos);
        prop_assert!(verify_signature(&amp;tampered).is_err());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h2>
<p>Fuzz testing is recommended for parsing and decoding functions to discover edge cases and potential security issues.</p>
<h3 id="recommended-tool-cargo-fuzz"><a class="header" href="#recommended-tool-cargo-fuzz">Recommended Tool: cargo-fuzz</a></h3>
<pre><code class="language-bash"># Install
cargo install cargo-fuzz

# Create a fuzz target
cargo fuzz init
cargo fuzz add base64_decode

# Run fuzzing
cargo +nightly fuzz run base64_decode
</code></pre>
<h3 id="priority-fuzz-targets-for-jacs"><a class="header" href="#priority-fuzz-targets-for-jacs">Priority Fuzz Targets for JACS</a></h3>
<ol>
<li><strong>Base64 decoding</strong> - Handles untrusted input from signatures</li>
<li><strong>Agent JSON parsing</strong> - Complex nested structures</li>
<li><strong>Document validation</strong> - Schema compliance checking</li>
<li><strong>Timestamp parsing</strong> - Date/time format handling</li>
</ol>
<p>Fuzzing documentation will be expanded as fuzz targets are added to the JACS test suite.</p>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-isolate-tests"><a class="header" href="#1-isolate-tests">1. Isolate Tests</a></h3>
<ul>
<li>Use separate test configurations</li>
<li>Create temporary directories for each test run</li>
<li>Clean up after tests (use RAII guards in Rust)</li>
</ul>
<h3 id="2-test-edge-cases"><a class="header" href="#2-test-edge-cases">2. Test Edge Cases</a></h3>
<pre><code class="language-python">def test_empty_document():
    """Test handling of empty documents."""
    with pytest.raises(Exception):
        test_agent.create_document('')

def test_invalid_json():
    """Test handling of invalid JSON."""
    with pytest.raises(Exception):
        test_agent.create_document('not json')

def test_large_document():
    """Test handling of large documents."""
    large_content = 'x' * 1000000
    doc = test_agent.create_document(json.dumps({
        'content': large_content
    }))
    assert doc is not None
</code></pre>
<h3 id="3-test-security-properties"><a class="header" href="#3-test-security-properties">3. Test Security Properties</a></h3>
<pre><code class="language-python">def test_signature_changes_with_content():
    """Verify different content produces different signatures."""
    doc1 = test_agent.create_document(json.dumps({'a': 1}))
    doc2 = test_agent.create_document(json.dumps({'a': 2}))

    sig1 = json.loads(doc1)['jacsSignature']['signature']
    sig2 = json.loads(doc2)['jacsSignature']['signature']

    assert sig1 != sig2
</code></pre>
<h3 id="4-test-error-handling"><a class="header" href="#4-test-error-handling">4. Test Error Handling</a></h3>
<pre><code class="language-python">def test_verify_invalid_signature():
    """Test that invalid signatures are rejected."""
    doc = test_agent.create_document(json.dumps({'data': 'test'}))
    parsed = json.loads(doc)

    # Corrupt the signature
    parsed['jacsSignature']['signature'] = 'invalid'
    corrupted = json.dumps(parsed)

    assert test_agent.verify_document(corrupted) is False
</code></pre>
<h2 id="see-also-18"><a class="header" href="#see-also-18">See Also</a></h2>
<ul>
<li><a href="advanced/../python/api.html">Python API Reference</a> - API documentation</li>
<li><a href="advanced/../nodejs/api.html">Node.js API Reference</a> - API documentation</li>
<li><a href="advanced/security.html">Security Model</a> - Security testing considerations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-context-protocol-mcp"><a class="header" href="#model-context-protocol-mcp">Model Context Protocol (MCP)</a></h1>
<p>JACS provides comprehensive integration with the <a href="https://modelcontextprotocol.io/">Model Context Protocol (MCP)</a>, enabling cryptographically signed and verified communication between AI agents and MCP servers.</p>
<h2 id="what-is-mcp-1"><a class="header" href="#what-is-mcp-1">What is MCP?</a></h2>
<p>Model Context Protocol is an open standard created by Anthropic for AI models to securely access external tools, data, and services. MCP defines:</p>
<ul>
<li><strong>Tools</strong>: Functions that AI models can call</li>
<li><strong>Resources</strong>: Data sources that models can read</li>
<li><strong>Prompts</strong>: Pre-defined prompt templates</li>
<li><strong>Transports</strong>: Communication channels (STDIO, SSE, WebSocket)</li>
</ul>
<h2 id="why-jacs--mcp"><a class="header" href="#why-jacs--mcp">Why JACS + MCP?</a></h2>
<p>JACS enhances MCP by adding a security layer that standard MCP lacks:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Standard MCP</th><th>JACS MCP</th></tr></thead><tbody>
<tr><td>Message Signing</td><td>No</td><td>Yes</td></tr>
<tr><td>Identity Verification</td><td>No</td><td>Yes</td></tr>
<tr><td>Tamper Detection</td><td>No</td><td>Yes</td></tr>
<tr><td>Audit Trail</td><td>No</td><td>Yes</td></tr>
<tr><td>Non-Repudiation</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>This makes JACS MCP suitable for:</p>
<ul>
<li>Multi-agent systems requiring trust</li>
<li>Financial and legal AI applications</li>
<li>Healthcare AI systems</li>
<li>Enterprise deployments</li>
<li>Any scenario where message authenticity matters</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>JACS uses a <strong>transport proxy pattern</strong> that wraps any MCP transport with cryptographic signing and verification:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      MCP Application                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                       MCP SDK                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                  JACS Transport Proxy                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ Outgoing:   ‚îÇ                    ‚îÇ Incoming:    ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ signRequest ‚îÇ                    ‚îÇ verifyResp   ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ               Underlying Transport                           ‚îÇ
‚îÇ           (STDIO / SSE / WebSocket)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h3 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h3>
<ol>
<li><strong>Outgoing Messages</strong>: The proxy intercepts JSON-RPC messages and signs them with the agent's private key</li>
<li><strong>Incoming Messages</strong>: The proxy verifies signatures before passing messages to the application</li>
<li><strong>Graceful Fallback</strong>: If verification fails, messages can be passed through as plain JSON for interoperability</li>
</ol>
<h2 id="quick-start-9"><a class="header" href="#quick-start-9">Quick Start</a></h2>
<h3 id="nodejs-3"><a class="header" href="#nodejs-3">Node.js</a></h3>
<pre><code class="language-javascript">import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { z } from 'zod';

// Create transport with JACS encryption
const baseTransport = new StdioServerTransport();
const secureTransport = createJACSTransportProxy(
  baseTransport,
  "./jacs.config.json",
  "server"
);

// Create MCP server
const server = new McpServer({
  name: "my-secure-server",
  version: "1.0.0"
});

// Register tools (standard MCP API)
server.tool("add", {
  a: z.number(),
  b: z.number()
}, async ({ a, b }) =&gt; {
  return { content: [{ type: "text", text: `${a + b}` }] };
});

// Connect with JACS encryption
await server.connect(secureTransport);
</code></pre>
<h3 id="python-3"><a class="header" href="#python-3">Python</a></h3>
<pre><code class="language-python">import jacs
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import uvicorn

# Initialize JACS agent
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

# Create FastMCP server with JACS authentication
mcp = JACSMCPServer(FastMCP("Secure Server"))

@mcp.tool()
def add(a: int, b: int) -&gt; str:
    """Add two numbers"""
    return str(a + b)

# Get ASGI app with JACS middleware
app = mcp.sse_app()

if __name__ == "__main__":
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h2 id="language-support"><a class="header" href="#language-support">Language Support</a></h2>
<p>JACS provides native MCP integration for both major platforms:</p>
<h3 id="nodejs-haiaijacs"><a class="header" href="#nodejs-haiaijacs">Node.js (@hai.ai/jacs)</a></h3>
<p>The Node.js integration uses a transport proxy pattern that works with any MCP transport:</p>
<ul>
<li><strong>STDIO</strong>: For CLI tools and subprocess communication</li>
<li><strong>SSE</strong>: For web-based servers</li>
<li><strong>WebSocket</strong>: For bidirectional streaming</li>
</ul>
<p>Key classes:</p>
<ul>
<li><code>JACSTransportProxy</code> - Wraps any transport with signing/verification</li>
<li><code>createJACSTransportProxy()</code> - Factory function</li>
</ul>
<p>See <a href="integrations/../nodejs/mcp.html">Node.js MCP Integration</a> for complete documentation.</p>
<h3 id="python-jacspy"><a class="header" href="#python-jacspy">Python (jacspy)</a></h3>
<p>The Python integration uses middleware wrappers for FastMCP:</p>
<ul>
<li><strong>JACSMCPServer</strong> - Wraps FastMCP servers with authentication</li>
<li><strong>JACSMCPClient</strong> - Wraps FastMCP clients with signing</li>
</ul>
<p>Key classes:</p>
<ul>
<li><code>JACSMCPServer</code> - Server wrapper with JACS middleware</li>
<li><code>JACSMCPClient</code> - Client wrapper with interceptors</li>
</ul>
<p>See <a href="integrations/../python/mcp.html">Python MCP Integration</a> for complete documentation.</p>
<h2 id="message-flow"><a class="header" href="#message-flow">Message Flow</a></h2>
<h3 id="tool-call-example"><a class="header" href="#tool-call-example">Tool Call Example</a></h3>
<p>When a client calls a tool on a JACS-enabled MCP server:</p>
<pre><code>Client                          Server
  ‚îÇ                               ‚îÇ
  ‚îÇ  1. Create JSON-RPC request   ‚îÇ
  ‚îÇ  2. Sign with signRequest()   ‚îÇ
  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&gt;  ‚îÇ
  ‚îÇ                               ‚îÇ 3. Verify with verifyRequest()
  ‚îÇ                               ‚îÇ 4. Execute tool
  ‚îÇ                               ‚îÇ 5. Sign response with signResponse()
  ‚îÇ  &lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
  ‚îÇ  6. Verify with verifyResponse() ‚îÇ
  ‚îÇ  7. Extract payload           ‚îÇ
</code></pre>
<h3 id="signed-message-structure"><a class="header" href="#signed-message-structure">Signed Message Structure</a></h3>
<p>A JACS-signed MCP message contains:</p>
<pre><code class="language-json">{
  "jacsId": "unique-document-id",
  "jacsVersion": "version-uuid",
  "jacsSignature": {
    "agentID": "signing-agent-id",
    "agentVersion": "agent-version",
    "date": "2024-01-15T10:30:00Z",
    "signature": "base64-signature",
    "signingAlgorithm": "ring-Ed25519"
  },
  "jacsSha256": "content-hash",
  "payload": {
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": { "name": "add", "arguments": { "a": 5, "b": 3 } },
    "id": 1
  }
}
</code></pre>
<h2 id="configuration-18"><a class="header" href="#configuration-18">Configuration</a></h2>
<h3 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h3>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "server-agent-id:version",
  "jacs_default_storage": "fs"
}
</code></pre>
<h3 id="client-configuration"><a class="header" href="#client-configuration">Client Configuration</a></h3>
<p>Each MCP client needs its own JACS agent identity:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_agent_id_and_version": "client-agent-id:version",
  "jacs_default_storage": "fs"
}
</code></pre>
<h2 id="transports"><a class="header" href="#transports">Transports</a></h2>
<h3 id="stdio"><a class="header" href="#stdio">STDIO</a></h3>
<p>Best for CLI tools and subprocess communication:</p>
<pre><code class="language-javascript">// Node.js
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const baseTransport = new StdioServerTransport();
const secureTransport = createJACSTransportProxy(
  baseTransport,
  "./jacs.config.json",
  "server"
);
</code></pre>
<p><strong>Important</strong>: Debug logging goes to <code>stderr</code> to keep <code>stdout</code> clean for JSON-RPC.</p>
<h3 id="server-sent-events-sse"><a class="header" href="#server-sent-events-sse">Server-Sent Events (SSE)</a></h3>
<p>For web-based MCP servers:</p>
<pre><code class="language-python"># Python with FastMCP
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP

mcp = JACSMCPServer(FastMCP("Web Server"))
app = mcp.sse_app()  # Returns ASGI app with JACS middleware
</code></pre>
<pre><code class="language-javascript">// Node.js with Express
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import express from 'express';

const app = express();
app.get('/sse', (req, res) =&gt; {
  const baseTransport = new SSEServerTransport('/messages', res);
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    "./jacs.config.json",
    "server"
  );
  server.connect(secureTransport);
});
</code></pre>
<h2 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h2>
<h3 id="signing-is-sacred"><a class="header" href="#signing-is-sacred">Signing is Sacred</a></h3>
<p><strong>CRITICAL GUIDANCE FOR AI AGENTS AND DEVELOPERS</strong></p>
<p>Signing a document or message with JACS is a <strong>sacred, irreversible act</strong>. When an agent signs:</p>
<ol>
<li>
<p><strong>Permanent Commitment</strong>: The signature creates permanent cryptographic proof that the signer attested to the content. This proof exists forever and can be verified by anyone.</p>
</li>
<li>
<p><strong>Non-Repudiation</strong>: The signer cannot later deny having signed. The signature is mathematically bound to their private key.</p>
</li>
<li>
<p><strong>Accountability</strong>: The signer is accountable for the content they signed. In multi-agent systems, signatures establish trust chains and responsibility.</p>
</li>
<li>
<p><strong>Irreversibility</strong>: There is no "unsign" operation. Once signed, the commitment exists permanently.</p>
</li>
</ol>
<p><strong>Before signing any document, message, or agreement:</strong></p>
<ul>
<li>Read and understand the complete content</li>
<li>Verify the content represents your actual intent</li>
<li>Confirm you have authority to make this commitment</li>
<li>Understand the implications of your signature</li>
</ul>
<p><strong>For AI agents</strong>: Do not sign automatically or without verification. Signing carelessly can:</p>
<ul>
<li>Create binding commitments you didn't intend</li>
<li>Establish false audit trails</li>
<li>Damage trust relationships with other agents</li>
<li>Create legal or ethical liability</li>
</ul>
<p><strong>For MCP tool implementations</strong>: When exposing signing capabilities as tools, include appropriate warnings and consider requiring explicit confirmation.</p>
<h3 id="what-gets-signed"><a class="header" href="#what-gets-signed">What Gets Signed</a></h3>
<ul>
<li>All JSON-RPC requests and responses</li>
<li>Tool calls and results</li>
<li>Resource requests and data</li>
<li>Prompt requests and templates</li>
</ul>
<h3 id="what-gets-verified"><a class="header" href="#what-gets-verified">What Gets Verified</a></h3>
<ul>
<li>Agent identity (agentID)</li>
<li>Message integrity (jacsSha256)</li>
<li>Signature validity (jacsSignature)</li>
<li>Optional: DNS-based identity verification</li>
</ul>
<h3 id="passthrough-mode-1"><a class="header" href="#passthrough-mode-1">Passthrough Mode</a></h3>
<p>For interoperability with non-JACS MCP systems, the proxy can fall back to plain JSON:</p>
<ol>
<li>Try to verify as JACS artifact</li>
<li>If verification fails, parse as plain JSON</li>
<li>Pass clean message to application</li>
</ol>
<p>To enforce JACS-only communication, implement custom validation in your tools.</p>
<h2 id="debugging-2"><a class="header" href="#debugging-2">Debugging</a></h2>
<h3 id="enable-debug-logging-1"><a class="header" href="#enable-debug-logging-1">Enable Debug Logging</a></h3>
<pre><code class="language-bash"># Node.js
export JACS_MCP_DEBUG=true

# Python
import logging
logging.basicConfig(level=logging.DEBUG)
</code></pre>
<h3 id="common-issues-3"><a class="header" href="#common-issues-3">Common Issues</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Cause</th><th>Solution</th></tr></thead><tbody>
<tr><td>"JACS not operational"</td><td>Config path incorrect</td><td>Verify config file path</td></tr>
<tr><td>Verification failures</td><td>Incompatible keys</td><td>Ensure matching key algorithms</td></tr>
<tr><td>Empty responses</td><td>Null value handling</td><td>Check message serialization</td></tr>
<tr><td>Connection timeouts</td><td>Network issues</td><td>Verify server is running</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-separate-keys-for-server-and-client"><a class="header" href="#1-separate-keys-for-server-and-client">1. Separate Keys for Server and Client</a></h3>
<pre><code>project/
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ jacs.config.json
‚îÇ   ‚îî‚îÄ‚îÄ jacs_keys/
‚îÇ       ‚îú‚îÄ‚îÄ private.pem
‚îÇ       ‚îî‚îÄ‚îÄ public.pem
‚îî‚îÄ‚îÄ client/
    ‚îú‚îÄ‚îÄ jacs.config.json
    ‚îî‚îÄ‚îÄ jacs_keys/
        ‚îú‚îÄ‚îÄ private.pem
        ‚îî‚îÄ‚îÄ public.pem
</code></pre>
<h3 id="2-use-tls-for-network-transports"><a class="header" href="#2-use-tls-for-network-transports">2. Use TLS for Network Transports</a></h3>
<pre><code class="language-python"># Use HTTPS for SSE
client = JACSMCPClient("https://server.example.com/sse")
</code></pre>
<h3 id="3-implement-key-rotation"><a class="header" href="#3-implement-key-rotation">3. Implement Key Rotation</a></h3>
<p>Update agent versions when rotating keys:</p>
<pre><code class="language-json">{
  "jacs_agent_id_and_version": "my-agent:v2"
}
</code></pre>
<h3 id="4-log-security-events"><a class="header" href="#4-log-security-events">4. Log Security Events</a></h3>
<pre><code class="language-python"># Production logging setup
import logging

logging.getLogger("jacs").setLevel(logging.INFO)
logging.getLogger("jacs.security").setLevel(logging.WARNING)
</code></pre>
<h2 id="example-multi-agent-system"><a class="header" href="#example-multi-agent-system">Example: Multi-Agent System</a></h2>
<p>A complete example with multiple JACS-authenticated agents:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Agent A        ‚îÇ     ‚îÇ   MCP Server     ‚îÇ     ‚îÇ   Agent B        ‚îÇ
‚îÇ  (Data Analyst)  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ&gt;‚îÇ  (Tool Provider) ‚îÇ&lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  (Report Writer) ‚îÇ
‚îÇ                  ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                  ‚îÇ
‚îÇ Signs requests   ‚îÇ     ‚îÇ Verifies both    ‚îÇ     ‚îÇ Signs requests   ‚îÇ
‚îÇ Verifies resps   ‚îÇ     ‚îÇ Signs responses  ‚îÇ     ‚îÇ Verifies resps   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>Each agent has its own:</p>
<ul>
<li>JACS agent ID and version</li>
<li>Private/public key pair</li>
<li>Configuration file</li>
</ul>
<p>The MCP server verifies requests from both agents and signs all responses.</p>
<h2 id="hai-mcp-server-tools"><a class="header" href="#hai-mcp-server-tools">HAI MCP Server Tools</a></h2>
<p>The <code>jacs-mcp</code> server provides built-in tools for agent operations:</p>
<h3 id="identity--registration-tools"><a class="header" href="#identity--registration-tools">Identity &amp; Registration Tools</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fetch_agent_key</code></td><td>Fetch a public key from HAI's key distribution service</td></tr>
<tr><td><code>register_agent</code></td><td>Register the local agent with HAI (requires <code>JACS_MCP_ALLOW_REGISTRATION=true</code>)</td></tr>
<tr><td><code>verify_agent</code></td><td>Verify another agent's attestation level</td></tr>
<tr><td><code>check_agent_status</code></td><td>Check registration status with HAI</td></tr>
<tr><td><code>unregister_agent</code></td><td>Unregister an agent from HAI</td></tr>
</tbody></table>
</div>
<h3 id="agent-state-tools"><a class="header" href="#agent-state-tools">Agent State Tools</a></h3>
<p>These tools allow agents to sign, verify, and manage state documents (memory files, skills, plans, configs, hooks, or any document):</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jacs_sign_state</code></td><td>Create and sign a new agent state document</td></tr>
<tr><td><code>jacs_verify_state</code></td><td>Verify an existing agent state document's signature</td></tr>
<tr><td><code>jacs_load_state</code></td><td>Load an agent state document by key</td></tr>
<tr><td><code>jacs_update_state</code></td><td>Update and re-sign an agent state document</td></tr>
<tr><td><code>jacs_list_state</code></td><td>List all agent state documents</td></tr>
<tr><td><code>jacs_adopt_state</code></td><td>Adopt an external file as a signed agent state</td></tr>
</tbody></table>
</div>
<p>All documents are stored within the JACS data directory for security. Use <code>state_type: "other"</code> for general-purpose signing of any document.</p>
<p>See <a href="integrations/../schemas/agentstate.html">Agent State Schema</a> for full documentation.</p>
<h2 id="see-also-19"><a class="header" href="#see-also-19">See Also</a></h2>
<ul>
<li><a href="integrations/../nodejs/mcp.html">Node.js MCP Integration</a> - Node.js specific details</li>
<li><a href="integrations/../python/mcp.html">Python MCP Integration</a> - Python specific details</li>
<li><a href="integrations/../advanced/security.html">Security Model</a> - JACS security architecture</li>
<li><a href="integrations/../advanced/crypto.html">Cryptographic Algorithms</a> - Signing algorithms</li>
<li><a href="integrations/../advanced/testing.html">Testing</a> - Testing MCP integrations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a2a-interoperability"><a class="header" href="#a2a-interoperability">A2A Interoperability</a></h1>
<p>This guide describes how JACS interoperates with Agent-to-Agent (A2A) systems in real deployments.</p>
<h2 id="what-jacs-adds"><a class="header" href="#what-jacs-adds">What JACS Adds</a></h2>
<p>JACS adds cryptographic provenance to A2A artifacts:</p>
<ul>
<li>Signed artifact envelopes (<code>a2a-task</code>, <code>a2a-message</code>, etc.)</li>
<li>Verifiable signer identity via public key resolution</li>
<li>Chain-of-custody support through parent signatures</li>
<li>Well-known discovery documents for external verifiers</li>
</ul>
<h2 id="interoperability-contract"><a class="header" href="#interoperability-contract">Interoperability Contract</a></h2>
<p>JACS A2A integration currently targets the v0.4.0 Agent Card shape used in this repository's Rust, Python, and Node bindings.</p>
<p>Required well-known documents:</p>
<ul>
<li><code>/.well-known/agent-card.json</code></li>
<li><code>/.well-known/jwks.json</code></li>
<li><code>/.well-known/jacs-agent.json</code></li>
<li><code>/.well-known/jacs-pubkey.json</code></li>
</ul>
<h2 id="verification-model"><a class="header" href="#verification-model">Verification Model</a></h2>
<p>When verifying foreign-agent A2A artifacts, JACS resolves keys using <code>JACS_KEY_RESOLUTION</code> order:</p>
<ul>
<li><code>local</code>: trusted local key cache</li>
<li><code>dns</code>: identity validation only (does not return key bytes)</li>
<li><code>hai</code>: remote key retrieval from HAI key service</li>
</ul>
<p>If a key is found, JACS performs full signature verification and returns a verified status.
If no key is found, verification is explicitly marked unverified (not silently accepted).</p>
<h2 id="12-factor-runtime-configuration"><a class="header" href="#12-factor-runtime-configuration">12-Factor Runtime Configuration</a></h2>
<p>Use environment variables for deploy-time behavior:</p>
<pre><code class="language-bash">export JACS_PRIVATE_KEY_PASSWORD="your-strong-password"
export JACS_KEY_RESOLUTION="local,hai"
export HAI_KEYS_BASE_URL="https://keys.hai.ai"
</code></pre>
<p>For offline/air-gapped operation:</p>
<pre><code class="language-bash">export JACS_KEY_RESOLUTION="local"
</code></pre>
<h2 id="rust-example"><a class="header" href="#rust-example">Rust Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jacs::a2a::provenance::{wrap_artifact_with_provenance, verify_wrapped_artifact};
use serde_json::json;

let wrapped = wrap_artifact_with_provenance(
    &amp;mut agent,
    json!({"taskId": "task-123", "operation": "classify"}),
    "task",
    None,
)?;

let result = verify_wrapped_artifact(&amp;agent, &amp;wrapped)?;
assert!(result.valid);
<span class="boring">}</span></code></pre></pre>
<h2 id="python-example"><a class="header" href="#python-example">Python Example</a></h2>
<pre><code class="language-python">from jacs.a2a import JACSA2AIntegration

a2a = JACSA2AIntegration("jacs.config.json")
agent_card = a2a.export_agent_card(agent_data)
docs = a2a.generate_well_known_documents(
    agent_card=agent_card,
    jws_signature="...",
    public_key_b64="...",
    agent_data={"jacsId": "...", "jacsVersion": "...", "keyAlgorithm": "RSA-PSS"},
)

assert "/.well-known/jwks.json" in docs
</code></pre>
<h2 id="nodejs-example"><a class="header" href="#nodejs-example">Node.js Example</a></h2>
<pre><code class="language-javascript">const { JACSA2AIntegration } = require('@hai.ai/jacs/a2a');

const a2a = new JACSA2AIntegration('./jacs.config.json');
const wrapped = a2a.wrapArtifactWithProvenance(
  { taskId: 'task-123', operation: 'classify' },
  'task'
);

const result = a2a.verifyWrappedArtifact(wrapped);
console.log(result.valid, result.parentSignaturesValid);
</code></pre>
<h2 id="devex-expectations"><a class="header" href="#devex-expectations">DevEx Expectations</a></h2>
<p>Before merging A2A changes, ensure:</p>
<ol>
<li>Rust, Python, and Node A2A tests all pass.</li>
<li>Foreign-signature verification is covered by tests (resolved and unresolved key paths).</li>
<li>Documentation snippets match package names and executable APIs.</li>
<li>Well-known docs include <code>jwks.json</code> and match output from all bindings.</li>
</ol>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<ul>
<li><code>Unverified</code> foreign signatures: no signer key available from configured resolution order.</li>
<li><code>Invalid</code> signatures: signature bytes, signer key, or signed payload fields do not match.</li>
<li>Missing <code>jwks.json</code>: ensure you are using current A2A helper APIs in your binding.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openclaw-integration"><a class="header" href="#openclaw-integration">OpenClaw Integration</a></h1>
<p>OpenClaw is a personal AI assistant platform. This chapter covers integrating JACS with OpenClaw to enable cryptographically signed agent-to-agent communication.</p>
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>The JACS OpenClaw plugin enables:</p>
<ul>
<li><strong>Bootstrap JACS identity</strong> via <code>openclaw plugin setup jacs</code></li>
<li><strong>Securely store cryptographic keys</strong> using OpenClaw's configuration system</li>
<li><strong>Sign and verify all agent communications</strong> with post-quantum cryptographic provenance</li>
<li><strong>Publish agent identity</strong> via <code>.well-known</code> endpoints</li>
<li><strong>P2P agent verification</strong> without requiring a central registry</li>
</ul>
<h2 id="installation-5"><a class="header" href="#installation-5">Installation</a></h2>
<pre><code class="language-bash"># Install the JACS plugin for OpenClaw
openclaw plugins install @openclaw/jacs
</code></pre>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<h3 id="initialize-jacs-identity"><a class="header" href="#initialize-jacs-identity">Initialize JACS Identity</a></h3>
<pre><code class="language-bash"># Interactive setup wizard
openclaw jacs init
</code></pre>
<p>This will:</p>
<ol>
<li>Select a key algorithm (pq2025/dilithium/rsa/ecdsa)</li>
<li>Generate a cryptographic key pair</li>
<li>Create an agent identity</li>
<li>Store keys in <code>~/.openclaw/jacs_keys/</code></li>
</ol>
<h3 id="configuration-19"><a class="header" href="#configuration-19">Configuration</a></h3>
<p>The plugin configuration is stored in <code>~/.openclaw/openclaw.json</code>:</p>
<pre><code class="language-json">{
  "plugins": {
    "entries": {
      "jacs": {
        "enabled": true,
        "config": {
          "keyAlgorithm": "pq2025",
          "autoSign": false,
          "autoVerify": false,
          "agentId": "89fb9d88-6990-420f-8df9-252ccdfdfd3d",
          "agentName": "My OpenClaw Agent",
          "agentDescription": "Personal AI assistant with JACS identity"
        }
      }
    }
  }
}
</code></pre>
<h3 id="configuration-options-2"><a class="header" href="#configuration-options-2">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>keyAlgorithm</code></td><td>string</td><td><code>pq2025</code></td><td>Signing algorithm (pq2025, pq-dilithium, rsa, ecdsa)</td></tr>
<tr><td><code>autoSign</code></td><td>boolean</td><td><code>false</code></td><td>Automatically sign outbound messages</td></tr>
<tr><td><code>autoVerify</code></td><td>boolean</td><td><code>false</code></td><td>Automatically verify inbound JACS-signed messages</td></tr>
<tr><td><code>agentName</code></td><td>string</td><td>-</td><td>Human-readable agent name</td></tr>
<tr><td><code>agentDescription</code></td><td>string</td><td>-</td><td>Agent description for A2A discovery</td></tr>
<tr><td><code>agentDomain</code></td><td>string</td><td>-</td><td>Domain for agent identity (DNSSEC validated)</td></tr>
</tbody></table>
</div>
<h2 id="directory-structure-1"><a class="header" href="#directory-structure-1">Directory Structure</a></h2>
<pre><code>~/.openclaw/
‚îú‚îÄ‚îÄ openclaw.json              # Plugin config (non-sensitive)
‚îú‚îÄ‚îÄ jacs/                      # JACS data directory
‚îÇ   ‚îú‚îÄ‚îÄ jacs.config.json       # JACS configuration
‚îÇ   ‚îî‚îÄ‚îÄ agent/                 # Agent documents
‚îî‚îÄ‚îÄ jacs_keys/                 # Key directory (encrypted)
    ‚îú‚îÄ‚îÄ agent.private.pem.enc  # AES-256-GCM encrypted
    ‚îî‚îÄ‚îÄ agent.public.pem       # Public key (shareable)
</code></pre>
<h2 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h2>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<pre><code class="language-bash">openclaw jacs status
</code></pre>
<p>Shows JACS status, agent ID, algorithm, and registration state.</p>
<h3 id="sign-document"><a class="header" href="#sign-document">Sign Document</a></h3>
<pre><code class="language-bash">openclaw jacs sign &lt;file&gt;
</code></pre>
<p>Sign a JSON document with your JACS identity.</p>
<h3 id="verify-document-1"><a class="header" href="#verify-document-1">Verify Document</a></h3>
<pre><code class="language-bash">openclaw jacs verify &lt;file&gt;
</code></pre>
<p>Verify a JACS-signed document.</p>
<h3 id="lookup-agent-1"><a class="header" href="#lookup-agent-1">Lookup Agent</a></h3>
<pre><code class="language-bash">openclaw jacs lookup &lt;domain&gt;
</code></pre>
<p>Look up another agent's public key from their domain.</p>
<h3 id="export-agent-card"><a class="header" href="#export-agent-card">Export Agent Card</a></h3>
<pre><code class="language-bash">openclaw jacs export-card
</code></pre>
<p>Export your agent as an A2A Agent Card.</p>
<h3 id="generate-dns-record"><a class="header" href="#generate-dns-record">Generate DNS Record</a></h3>
<pre><code class="language-bash">openclaw jacs dns-record &lt;domain&gt;
</code></pre>
<p>Generate DNS TXT record commands for publishing your agent fingerprint.</p>
<h2 id="agent-tools"><a class="header" href="#agent-tools">Agent Tools</a></h2>
<p>The plugin provides tools for use in agent conversations:</p>
<h3 id="jacs_sign"><a class="header" href="#jacs_sign">jacs_sign</a></h3>
<p>Sign a document with JACS cryptographic provenance.</p>
<pre><code class="language-json">{
  "name": "jacs_sign",
  "parameters": {
    "document": { "message": "hello" },
    "artifactType": "message"
  }
}
</code></pre>
<h3 id="jacs_verify"><a class="header" href="#jacs_verify">jacs_verify</a></h3>
<p>Verify a JACS-signed document.</p>
<pre><code class="language-json">{
  "name": "jacs_verify",
  "parameters": {
    "document": { "...signed document..." }
  }
}
</code></pre>
<h3 id="jacs_fetch_pubkey"><a class="header" href="#jacs_fetch_pubkey">jacs_fetch_pubkey</a></h3>
<p>Fetch another agent's public key from their domain.</p>
<pre><code class="language-json">{
  "name": "jacs_fetch_pubkey",
  "parameters": {
    "domain": "other-agent.example.com"
  }
}
</code></pre>
<h3 id="jacs_verify_with_key"><a class="header" href="#jacs_verify_with_key">jacs_verify_with_key</a></h3>
<p>Verify a document using a fetched public key.</p>
<pre><code class="language-json">{
  "name": "jacs_verify_with_key",
  "parameters": {
    "document": { "...signed document..." },
    "publicKey": "-----BEGIN PUBLIC KEY-----..."
  }
}
</code></pre>
<h3 id="jacs_lookup_agent"><a class="header" href="#jacs_lookup_agent">jacs_lookup_agent</a></h3>
<p>Lookup a JACS agent by domain or ID.</p>
<pre><code class="language-json">{
  "name": "jacs_lookup_agent",
  "parameters": {
    "domain": "agent.example.com"
  }
}
</code></pre>
<h3 id="jacs_create_agreement"><a class="header" href="#jacs_create_agreement">jacs_create_agreement</a></h3>
<p>Create a multi-party agreement requiring signatures from multiple agents.</p>
<pre><code class="language-json">{
  "name": "jacs_create_agreement",
  "parameters": {
    "document": { "terms": "..." },
    "agentIds": ["agent-1-uuid", "agent-2-uuid"],
    "question": "Do you agree to these terms?"
  }
}
</code></pre>
<h2 id="well-known-endpoints"><a class="header" href="#well-known-endpoints">Well-Known Endpoints</a></h2>
<p>When OpenClaw's gateway is running, the plugin serves:</p>
<h3 id="well-knownagent-cardjson"><a class="header" href="#well-knownagent-cardjson"><code>/.well-known/agent-card.json</code></a></h3>
<p>A2A v0.4.0 Agent Card with JACS extension.</p>
<h3 id="well-knownjacs-pubkeyjson"><a class="header" href="#well-knownjacs-pubkeyjson"><code>/.well-known/jacs-pubkey.json</code></a></h3>
<p>Your agent's public key for verification:</p>
<pre><code class="language-json">{
  "publicKey": "-----BEGIN PUBLIC KEY-----...",
  "publicKeyHash": "sha256-hash",
  "algorithm": "pq2025",
  "agentId": "agent-uuid",
  "timestamp": "2024-01-15T10:30:00Z"
}
</code></pre>
<h2 id="p2p-agent-verification"><a class="header" href="#p2p-agent-verification">P2P Agent Verification</a></h2>
<p>Agents can verify each other without a central registry:</p>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<ol>
<li><strong>Agent A</strong> publishes their public key at <code>/.well-known/jacs-pubkey.json</code></li>
<li><strong>Agent A</strong> optionally sets DNS TXT record at <code>_v1.agent.jacs.&lt;domain&gt;.</code></li>
<li><strong>Agent A</strong> signs a document with <code>jacs_sign</code></li>
<li><strong>Agent B</strong> receives the signed document</li>
<li><strong>Agent B</strong> fetches Agent A's key with <code>jacs_fetch_pubkey</code></li>
<li><strong>Agent B</strong> verifies with <code>jacs_verify_with_key</code></li>
</ol>
<h3 id="example-workflow"><a class="header" href="#example-workflow">Example Workflow</a></h3>
<pre><code>Agent A (agent-a.example.com)          Agent B (agent-b.example.com)
================================       ================================

1. Initialize JACS
   openclaw jacs init

2. Publish public key
   (served at /.well-known/jacs-pubkey.json)

3. Sign a message
   jacs_sign({ message: "hello" })
   ‚Üí signed_doc

4. Send signed_doc to Agent B
                                       5. Receive signed_doc

                                       6. Fetch Agent A's public key
                                          jacs_fetch_pubkey("agent-a.example.com")
                                          ‚Üí pubkey_a

                                       7. Verify signature
                                          jacs_verify_with_key(signed_doc, pubkey_a)
                                          ‚Üí { valid: true, signer: "agent-a-uuid" }
</code></pre>
<h2 id="dns-based-discovery"><a class="header" href="#dns-based-discovery">DNS-Based Discovery</a></h2>
<p>For additional verification, agents can publish their public key fingerprint in DNS:</p>
<h3 id="generate-dns-record-1"><a class="header" href="#generate-dns-record-1">Generate DNS Record</a></h3>
<pre><code class="language-bash">openclaw jacs dns-record agent.example.com
</code></pre>
<p>This outputs commands for your DNS provider:</p>
<pre><code>_v1.agent.jacs.agent.example.com. 3600 IN TXT "v=hai.ai; jacs_agent_id=&lt;UUID&gt;; alg=SHA-256; enc=base64; jac_public_key_hash=&lt;44-char-b64&gt;"
</code></pre>
<h3 id="dns-lookup"><a class="header" href="#dns-lookup">DNS Lookup</a></h3>
<pre><code class="language-bash">openclaw jacs lookup agent.example.com
</code></pre>
<p>The plugin will:</p>
<ol>
<li>Query DNS TXT record at <code>_v1.agent.jacs.agent.example.com</code></li>
<li>Fetch full public key from <code>/.well-known/jacs-pubkey.json</code></li>
<li>Verify the DNS hash matches the fetched key</li>
</ol>
<h2 id="security-3"><a class="header" href="#security-3">Security</a></h2>
<h3 id="key-protection-1"><a class="header" href="#key-protection-1">Key Protection</a></h3>
<ul>
<li>Private keys are encrypted with AES-256-GCM</li>
<li>Password-derived key using PBKDF2 (100k iterations)</li>
<li>Keys stored with restricted file permissions</li>
</ul>
<h3 id="post-quantum-cryptography"><a class="header" href="#post-quantum-cryptography">Post-Quantum Cryptography</a></h3>
<p>The default algorithm (<code>pq2025</code> / ML-DSA-87) is quantum-resistant, providing protection against future quantum computing attacks.</p>
<h3 id="signature-binding"><a class="header" href="#signature-binding">Signature Binding</a></h3>
<p>Signatures include:</p>
<ul>
<li>Document hash (prevents modification)</li>
<li>Signer's agent ID and version</li>
<li>Timestamp</li>
<li>List of signed fields</li>
</ul>
<h2 id="skill-usage"><a class="header" href="#skill-usage">Skill Usage</a></h2>
<p>The plugin provides a skill for agent conversations:</p>
<pre><code>/jacs sign {"task": "analyze data", "result": "completed"}
/jacs verify &lt;paste signed document&gt;
/jacs lookup agent.example.com
</code></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="jacs-not-initialized"><a class="header" href="#jacs-not-initialized">"JACS not initialized"</a></h3>
<p>Run <code>openclaw jacs init</code> to set up your JACS identity.</p>
<h3 id="failed-to-fetch-public-key"><a class="header" href="#failed-to-fetch-public-key">"Failed to fetch public key"</a></h3>
<p>Verify the domain is correct and serving <code>/.well-known/jacs-pubkey.json</code>.</p>
<h3 id="signature-verification-failed"><a class="header" href="#signature-verification-failed">"Signature verification failed"</a></h3>
<ul>
<li>Check that the document hasn't been modified</li>
<li>Verify you have the correct public key for the signer</li>
<li>Ensure the signing algorithm matches</li>
</ul>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li><a href="integrations/../rust/dns.html">DNS-Based Verification</a> - Detailed DNS setup</li>
<li><a href="integrations/../rust/agreements.html">Agreements</a> - Multi-agent coordination</li>
<li><a href="integrations/mcp.html">MCP Integration</a> - Model Context Protocol</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-servers"><a class="header" href="#web-servers">Web Servers</a></h1>
<p>JACS provides middleware and utilities for building HTTP servers with cryptographic request/response signing across multiple frameworks and languages.</p>
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p>Web server integration with JACS enables:</p>
<ul>
<li><strong>Request Authentication</strong>: Verify incoming requests were signed by valid agents</li>
<li><strong>Response Signing</strong>: Automatically sign outgoing responses</li>
<li><strong>Tamper Detection</strong>: Ensure message integrity end-to-end</li>
<li><strong>Audit Trail</strong>: Track all authenticated interactions</li>
</ul>
<h2 id="supported-frameworks"><a class="header" href="#supported-frameworks">Supported Frameworks</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Framework</th><th>Language</th><th>Module</th></tr></thead><tbody>
<tr><td>Express.js</td><td>Node.js</td><td><code>@hai.ai/jacs/http</code></td></tr>
<tr><td>Koa</td><td>Node.js</td><td><code>@hai.ai/jacs/http</code></td></tr>
<tr><td>FastAPI</td><td>Python</td><td><code>jacs.http</code></td></tr>
<tr><td>Flask</td><td>Python</td><td><code>jacs.http</code></td></tr>
</tbody></table>
</div>
<h2 id="requestresponse-flow-1"><a class="header" href="#requestresponse-flow-1">Request/Response Flow</a></h2>
<p>All JACS web integrations follow the same flow:</p>
<pre><code>Client                          Server
  ‚îÇ                               ‚îÇ
  ‚îÇ‚îÄ‚îÄ signRequest(payload) ‚îÄ‚îÄ‚îÄ‚îÄ&gt;  ‚îÇ
  ‚îÇ                               ‚îÇ‚îÄ‚îÄ verifyRequest()
  ‚îÇ                               ‚îÇ‚îÄ‚îÄ process request
  ‚îÇ                               ‚îÇ‚îÄ‚îÄ signResponse(result)
  ‚îÇ&lt;‚îÄ‚îÄ verifyResponse(result) ‚îÄ‚îÄ  ‚îÇ
  ‚îÇ
</code></pre>
<h2 id="nodejs-integration"><a class="header" href="#nodejs-integration">Node.js Integration</a></h2>
<h3 id="expressjs"><a class="header" href="#expressjs">Express.js</a></h3>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();

// IMPORTANT: Parse body as text BEFORE JACS middleware
app.use('/api', express.text({ type: '*/*' }));

// Apply JACS middleware
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Route handlers receive verified payload in req.jacsPayload
app.post('/api/data', (req, res) =&gt; {
  const payload = req.jacsPayload;

  if (!payload) {
    return res.status(400).send({ error: 'Invalid JACS request' });
  }

  // Response objects are automatically signed
  res.send({
    received: payload,
    status: 'ok'
  });
});

app.listen(3000);
</code></pre>
<h3 id="koa"><a class="header" href="#koa">Koa</a></h3>
<pre><code class="language-javascript">import Koa from 'koa';
import { JACSKoaMiddleware } from '@hai.ai/jacs/http';

const app = new Koa();

// Apply JACS middleware (handles body parsing internally)
app.use(JACSKoaMiddleware({
  configPath: './jacs.config.json'
}));

app.use(async (ctx) =&gt; {
  if (ctx.path === '/api/data' &amp;&amp; ctx.method === 'POST') {
    const payload = ctx.state.jacsPayload;

    if (!payload) {
      ctx.status = 400;
      ctx.body = { error: 'Invalid JACS request' };
      return;
    }

    // Response objects are automatically signed
    ctx.body = {
      received: payload,
      status: 'ok'
    };
  }
});

app.listen(3000);
</code></pre>
<p>See <a href="integrations/../nodejs/http.html">Node.js HTTP Server</a> and <a href="integrations/../nodejs/express.html">Express Middleware</a> for complete documentation.</p>
<h2 id="python-integration"><a class="header" href="#python-integration">Python Integration</a></h2>
<h3 id="fastapi"><a class="header" href="#fastapi">FastAPI</a></h3>
<pre><code class="language-python">from fastapi import FastAPI, Request
from fastapi.responses import PlainTextResponse
import jacs
import json

app = FastAPI()

# Initialize JACS agent
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

@app.post("/api/data")
async def handle_data(request: Request):
    # Read raw body
    body = await request.body()
    body_str = body.decode('utf-8')

    # Verify JACS request
    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        return PlainTextResponse(
            content=json.dumps({"error": "Invalid JACS request"}),
            status_code=400
        )

    # Process request
    result = {"received": payload, "status": "ok"}

    # Sign response
    signed_response = jacs.sign_response(result)

    return PlainTextResponse(content=signed_response)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h3 id="flask"><a class="header" href="#flask">Flask</a></h3>
<pre><code class="language-python">from flask import Flask, request
import jacs
import json

app = Flask(__name__)

# Initialize JACS agent
agent = jacs.JacsAgent()
agent.load("./jacs.config.json")

@app.route("/api/data", methods=["POST"])
def handle_data():
    # Read raw body
    body_str = request.get_data(as_text=True)

    # Verify JACS request
    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        return json.dumps({"error": "Invalid JACS request"}), 400

    # Process request
    result = {"received": payload, "status": "ok"}

    # Sign response
    signed_response = jacs.sign_response(result)

    return signed_response, 200, {"Content-Type": "text/plain"}

if __name__ == "__main__":
    app.run(port=8000)
</code></pre>
<h2 id="http-client-1"><a class="header" href="#http-client-1">HTTP Client</a></h2>
<h3 id="nodejs-client"><a class="header" href="#nodejs-client">Node.js Client</a></h3>
<pre><code class="language-javascript">import jacs from '@hai.ai/jacs';

async function sendJacsRequest(url, payload) {
  // Load JACS agent
  await jacs.load('./jacs.client.config.json');

  // Sign the request
  const signedRequest = await jacs.signRequest(payload);

  // Send HTTP request
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: signedRequest
  });

  // Verify response
  const responseText = await response.text();
  const verified = await jacs.verifyResponse(responseText);

  return verified.payload;
}

// Usage
const result = await sendJacsRequest('http://localhost:3000/api/data', {
  action: 'fetch',
  query: { id: 42 }
});
</code></pre>
<h3 id="python-client"><a class="header" href="#python-client">Python Client</a></h3>
<pre><code class="language-python">import jacs
import requests
import json

def send_jacs_request(url, payload):
    # Initialize JACS agent
    agent = jacs.JacsAgent()
    agent.load("./jacs.client.config.json")

    # Sign the request
    signed_request = jacs.sign_request(payload)

    # Send HTTP request
    response = requests.post(
        url,
        data=signed_request,
        headers={"Content-Type": "text/plain"}
    )

    # Verify response
    verified = jacs.verify_response(response.text)
    return json.loads(verified).get('payload')

# Usage
result = send_jacs_request("http://localhost:8000/api/data", {
    "action": "fetch",
    "query": {"id": 42}
})
</code></pre>
<h2 id="middleware-patterns"><a class="header" href="#middleware-patterns">Middleware Patterns</a></h2>
<h3 id="route-level-protection"><a class="header" href="#route-level-protection">Route-Level Protection</a></h3>
<p>Protect specific routes while leaving others public:</p>
<pre><code class="language-javascript">// Node.js Express
const app = express();

// Public routes (no JACS)
app.get('/health', (req, res) =&gt; res.send({ status: 'ok' }));
app.get('/public/info', (req, res) =&gt; res.send({ name: 'My API' }));

// Protected routes (JACS required)
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));

app.post('/api/secure', (req, res) =&gt; {
  // Only JACS-signed requests reach here
  res.send({ data: 'secure response' });
});
</code></pre>
<h3 id="multiple-agent-configurations"><a class="header" href="#multiple-agent-configurations">Multiple Agent Configurations</a></h3>
<p>Use different JACS agents for different route groups:</p>
<pre><code class="language-javascript">// Admin routes with admin agent
app.use('/admin', express.text({ type: '*/*' }));
app.use('/admin', JACSExpressMiddleware({
  configPath: './jacs.admin.config.json'
}));

// User routes with user agent
app.use('/user', express.text({ type: '*/*' }));
app.use('/user', JACSExpressMiddleware({
  configPath: './jacs.user.config.json'
}));
</code></pre>
<h3 id="validation-middleware"><a class="header" href="#validation-middleware">Validation Middleware</a></h3>
<p>Create reusable validation helpers:</p>
<pre><code class="language-javascript">function requireJacsPayload(req, res, next) {
  if (!req.jacsPayload) {
    return res.status(400).json({
      error: 'JACS verification failed',
      message: 'Request must be signed with valid JACS credentials'
    });
  }
  next();
}

// Apply to routes
app.post('/api/secure', requireJacsPayload, (req, res) =&gt; {
  // Guaranteed to have valid req.jacsPayload
  res.send({ data: req.jacsPayload });
});
</code></pre>
<h2 id="content-type-considerations"><a class="header" href="#content-type-considerations">Content-Type Considerations</a></h2>
<p>JACS requests should use <code>text/plain</code> content type since they are signed JSON strings:</p>
<pre><code class="language-javascript">// Client side
const response = await fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'text/plain' },  // Not application/json
  body: signedRequest
});
</code></pre>
<pre><code class="language-javascript">// Server side (Express)
app.use('/api', express.text({ type: '*/*' }));  // Parse as text, not JSON
</code></pre>
<h2 id="error-handling-10"><a class="header" href="#error-handling-10">Error Handling</a></h2>
<h3 id="server-side-errors"><a class="header" href="#server-side-errors">Server-Side Errors</a></h3>
<pre><code class="language-javascript">app.post('/api/process', (req, res, next) =&gt; {
  try {
    if (!req.jacsPayload) {
      throw new Error('Missing JACS payload');
    }

    const result = processData(req.jacsPayload);
    res.send({ result });
  } catch (error) {
    next(error);
  }
});

// Global error handler
app.use((error, req, res, next) =&gt; {
  console.error('Error:', error.message);
  res.status(500).send({
    error: 'Internal server error',
    message: error.message
  });
});
</code></pre>
<h3 id="client-side-errors"><a class="header" href="#client-side-errors">Client-Side Errors</a></h3>
<pre><code class="language-javascript">try {
  const verified = await jacs.verifyResponse(responseText);
  return verified.payload;
} catch (error) {
  console.error('JACS verification failed:', error.message);
  // Handle invalid/tampered response
}
</code></pre>
<h2 id="security-best-practices-2"><a class="header" href="#security-best-practices-2">Security Best Practices</a></h2>
<h3 id="1-use-tls-in-production"><a class="header" href="#1-use-tls-in-production">1. Use TLS in Production</a></h3>
<p>Always use HTTPS for production deployments:</p>
<pre><code class="language-javascript">// Client
await sendJacsRequest('https://api.example.com/data', payload);
</code></pre>
<h3 id="2-separate-server-and-client-keys"><a class="header" href="#2-separate-server-and-client-keys">2. Separate Server and Client Keys</a></h3>
<p>Each endpoint needs its own JACS identity:</p>
<pre><code>project/
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ jacs.config.json
‚îÇ   ‚îî‚îÄ‚îÄ jacs_keys/
‚îÇ       ‚îú‚îÄ‚îÄ private.pem
‚îÇ       ‚îî‚îÄ‚îÄ public.pem
‚îî‚îÄ‚îÄ client/
    ‚îú‚îÄ‚îÄ jacs.config.json
    ‚îî‚îÄ‚îÄ jacs_keys/
        ‚îú‚îÄ‚îÄ private.pem
        ‚îî‚îÄ‚îÄ public.pem
</code></pre>
<h3 id="3-middleware-order-matters"><a class="header" href="#3-middleware-order-matters">3. Middleware Order Matters</a></h3>
<p>For Express, ensure correct middleware order:</p>
<pre><code class="language-javascript">// Correct order
app.use('/api', express.text({ type: '*/*' }));     // 1. Parse body
app.use('/api', JACSExpressMiddleware({ ... }));    // 2. JACS verification

// Wrong order - JACS won't receive string body
app.use('/api', JACSExpressMiddleware({ ... }));
app.use('/api', express.text({ type: '*/*' }));
</code></pre>
<h3 id="4-avoid-json-body-parser-conflicts"><a class="header" href="#4-avoid-json-body-parser-conflicts">4. Avoid JSON Body Parser Conflicts</a></h3>
<p>Don't mix <code>express.json()</code> with JACS routes:</p>
<pre><code class="language-javascript">// JSON for non-JACS routes
app.use('/public', express.json());

// Text for JACS routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ ... }));
</code></pre>
<h2 id="logging-and-auditing"><a class="header" href="#logging-and-auditing">Logging and Auditing</a></h2>
<p>Log JACS requests for security auditing:</p>
<pre><code class="language-javascript">function jacsLogger(req, res, next) {
  if (req.jacsPayload) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      method: req.method,
      path: req.path,
      jacsPayload: req.jacsPayload,
      ip: req.ip
    }));
  }
  next();
}

app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({ configPath: './jacs.config.json' }));
app.use('/api', jacsLogger);  // After JACS middleware
</code></pre>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<h3 id="testing-with-supertest"><a class="header" href="#testing-with-supertest">Testing with Supertest</a></h3>
<pre><code class="language-javascript">import request from 'supertest';
import jacs from '@hai.ai/jacs';

describe('JACS API', () =&gt; {
  beforeAll(async () =&gt; {
    await jacs.load('./jacs.test.config.json');
  });

  it('should accept valid JACS requests', async () =&gt; {
    const payload = { action: 'test', data: 'hello' };
    const signedRequest = await jacs.signRequest(payload);

    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send(signedRequest);

    expect(response.status).toBe(200);

    // Verify response is JACS-signed
    const verified = await jacs.verifyResponse(response.text);
    expect(verified.payload.echo).toEqual(payload);
  });

  it('should reject unsigned requests', async () =&gt; {
    const response = await request(app)
      .post('/api/echo')
      .set('Content-Type', 'text/plain')
      .send('{"invalid": "request"}');

    expect(response.status).toBe(400);
  });
});
</code></pre>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="common-issues-4"><a class="header" href="#common-issues-4">Common Issues</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Cause</th><th>Solution</th></tr></thead><tbody>
<tr><td><code>req.jacsPayload</code> undefined</td><td>Wrong middleware order</td><td>Put <code>express.text()</code> before JACS middleware</td></tr>
<tr><td>Response not signed</td><td>Sending string instead of object</td><td>Use <code>res.send({ ... })</code> not <code>res.send(JSON.stringify(...))</code></td></tr>
<tr><td>Verification failures</td><td>Key mismatch</td><td>Ensure compatible JACS configurations</td></tr>
<tr><td>Connection refused</td><td>Server not running</td><td>Verify server is listening on correct port</td></tr>
</tbody></table>
</div>
<h3 id="debug-logging"><a class="header" href="#debug-logging">Debug Logging</a></h3>
<pre><code class="language-javascript">// Node.js
process.env.JACS_DEBUG = 'true';
</code></pre>
<pre><code class="language-python"># Python
import logging
logging.basicConfig(level=logging.DEBUG)
</code></pre>
<h2 id="see-also-20"><a class="header" href="#see-also-20">See Also</a></h2>
<ul>
<li><a href="integrations/../nodejs/http.html">Node.js HTTP Server</a> - Detailed Node.js documentation</li>
<li><a href="integrations/../nodejs/express.html">Express Middleware</a> - Express-specific patterns</li>
<li><a href="integrations/mcp.html">MCP Integration</a> - Model Context Protocol support</li>
<li><a href="integrations/../advanced/security.html">Security Model</a> - JACS security architecture</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<p>JACS includes a <strong>built-in PostgreSQL storage backend</strong> (behind the <code>database</code> feature flag) that handles document storage, JSONB queries, and signature preservation automatically. For most use cases, this is the recommended approach.</p>
<p>For custom integrations with other databases, see the examples below.</p>
<h2 id="built-in-postgresql-backend"><a class="header" href="#built-in-postgresql-backend">Built-in PostgreSQL Backend</a></h2>
<p>JACS ships with native PostgreSQL support via the <code>database</code> Cargo feature. This uses a TEXT + JSONB dual-column strategy to preserve cryptographic signatures while enabling efficient queries. See <a href="integrations/../advanced/storage.html">Storage Backends</a> for full documentation.</p>
<pre><code class="language-bash"># Enable at compile time
cargo build --features database

# Configure via environment
export JACS_DATABASE_URL="postgres://user:pass@localhost:5432/jacs"
</code></pre>
<h2 id="custom-database-integrations"><a class="header" href="#custom-database-integrations">Custom Database Integrations</a></h2>
<p>If you need to integrate JACS documents with other databases (MongoDB, SQLite, Redis) or need application-specific table structures, you can store JACS documents directly.</p>
<p>JACS documents are JSON objects with cryptographic signatures. They can be stored in any database that supports JSON or text storage:</p>
<div class="table-wrapper"><table><thead><tr><th>Database Type</th><th>Storage Method</th><th>Best For</th></tr></thead><tbody>
<tr><td>PostgreSQL (built-in)</td><td>TEXT + JSONB</td><td>Complex queries, signature preservation</td></tr>
<tr><td>PostgreSQL (custom)</td><td>JSONB column</td><td>Application-specific schemas</td></tr>
<tr><td>MongoDB</td><td>Native documents</td><td>Document-centric apps</td></tr>
<tr><td>SQLite</td><td>TEXT column</td><td>Local/embedded apps</td></tr>
<tr><td>Redis</td><td>Key-value</td><td>Caching, high-speed access</td></tr>
</tbody></table>
</div>
<h2 id="why-use-a-custom-database-integration"><a class="header" href="#why-use-a-custom-database-integration">Why Use a Custom Database Integration?</a></h2>
<p>The built-in PostgreSQL backend covers most query needs. Use a custom integration when you need:</p>
<ul>
<li><strong>Different Database</strong>: MongoDB, SQLite, Redis, etc.</li>
<li><strong>Custom Schema</strong>: Application-specific table structures</li>
<li><strong>Relations</strong>: Link JACS documents to non-JACS data</li>
<li><strong>Existing Infrastructure</strong>: Integrate with current systems</li>
</ul>
<h2 id="postgresql-integration"><a class="header" href="#postgresql-integration">PostgreSQL Integration</a></h2>
<h3 id="schema-design"><a class="header" href="#schema-design">Schema Design</a></h3>
<pre><code class="language-sql">-- JACS documents table
CREATE TABLE jacs_documents (
    id UUID PRIMARY KEY,
    version_id UUID NOT NULL,
    document JSONB NOT NULL,
    signature_valid BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Extracted fields for indexing
    agent_id UUID,
    document_type VARCHAR(100),

    UNIQUE(id, version_id)
);

-- Index on JACS fields
CREATE INDEX idx_jacs_agent ON jacs_documents(agent_id);
CREATE INDEX idx_jacs_type ON jacs_documents(document_type);
CREATE INDEX idx_jacs_created ON jacs_documents(created_at);

-- GIN index for JSONB queries
CREATE INDEX idx_jacs_document ON jacs_documents USING GIN (document);
</code></pre>
<h3 id="nodejs-example-1"><a class="header" href="#nodejs-example-1">Node.js Example</a></h3>
<pre><code class="language-javascript">import { Pool } from 'pg';
import jacs from '@hai.ai/jacs';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class JacsDocumentStore {
  constructor(configPath) {
    this.configPath = configPath;
  }

  async initialize() {
    await jacs.load(this.configPath);
  }

  async createAndStore(content, options = {}) {
    // Create JACS document
    const docString = await jacs.createDocument(
      JSON.stringify(content),
      options.customSchema
    );

    const doc = JSON.parse(docString);

    // Store in database
    const result = await pool.query(`
      INSERT INTO jacs_documents (id, version_id, document, agent_id, document_type)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `, [
      doc.jacsId,
      doc.jacsVersion,
      doc,
      doc.jacsSignature?.agentID,
      content.type || 'document'
    ]);

    return result.rows[0];
  }

  async getDocument(id, versionId = null) {
    let query = 'SELECT * FROM jacs_documents WHERE id = $1';
    const params = [id];

    if (versionId) {
      query += ' AND version_id = $2';
      params.push(versionId);
    } else {
      query += ' ORDER BY created_at DESC LIMIT 1';
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async verifyDocument(id) {
    const row = await this.getDocument(id);
    if (!row) return null;

    const isValid = await jacs.verifyDocument(JSON.stringify(row.document));

    // Update signature_valid flag
    await pool.query(
      'UPDATE jacs_documents SET signature_valid = $1 WHERE id = $2 AND version_id = $3',
      [isValid, row.id, row.version_id]
    );

    return { document: row.document, isValid };
  }

  async searchDocuments(query) {
    const result = await pool.query(`
      SELECT * FROM jacs_documents
      WHERE document @&gt; $1
      ORDER BY created_at DESC
    `, [JSON.stringify(query)]);

    return result.rows;
  }
}

// Usage
const store = new JacsDocumentStore('./jacs.config.json');
await store.initialize();

// Create and store a document
const doc = await store.createAndStore({
  type: 'invoice',
  amount: 1500,
  customer: 'Acme Corp'
});

// Search documents
const invoices = await store.searchDocuments({ type: 'invoice' });
</code></pre>
<h3 id="python-example-1"><a class="header" href="#python-example-1">Python Example</a></h3>
<pre><code class="language-python">import json
import jacs
import psycopg2
from psycopg2.extras import RealDictCursor

class JacsDocumentStore:
    def __init__(self, config_path, database_url):
        self.config_path = config_path
        self.database_url = database_url
        self.conn = None

    def initialize(self):
        # Initialize JACS
        agent = jacs.JacsAgent()
        agent.load(self.config_path)

        # Connect to database
        self.conn = psycopg2.connect(self.database_url)

    def create_and_store(self, content, custom_schema=None):
        # Create JACS document
        doc_string = jacs.create_document(
            json.dumps(content),
            custom_schema=custom_schema
        )
        doc = json.loads(doc_string)

        # Store in database
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                INSERT INTO jacs_documents (id, version_id, document, agent_id, document_type)
                VALUES (%s, %s, %s, %s, %s)
                RETURNING *
            """, (
                doc['jacsId'],
                doc['jacsVersion'],
                json.dumps(doc),
                doc.get('jacsSignature', {}).get('agentID'),
                content.get('type', 'document')
            ))
            self.conn.commit()
            return cur.fetchone()

    def get_document(self, doc_id, version_id=None):
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            if version_id:
                cur.execute(
                    "SELECT * FROM jacs_documents WHERE id = %s AND version_id = %s",
                    (doc_id, version_id)
                )
            else:
                cur.execute(
                    "SELECT * FROM jacs_documents WHERE id = %s ORDER BY created_at DESC LIMIT 1",
                    (doc_id,)
                )
            return cur.fetchone()

    def verify_document(self, doc_id):
        row = self.get_document(doc_id)
        if not row:
            return None

        is_valid = jacs.verify_document(json.dumps(row['document']))

        # Update verification status
        with self.conn.cursor() as cur:
            cur.execute(
                "UPDATE jacs_documents SET signature_valid = %s WHERE id = %s AND version_id = %s",
                (is_valid, row['id'], row['version_id'])
            )
            self.conn.commit()

        return {'document': row['document'], 'is_valid': is_valid}

    def search_documents(self, query):
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute(
                "SELECT * FROM jacs_documents WHERE document @&gt; %s ORDER BY created_at DESC",
                (json.dumps(query),)
            )
            return cur.fetchall()

# Usage
store = JacsDocumentStore('./jacs.config.json', 'postgresql://localhost/mydb')
store.initialize()

# Create and store a document
doc = store.create_and_store({
    'type': 'invoice',
    'amount': 1500,
    'customer': 'Acme Corp'
})

# Search documents
invoices = store.search_documents({'type': 'invoice'})
</code></pre>
<h2 id="mongodb-integration"><a class="header" href="#mongodb-integration">MongoDB Integration</a></h2>
<h3 id="collection-design"><a class="header" href="#collection-design">Collection Design</a></h3>
<pre><code class="language-javascript">// MongoDB schema (using Mongoose)
const jacsDocumentSchema = new mongoose.Schema({
  jacsId: { type: String, required: true, index: true },
  jacsVersion: { type: String, required: true },
  document: { type: mongoose.Schema.Types.Mixed, required: true },
  signatureValid: { type: Boolean, default: true },
  agentId: { type: String, index: true },
  documentType: { type: String, index: true },
  createdAt: { type: Date, default: Date.now, index: true }
});

jacsDocumentSchema.index({ jacsId: 1, jacsVersion: 1 }, { unique: true });
</code></pre>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-javascript">import mongoose from 'mongoose';
import jacs from '@hai.ai/jacs';

const JacsDocument = mongoose.model('JacsDocument', jacsDocumentSchema);

class MongoJacsStore {
  async initialize(configPath) {
    await jacs.load(configPath);
    await mongoose.connect(process.env.MONGODB_URI);
  }

  async createAndStore(content, options = {}) {
    const docString = await jacs.createDocument(
      JSON.stringify(content),
      options.customSchema
    );

    const doc = JSON.parse(docString);

    const stored = await JacsDocument.create({
      jacsId: doc.jacsId,
      jacsVersion: doc.jacsVersion,
      document: doc,
      agentId: doc.jacsSignature?.agentID,
      documentType: content.type || 'document'
    });

    return stored;
  }

  async getDocument(jacsId, versionId = null) {
    const query = { jacsId };
    if (versionId) {
      query.jacsVersion = versionId;
    }

    return JacsDocument.findOne(query).sort({ createdAt: -1 });
  }

  async searchDocuments(query) {
    // Build MongoDB query from content fields
    const mongoQuery = {};
    for (const [key, value] of Object.entries(query)) {
      mongoQuery[`document.${key}`] = value;
    }

    return JacsDocument.find(mongoQuery).sort({ createdAt: -1 });
  }

  async getDocumentsByAgent(agentId) {
    return JacsDocument.find({ agentId }).sort({ createdAt: -1 });
  }
}

// Usage
const store = new MongoJacsStore();
await store.initialize('./jacs.config.json');

const doc = await store.createAndStore({
  type: 'contract',
  parties: ['Alice', 'Bob'],
  value: 50000
});

const contracts = await store.searchDocuments({ type: 'contract' });
</code></pre>
<h2 id="sqlite-integration"><a class="header" href="#sqlite-integration">SQLite Integration</a></h2>
<p>For embedded or local applications:</p>
<pre><code class="language-javascript">import Database from 'better-sqlite3';
import jacs from '@hai.ai/jacs';

class SqliteJacsStore {
  constructor(dbPath) {
    this.db = new Database(dbPath);
    this.initSchema();
  }

  initSchema() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS jacs_documents (
        id TEXT NOT NULL,
        version_id TEXT NOT NULL,
        document TEXT NOT NULL,
        agent_id TEXT,
        document_type TEXT,
        signature_valid INTEGER DEFAULT 1,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (id, version_id)
      );

      CREATE INDEX IF NOT EXISTS idx_agent ON jacs_documents(agent_id);
      CREATE INDEX IF NOT EXISTS idx_type ON jacs_documents(document_type);
    `);
  }

  async initialize(configPath) {
    await jacs.load(configPath);
  }

  async createAndStore(content, options = {}) {
    const docString = await jacs.createDocument(
      JSON.stringify(content),
      options.customSchema
    );

    const doc = JSON.parse(docString);

    const stmt = this.db.prepare(`
      INSERT INTO jacs_documents (id, version_id, document, agent_id, document_type)
      VALUES (?, ?, ?, ?, ?)
    `);

    stmt.run(
      doc.jacsId,
      doc.jacsVersion,
      docString,
      doc.jacsSignature?.agentID,
      content.type || 'document'
    );

    return doc;
  }

  getDocument(id, versionId = null) {
    let query = 'SELECT * FROM jacs_documents WHERE id = ?';
    const params = [id];

    if (versionId) {
      query += ' AND version_id = ?';
      params.push(versionId);
    } else {
      query += ' ORDER BY created_at DESC LIMIT 1';
    }

    const stmt = this.db.prepare(query);
    const row = stmt.get(...params);

    if (row) {
      row.document = JSON.parse(row.document);
    }

    return row;
  }

  searchByType(documentType) {
    const stmt = this.db.prepare(
      'SELECT * FROM jacs_documents WHERE document_type = ? ORDER BY created_at DESC'
    );
    return stmt.all(documentType).map(row =&gt; ({
      ...row,
      document: JSON.parse(row.document)
    }));
  }
}
</code></pre>
<h2 id="redis-caching"><a class="header" href="#redis-caching">Redis Caching</a></h2>
<p>Use Redis for high-speed document access:</p>
<pre><code class="language-javascript">import Redis from 'ioredis';
import jacs from '@hai.ai/jacs';

class JacsRedisCache {
  constructor(redisUrl) {
    this.redis = new Redis(redisUrl);
    this.ttl = 3600; // 1 hour default TTL
  }

  async initialize(configPath) {
    await jacs.load(configPath);
  }

  async cacheDocument(docString) {
    const doc = JSON.parse(docString);
    const key = `jacs:${doc.jacsId}:${doc.jacsVersion}`;

    await this.redis.setex(key, this.ttl, docString);

    // Also cache as latest version
    await this.redis.setex(`jacs:${doc.jacsId}:latest`, this.ttl, docString);

    return doc;
  }

  async getDocument(jacsId, versionId = 'latest') {
    const key = `jacs:${jacsId}:${versionId}`;
    const docString = await this.redis.get(key);

    if (!docString) return null;

    return JSON.parse(docString);
  }

  async invalidate(jacsId, versionId = null) {
    if (versionId) {
      await this.redis.del(`jacs:${jacsId}:${versionId}`);
    } else {
      // Invalidate all versions
      const keys = await this.redis.keys(`jacs:${jacsId}:*`);
      if (keys.length &gt; 0) {
        await this.redis.del(...keys);
      }
    }
  }
}
</code></pre>
<h2 id="indexing-strategies"><a class="header" href="#indexing-strategies">Indexing Strategies</a></h2>
<h3 id="extracting-searchable-fields"><a class="header" href="#extracting-searchable-fields">Extracting Searchable Fields</a></h3>
<p>Extract key fields during storage for efficient querying:</p>
<pre><code class="language-javascript">async function extractIndexFields(jacsDocument) {
  return {
    jacsId: jacsDocument.jacsId,
    jacsVersion: jacsDocument.jacsVersion,
    agentId: jacsDocument.jacsSignature?.agentID,
    createdDate: jacsDocument.jacsSignature?.date,
    hasAgreement: !!jacsDocument.jacsAgreement,
    agreementComplete: jacsDocument.jacsAgreement?.signatures?.length ===
                        jacsDocument.jacsAgreement?.agentIDs?.length,
    // Application-specific fields
    documentType: jacsDocument.type,
    status: jacsDocument.status,
    tags: jacsDocument.tags || []
  };
}
</code></pre>
<h3 id="full-text-search"><a class="header" href="#full-text-search">Full-Text Search</a></h3>
<p>PostgreSQL example with full-text search:</p>
<pre><code class="language-sql">-- Add text search column
ALTER TABLE jacs_documents ADD COLUMN search_vector tsvector;

-- Create index
CREATE INDEX idx_search ON jacs_documents USING GIN(search_vector);

-- Update trigger
CREATE OR REPLACE FUNCTION update_search_vector() RETURNS trigger AS $$
BEGIN
  NEW.search_vector := to_tsvector('english',
    coalesce(NEW.document-&gt;&gt;'title', '') || ' ' ||
    coalesce(NEW.document-&gt;&gt;'content', '') || ' ' ||
    coalesce(NEW.document-&gt;&gt;'description', '')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER jacs_search_update
  BEFORE INSERT OR UPDATE ON jacs_documents
  FOR EACH ROW EXECUTE FUNCTION update_search_vector();
</code></pre>
<pre><code class="language-javascript">// Search example
async function fullTextSearch(searchQuery) {
  const result = await pool.query(`
    SELECT *, ts_rank(search_vector, plainto_tsquery($1)) as rank
    FROM jacs_documents
    WHERE search_vector @@ plainto_tsquery($1)
    ORDER BY rank DESC
  `, [searchQuery]);

  return result.rows;
}
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="1-store-complete-documents"><a class="header" href="#1-store-complete-documents">1. Store Complete Documents</a></h3>
<p>Always store the complete JACS document to preserve signatures:</p>
<pre><code class="language-javascript">// Good - stores complete document
await pool.query(
  'INSERT INTO jacs_documents (id, document) VALUES ($1, $2)',
  [doc.jacsId, JSON.stringify(doc)]  // Complete document
);

// Bad - loses signature data
await pool.query(
  'INSERT INTO documents (id, content) VALUES ($1, $2)',
  [doc.jacsId, JSON.stringify(doc.content)]  // Only content
);
</code></pre>
<h3 id="2-verify-after-retrieval"><a class="header" href="#2-verify-after-retrieval">2. Verify After Retrieval</a></h3>
<p>Always verify signatures when retrieving documents for sensitive operations:</p>
<pre><code class="language-javascript">async function getVerifiedDocument(id) {
  const row = await pool.query(
    'SELECT document FROM jacs_documents WHERE id = $1',
    [id]
  );

  if (!row.rows[0]) return null;

  const docString = JSON.stringify(row.rows[0].document);
  const isValid = await jacs.verifyDocument(docString);

  if (!isValid) {
    throw new Error('Document signature verification failed');
  }

  return row.rows[0].document;
}
</code></pre>
<h3 id="3-handle-version-history"><a class="header" href="#3-handle-version-history">3. Handle Version History</a></h3>
<p>Maintain version history for audit trails:</p>
<pre><code class="language-javascript">async function getDocumentHistory(jacsId) {
  const result = await pool.query(`
    SELECT * FROM jacs_documents
    WHERE id = $1
    ORDER BY created_at ASC
  `, [jacsId]);

  return result.rows;
}
</code></pre>
<h3 id="4-batch-verification"><a class="header" href="#4-batch-verification">4. Batch Verification</a></h3>
<p>Periodically verify stored documents:</p>
<pre><code class="language-javascript">async function verifyAllDocuments() {
  const docs = await pool.query('SELECT * FROM jacs_documents');

  for (const row of docs.rows) {
    const docString = JSON.stringify(row.document);
    const isValid = await jacs.verifyDocument(docString);

    if (!isValid) {
      console.warn(`Document ${row.id} failed verification`);
      await pool.query(
        'UPDATE jacs_documents SET signature_valid = false WHERE id = $1',
        [row.id]
      );
    }
  }
}
</code></pre>
<h2 id="see-also-21"><a class="header" href="#see-also-21">See Also</a></h2>
<ul>
<li><a href="integrations/../advanced/storage.html">Storage Backends</a> - Built-in JACS storage</li>
<li><a href="integrations/../advanced/security.html">Security Model</a> - Document security</li>
<li><a href="integrations/../advanced/testing.html">Testing</a> - Testing database integrations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-examples"><a class="header" href="#cli-examples">CLI Examples</a></h1>
<p>This chapter provides practical examples of using the JACS CLI for common workflows.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<pre><code class="language-bash">jacs init                  # Initialize JACS (config + agent + keys)
jacs agent create          # Create a new agent
jacs document create       # Create a signed document
jacs document verify       # Verify a document signature
jacs document sign-agreement  # Sign an agreement
</code></pre>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<h3 id="first-time-setup"><a class="header" href="#first-time-setup">First-Time Setup</a></h3>
<p>Initialize JACS in a new project:</p>
<pre><code class="language-bash"># Create a new directory
mkdir my-jacs-project
cd my-jacs-project

# Initialize JACS
jacs init

# This creates:
# - jacs.config.json (configuration)
# - jacs_keys/ (private and public keys)
# - jacs_data/ (document storage)
# - An initial agent document
</code></pre>
<h3 id="verify-your-setup"><a class="header" href="#verify-your-setup">Verify Your Setup</a></h3>
<pre><code class="language-bash"># Check the configuration
jacs config read

# Verify your agent
jacs agent verify

# Expected output:
# Agent verification successful
# Agent ID: 550e8400-e29b-41d4-a716-446655440000
# Agent Version: f47ac10b-58cc-4372-a567-0e02b2c3d479
</code></pre>
<h2 id="document-operations"><a class="header" href="#document-operations">Document Operations</a></h2>
<h3 id="creating-documents-5"><a class="header" href="#creating-documents-5">Creating Documents</a></h3>
<p><strong>Create from a JSON file:</strong></p>
<pre><code class="language-bash"># Create input file
cat &gt; invoice.json &lt;&lt; 'EOF'
{
  "type": "invoice",
  "invoiceNumber": "INV-001",
  "customer": "Acme Corp",
  "amount": 1500.00,
  "items": [
    {"description": "Consulting", "quantity": 10, "price": 150}
  ]
}
EOF

# Create signed document
jacs document create -f invoice.json

# Output shows the saved document path
# Document saved to: jacs_data/documents/[uuid]/[version].json
</code></pre>
<p><strong>Create with custom output:</strong></p>
<pre><code class="language-bash"># Specify output filename
jacs document create -f invoice.json -o signed-invoice.json

# Print to stdout (don't save)
jacs document create -f invoice.json --no-save
</code></pre>
<p><strong>Create with file attachments:</strong></p>
<pre><code class="language-bash"># Create document with PDF attachment
jacs document create -f contract.json --attach ./contract.pdf

# Embed attachment content in document
jacs document create -f contract.json --attach ./contract.pdf --embed true

# Attach entire directory
jacs document create -f report.json --attach ./attachments/
</code></pre>
<p><strong>Create with custom schema:</strong></p>
<pre><code class="language-bash"># Use a custom schema for validation
jacs document create -f order.json -s ./schemas/order.schema.json
</code></pre>
<h3 id="verifying-documents-5"><a class="header" href="#verifying-documents-5">Verifying Documents</a></h3>
<p><strong>Basic verification:</strong></p>
<pre><code class="language-bash"># Verify a document
jacs document verify -f ./signed-invoice.json

# Expected output:
# Document verified successfully
# Document ID: 550e8400-e29b-41d4-a716-446655440000
# Signer: Agent Name (agent-uuid)
</code></pre>
<p><strong>Verbose verification:</strong></p>
<pre><code class="language-bash"># Get detailed verification info
jacs document verify -f ./signed-invoice.json -v

# Output includes:
# - Document ID and version
# - Signature algorithm used
# - Signing agent details
# - Timestamp
# - Schema validation results
</code></pre>
<p><strong>Batch verification:</strong></p>
<pre><code class="language-bash"># Verify all documents in a directory
jacs document verify -d ./documents/

# With custom schema
jacs document verify -d ./invoices/ -s ./schemas/invoice.schema.json
</code></pre>
<h3 id="updating-documents-5"><a class="header" href="#updating-documents-5">Updating Documents</a></h3>
<p>Create a new version of an existing document:</p>
<pre><code class="language-bash"># Original document
cat &gt; original.json &lt;&lt; 'EOF'
{
  "title": "Project Plan",
  "status": "draft",
  "content": "Initial version"
}
EOF

jacs document create -f original.json -o project-v1.json

# Updated content
cat &gt; updated.json &lt;&lt; 'EOF'
{
  "title": "Project Plan",
  "status": "approved",
  "content": "Final version with updates"
}
EOF

# Create new version (maintains version history)
jacs document update -f project-v1.json -n updated.json -o project-v2.json

# Verify the updated document
jacs document verify -f project-v2.json -v
</code></pre>
<h3 id="extracting-embedded-content-1"><a class="header" href="#extracting-embedded-content-1">Extracting Embedded Content</a></h3>
<pre><code class="language-bash"># Extract embedded files from a document
jacs document extract -f ./document-with-attachments.json

# Extracts to: jacs_data/extracted/[document-id]/

# Extract from multiple documents
jacs document extract -d ./documents/
</code></pre>
<h2 id="agreement-workflows"><a class="header" href="#agreement-workflows">Agreement Workflows</a></h2>
<h3 id="creating-an-agreement"><a class="header" href="#creating-an-agreement">Creating an Agreement</a></h3>
<p>An agreement requires multiple agents to sign a document:</p>
<pre><code class="language-bash"># First, create the document to be agreed upon
cat &gt; service-agreement.json &lt;&lt; 'EOF'
{
  "type": "service_agreement",
  "title": "Professional Services Agreement",
  "parties": ["Company A", "Company B"],
  "terms": "...",
  "effectiveDate": "2024-02-01"
}
EOF

jacs document create -f service-agreement.json -o agreement.json

# Create agreement requiring signatures from two agents
# (Use actual agent UUIDs)
jacs document create-agreement \
  -f agreement.json \
  -i "agent1-uuid-here,agent2-uuid-here" \
  -o agreement-pending.json

# Output:
# Agreement created
# Required signatures: 2
# Current signatures: 0
</code></pre>
<h3 id="signing-an-agreement"><a class="header" href="#signing-an-agreement">Signing an Agreement</a></h3>
<pre><code class="language-bash"># First agent signs
jacs document sign-agreement -f agreement-pending.json -o agreement-signed-1.json

# Check status
jacs document check-agreement -f agreement-signed-1.json
# Output:
# Agreement status: pending
# Signatures: 1/2
# Missing: agent2-uuid

# Second agent signs (using their configuration)
JACS_CONFIG_PATH=./agent2.config.json \
  jacs document sign-agreement -f agreement-signed-1.json -o agreement-complete.json

# Verify completion
jacs document check-agreement -f agreement-complete.json
# Output:
# Agreement status: complete
# Signatures: 2/2
</code></pre>
<h3 id="complete-agreement-workflow"><a class="header" href="#complete-agreement-workflow">Complete Agreement Workflow</a></h3>
<pre><code class="language-bash">#!/bin/bash
# agreement-workflow.sh

# Step 1: Create the contract document
cat &gt; contract.json &lt;&lt; 'EOF'
{
  "type": "contract",
  "parties": {
    "seller": "Widget Corp",
    "buyer": "Acme Inc"
  },
  "terms": "Sale of 1000 widgets at $10 each",
  "totalValue": 10000
}
EOF

echo "Creating contract document..."
jacs document create -f contract.json -o contract-signed.json

# Step 2: Get agent IDs
SELLER_AGENT=$(jacs config read | grep agent_id | cut -d: -f2 | tr -d ' ')
BUYER_AGENT="buyer-agent-uuid-here"  # Replace with actual ID

# Step 3: Create agreement
echo "Creating agreement..."
jacs document create-agreement \
  -f contract-signed.json \
  -i "$SELLER_AGENT,$BUYER_AGENT" \
  -o contract-agreement.json

# Step 4: Seller signs
echo "Seller signing..."
jacs document sign-agreement \
  -f contract-agreement.json \
  -o contract-seller-signed.json

# Step 5: Check intermediate status
echo "Checking status..."
jacs document check-agreement -f contract-seller-signed.json

# Step 6: Buyer signs
echo "Buyer signing..."
JACS_CONFIG_PATH=./buyer.config.json \
  jacs document sign-agreement \
  -f contract-seller-signed.json \
  -o contract-complete.json

# Step 7: Verify complete agreement
echo "Final verification..."
jacs document verify -f contract-complete.json -v
jacs document check-agreement -f contract-complete.json

echo "Agreement workflow complete!"
</code></pre>
<h2 id="agent-operations-2"><a class="header" href="#agent-operations-2">Agent Operations</a></h2>
<h3 id="creating-a-custom-agent"><a class="header" href="#creating-a-custom-agent">Creating a Custom Agent</a></h3>
<pre><code class="language-bash"># Create agent definition file
cat &gt; my-agent.json &lt;&lt; 'EOF'
{
  "jacsAgentType": "ai",
  "name": "My Custom Agent",
  "description": "An AI agent for document processing",
  "contact": {
    "email": "agent@example.com"
  },
  "services": [
    {
      "name": "document-processing",
      "description": "Process and sign documents"
    }
  ]
}
EOF

# Create agent with new keys
jacs agent create --create-keys true -f my-agent.json

# Create agent using existing keys
jacs agent create --create-keys false -f my-agent.json
</code></pre>
<h3 id="dns-based-identity"><a class="header" href="#dns-based-identity">DNS-Based Identity</a></h3>
<p><strong>Generate DNS record commands:</strong></p>
<pre><code class="language-bash"># Generate TXT record for your domain
jacs agent dns --domain myagent.example.com

# Output (example):
# Add the following DNS TXT record:
# _v1.agent.jacs.myagent.example.com TXT "pk=&lt;base64-public-key-hash&gt;"

# Different providers
jacs agent dns --domain myagent.example.com --provider aws
jacs agent dns --domain myagent.example.com --provider cloudflare
jacs agent dns --domain myagent.example.com --provider azure

# Custom TTL
jacs agent dns --domain myagent.example.com --ttl 7200
</code></pre>
<p><strong>Verify DNS-published agent:</strong></p>
<pre><code class="language-bash"># Look up agent by domain
jacs agent lookup partner.example.com

# Require strict DNSSEC validation
jacs agent lookup partner.example.com --strict

# Verify local agent file against DNS
jacs agent verify -a ./partner-agent.json --require-strict-dns
</code></pre>
<h3 id="agent-verification"><a class="header" href="#agent-verification">Agent Verification</a></h3>
<pre><code class="language-bash"># Basic verification
jacs agent verify

# Verify another agent's file
jacs agent verify -a ./other-agent.json

# With DNS requirements
jacs agent verify --require-dns          # Require DNS (not strict)
jacs agent verify --require-strict-dns   # Require DNSSEC
jacs agent verify --no-dns              # Skip DNS entirely
jacs agent verify --ignore-dns          # Ignore DNS validation failures
</code></pre>
<h2 id="task-management"><a class="header" href="#task-management">Task Management</a></h2>
<h3 id="creating-tasks-1"><a class="header" href="#creating-tasks-1">Creating Tasks</a></h3>
<pre><code class="language-bash"># Simple task
jacs task create \
  -n "Review Contract" \
  -d "Review the service contract and provide feedback"

# Task with additional data from file
cat &gt; task-details.json &lt;&lt; 'EOF'
{
  "priority": "high",
  "dueDate": "2024-02-15",
  "assignee": "legal-team"
}
EOF

jacs task create \
  -n "Contract Review" \
  -d "Detailed review required" \
  -f task-details.json
</code></pre>
<h2 id="scripting-examples"><a class="header" href="#scripting-examples">Scripting Examples</a></h2>
<h3 id="batch-document-processing"><a class="header" href="#batch-document-processing">Batch Document Processing</a></h3>
<pre><code class="language-bash">#!/bin/bash
# batch-sign.sh - Sign all JSON files in a directory

INPUT_DIR=$1
OUTPUT_DIR=${2:-"./signed"}

mkdir -p "$OUTPUT_DIR"

for file in "$INPUT_DIR"/*.json; do
  filename=$(basename "$file")
  echo "Signing: $filename"

  jacs document create -f "$file" -o "$OUTPUT_DIR/$filename"

  if [ $? -eq 0 ]; then
    echo "  ‚úì Signed successfully"
  else
    echo "  ‚úó Signing failed"
  fi
done

echo "Batch signing complete. Output in $OUTPUT_DIR"
</code></pre>
<h3 id="verification-report"><a class="header" href="#verification-report">Verification Report</a></h3>
<pre><code class="language-bash">#!/bin/bash
# verify-report.sh - Generate verification report

DOC_DIR=$1
REPORT="verification-report.txt"

echo "JACS Document Verification Report" &gt; $REPORT
echo "Generated: $(date)" &gt;&gt; $REPORT
echo "=================================" &gt;&gt; $REPORT
echo "" &gt;&gt; $REPORT

passed=0
failed=0

for file in "$DOC_DIR"/*.json; do
  filename=$(basename "$file")

  if jacs document verify -f "$file" &gt; /dev/null 2&gt;&amp;1; then
    echo "‚úì PASS: $filename" &gt;&gt; $REPORT
    ((passed++))
  else
    echo "‚úó FAIL: $filename" &gt;&gt; $REPORT
    ((failed++))
  fi
done

echo "" &gt;&gt; $REPORT
echo "Summary: $passed passed, $failed failed" &gt;&gt; $REPORT

cat $REPORT
</code></pre>
<h3 id="watch-for-new-documents"><a class="header" href="#watch-for-new-documents">Watch for New Documents</a></h3>
<pre><code class="language-bash">#!/bin/bash
# watch-and-verify.sh - Monitor directory and verify new documents

WATCH_DIR=${1:-"./incoming"}

echo "Watching $WATCH_DIR for new documents..."

inotifywait -m "$WATCH_DIR" -e create -e moved_to |
  while read dir action file; do
    if [[ "$file" == *.json ]]; then
      echo "New document: $file"

      if jacs document verify -f "$WATCH_DIR/$file"; then
        mv "$WATCH_DIR/$file" "./verified/"
        echo "  Moved to verified/"
      else
        mv "$WATCH_DIR/$file" "./rejected/"
        echo "  Moved to rejected/"
      fi
    fi
  done
</code></pre>
<h2 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h2>
<h3 id="using-environment-variables"><a class="header" href="#using-environment-variables">Using Environment Variables</a></h3>
<pre><code class="language-bash"># Use a specific config file
export JACS_CONFIG_PATH=./production.config.json
jacs document create -f invoice.json

# Override specific settings
export JACS_DATA_DIRECTORY=./custom-data
export JACS_KEY_DIRECTORY=./secure-keys
jacs agent create --create-keys true

# One-time override
JACS_CONFIG_PATH=./test.config.json jacs document verify -f test-doc.json
</code></pre>
<h3 id="multiple-configurations"><a class="header" href="#multiple-configurations">Multiple Configurations</a></h3>
<pre><code class="language-bash"># Development
alias jacs-dev='JACS_CONFIG_PATH=./dev.config.json jacs'
jacs-dev document create -f test.json

# Production
alias jacs-prod='JACS_CONFIG_PATH=./prod.config.json jacs'
jacs-prod document verify -f important.json

# Different agents
alias jacs-alice='JACS_CONFIG_PATH=./alice.config.json jacs'
alias jacs-bob='JACS_CONFIG_PATH=./bob.config.json jacs'
</code></pre>
<h2 id="error-handling-11"><a class="header" href="#error-handling-11">Error Handling</a></h2>
<h3 id="understanding-exit-codes"><a class="header" href="#understanding-exit-codes">Understanding Exit Codes</a></h3>
<pre><code class="language-bash">jacs document verify -f document.json
exit_code=$?

case $exit_code in
  0) echo "Success" ;;
  1) echo "General error" ;;
  2) echo "Invalid arguments" ;;
  3) echo "File not found" ;;
  4) echo "Verification failed" ;;
  5) echo "Signature invalid" ;;
  *) echo "Unknown error: $exit_code" ;;
esac
</code></pre>
<h3 id="handling-failures"><a class="header" href="#handling-failures">Handling Failures</a></h3>
<pre><code class="language-bash">#!/bin/bash
# robust-signing.sh

sign_document() {
  local input=$1
  local output=$2

  if ! jacs document create -f "$input" -o "$output" 2&gt;/dev/null; then
    echo "Error: Failed to sign $input" &gt;&amp;2
    return 1
  fi

  if ! jacs document verify -f "$output" 2&gt;/dev/null; then
    echo "Error: Verification failed for $output" &gt;&amp;2
    rm -f "$output"
    return 1
  fi

  echo "Successfully signed: $output"
  return 0
}

# Usage
sign_document "invoice.json" "signed-invoice.json" || exit 1
</code></pre>
<h2 id="see-also-22"><a class="header" href="#see-also-22">See Also</a></h2>
<ul>
<li><a href="examples/../reference/cli-commands.html">CLI Command Reference</a> - Complete command reference</li>
<li><a href="examples/../reference/configuration.html">Configuration Reference</a> - Configuration options</li>
<li><a href="examples/../rust/cli.html">Rust CLI Usage</a> - Detailed CLI documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-examples"><a class="header" href="#nodejs-examples">Node.js Examples</a></h1>
<p>This chapter provides practical Node.js examples using the <code>@hai.ai/jacs</code> package.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<pre><code class="language-bash"># Install dependencies
npm install @hai.ai/jacs express @modelcontextprotocol/sdk zod
</code></pre>
<pre><code class="language-javascript">// Initialize JACS (ES Modules)
import { JacsAgent } from '@hai.ai/jacs';

const agent = new JacsAgent();
await agent.load('./jacs.config.json');
</code></pre>
<h2 id="basic-document-operations"><a class="header" href="#basic-document-operations">Basic Document Operations</a></h2>
<h3 id="creating-and-signing-documents"><a class="header" href="#creating-and-signing-documents">Creating and Signing Documents</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

async function createSignedDocument() {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  // Create a simple document
  const content = {
    title: 'Invoice',
    invoiceNumber: 'INV-001',
    amount: 1500.00,
    customer: 'Acme Corp',
    items: [
      { description: 'Consulting', quantity: 10, price: 150 }
    ]
  };

  // Create and sign the document
  const signedDoc = await agent.createDocument(JSON.stringify(content));

  // Parse the result
  const doc = JSON.parse(signedDoc);
  console.log('Document ID:', doc.jacsId);
  console.log('Version:', doc.jacsVersion);
  console.log('Signature:', doc.jacsSignature ? 'Present' : 'Missing');

  return doc;
}

createSignedDocument();
</code></pre>
<h3 id="verifying-documents-6"><a class="header" href="#verifying-documents-6">Verifying Documents</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

async function verifyDocument(filePath) {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  // Read the document
  const docString = fs.readFileSync(filePath, 'utf-8');

  // Verify signature
  const isValid = await agent.verifyDocument(docString);

  if (isValid) {
    console.log('‚úì Document signature is valid');
    const doc = JSON.parse(docString);
    console.log('  Signed by:', doc.jacsSignature?.agentID);
    console.log('  Signed at:', doc.jacsSignature?.date);
  } else {
    console.log('‚úó Document signature is INVALID');
  }

  return isValid;
}

verifyDocument('./invoice.json');
</code></pre>
<h3 id="updating-documents-6"><a class="header" href="#updating-documents-6">Updating Documents</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

async function updateDocument(originalPath, newContent) {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  // Read original document
  const originalDoc = fs.readFileSync(originalPath, 'utf-8');

  // Update with new content (preserves version chain)
  const updatedDoc = await agent.updateDocument(
    originalDoc,
    JSON.stringify(newContent)
  );

  const doc = JSON.parse(updatedDoc);
  console.log('Updated Document ID:', doc.jacsId);
  console.log('New Version:', doc.jacsVersion);

  return doc;
}

// Usage
const updated = await updateDocument('./invoice-v1.json', {
  title: 'Invoice',
  invoiceNumber: 'INV-001',
  amount: 1500.00,
  customer: 'Acme Corp',
  status: 'paid'  // New field
});
</code></pre>
<h2 id="http-server-with-express"><a class="header" href="#http-server-with-express">HTTP Server with Express</a></h2>
<h3 id="complete-express-server"><a class="header" href="#complete-express-server">Complete Express Server</a></h3>
<pre><code class="language-javascript">import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';
import { JacsAgent } from '@hai.ai/jacs';

const app = express();
const PORT = 3000;

// Initialize JACS
const agent = new JacsAgent();
await agent.load('./jacs.config.json');

// Health check (no JACS)
app.get('/health', (req, res) =&gt; {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// JACS-protected API routes
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Validation middleware
function requirePayload(req, res, next) {
  if (!req.jacsPayload) {
    return res.status(400).json({
      error: 'Invalid JACS request',
      message: 'Request must be signed with valid JACS credentials'
    });
  }
  next();
}

// Echo endpoint
app.post('/api/echo', requirePayload, (req, res) =&gt; {
  res.send({
    echo: req.jacsPayload,
    serverTime: new Date().toISOString()
  });
});

// Calculate endpoint
app.post('/api/calculate', requirePayload, (req, res) =&gt; {
  const { operation, a, b } = req.jacsPayload;

  let result;
  switch (operation) {
    case 'add': result = a + b; break;
    case 'subtract': result = a - b; break;
    case 'multiply': result = a * b; break;
    case 'divide': result = b !== 0 ? a / b : null; break;
    default:
      return res.status(400).send({ error: 'Unknown operation' });
  }

  res.send({ operation, a, b, result });
});

// Create document endpoint
app.post('/api/documents', requirePayload, async (req, res) =&gt; {
  try {
    const signedDoc = await agent.createDocument(
      JSON.stringify(req.jacsPayload)
    );
    const doc = JSON.parse(signedDoc);

    res.send({
      success: true,
      documentId: doc.jacsId,
      version: doc.jacsVersion
    });
  } catch (error) {
    res.status(500).send({ error: error.message });
  }
});

// Error handler
app.use((err, req, res, next) =&gt; {
  console.error('Error:', err);
  res.status(500).send({ error: 'Internal server error' });
});

app.listen(PORT, () =&gt; {
  console.log(`JACS Express server running on port ${PORT}`);
});
</code></pre>
<h3 id="http-client-2"><a class="header" href="#http-client-2">HTTP Client</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

async function callJacsApi(url, payload) {
  const agent = new JacsAgent();
  await agent.load('./jacs.client.config.json');

  // Sign the request
  const signedRequest = await agent.signRequest(payload);

  // Send HTTP request
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: signedRequest
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }

  // Verify and extract response
  const responseText = await response.text();
  const verified = await agent.verifyResponse(responseText);

  return verified.payload;
}

// Usage
async function main() {
  // Call echo endpoint
  const echoResult = await callJacsApi(
    'http://localhost:3000/api/echo',
    { message: 'Hello, server!' }
  );
  console.log('Echo:', echoResult);

  // Call calculate endpoint
  const calcResult = await callJacsApi(
    'http://localhost:3000/api/calculate',
    { operation: 'multiply', a: 7, b: 6 }
  );
  console.log('Calculate:', calcResult);
}

main().catch(console.error);
</code></pre>
<h2 id="mcp-integration-3"><a class="header" href="#mcp-integration-3">MCP Integration</a></h2>
<h3 id="mcp-server"><a class="header" href="#mcp-server">MCP Server</a></h3>
<pre><code class="language-javascript">import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { z } from 'zod';

const JACS_CONFIG = "./jacs.server.config.json";

async function main() {
  console.error("JACS MCP Server starting...");

  // Create transport with JACS encryption
  const baseTransport = new StdioServerTransport();
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    JACS_CONFIG,
    "server"
  );

  // Create MCP server
  const server = new McpServer({
    name: "jacs-demo-server",
    version: "1.0.0"
  });

  // Register tools
  server.tool("echo", {
    message: z.string().describe("Message to echo")
  }, async ({ message }) =&gt; {
    console.error(`Echo called: ${message}`);
    return { content: [{ type: "text", text: `Echo: ${message}` }] };
  });

  server.tool("calculate", {
    operation: z.enum(["add", "subtract", "multiply", "divide"]),
    a: z.number(),
    b: z.number()
  }, async ({ operation, a, b }) =&gt; {
    let result;
    switch (operation) {
      case 'add': result = a + b; break;
      case 'subtract': result = a - b; break;
      case 'multiply': result = a * b; break;
      case 'divide': result = b !== 0 ? a / b : 'undefined'; break;
    }
    return { content: [{ type: "text", text: `${a} ${operation} ${b} = ${result}` }] };
  });

  // Register resource
  server.resource(
    "server-info",
    "info://server",
    async (uri) =&gt; ({
      contents: [{
        uri: uri.href,
        text: JSON.stringify({
          name: "JACS Demo Server",
          version: "1.0.0",
          capabilities: ["echo", "calculate"]
        }),
        mimeType: "application/json"
      }]
    })
  );

  // Connect
  await server.connect(secureTransport);
  console.error("Server running with JACS encryption");
}

main().catch(err =&gt; {
  console.error("Fatal error:", err);
  process.exit(1);
});
</code></pre>
<h3 id="mcp-client"><a class="header" href="#mcp-client">MCP Client</a></h3>
<pre><code class="language-javascript">import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

const JACS_CONFIG = "./jacs.client.config.json";

async function main() {
  console.log("JACS MCP Client starting...");

  // Connect to server
  const baseTransport = new StdioClientTransport({
    command: 'node',
    args: ['mcp-server.js']
  });

  const secureTransport = createJACSTransportProxy(
    baseTransport,
    JACS_CONFIG,
    "client"
  );

  const client = new Client({
    name: "jacs-demo-client",
    version: "1.0.0"
  }, {
    capabilities: { tools: {} }
  });

  await client.connect(secureTransport);
  console.log("Connected to JACS MCP Server");

  // List tools
  const tools = await client.listTools();
  console.log("Available tools:", tools.tools.map(t =&gt; t.name));

  // Call echo
  const echoResult = await client.callTool({
    name: "echo",
    arguments: { message: "Hello, JACS!" }
  });
  console.log("Echo:", echoResult.content[0].text);

  // Call calculate
  const calcResult = await client.callTool({
    name: "calculate",
    arguments: { operation: "multiply", a: 6, b: 7 }
  });
  console.log("Calculate:", calcResult.content[0].text);

  await client.close();
  console.log("Done!");
}

main().catch(console.error);
</code></pre>
<h2 id="agreements-4"><a class="header" href="#agreements-4">Agreements</a></h2>
<h3 id="creating-multi-party-agreements"><a class="header" href="#creating-multi-party-agreements">Creating Multi-Party Agreements</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

async function createAgreement() {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  // Create the contract document
  const contract = {
    type: 'service_agreement',
    title: 'Professional Services Agreement',
    parties: ['Company A', 'Company B'],
    terms: 'Terms and conditions here...',
    value: 50000,
    effectiveDate: '2024-02-01'
  };

  const signedContract = await agent.createDocument(JSON.stringify(contract));

  // Get agent IDs (replace with actual UUIDs)
  const agentIds = [
    'agent1-uuid-here',
    'agent2-uuid-here'
  ];

  // Create agreement
  const agreementDoc = await agent.createAgreement(
    signedContract,
    agentIds,
    'Do you agree to the terms of this service agreement?',
    'This is a legally binding agreement'
  );

  console.log('Agreement created');
  const doc = JSON.parse(agreementDoc);
  console.log('Document ID:', doc.jacsId);
  console.log('Required signatures:', doc.jacsAgreement?.agentIDs?.length);

  // Save for signing
  fs.writeFileSync('agreement-pending.json', agreementDoc);

  return doc;
}

createAgreement();
</code></pre>
<h3 id="signing-agreements-1"><a class="header" href="#signing-agreements-1">Signing Agreements</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

async function signAgreement(agreementPath, outputPath) {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  // Read agreement
  const agreementDoc = fs.readFileSync(agreementPath, 'utf-8');

  // Sign agreement
  const signedAgreement = await agent.signAgreement(agreementDoc);

  // Check status
  const statusJson = await agent.checkAgreement(signedAgreement);
  const status = JSON.parse(statusJson);

  console.log('Agreement signed');
  console.log('Status:', status.complete ? 'Complete' : 'Pending');
  console.log('Signatures:', status.signatures?.length || 0);

  // Save
  fs.writeFileSync(outputPath, signedAgreement);

  return status;
}

signAgreement('./agreement-pending.json', './agreement-signed.json');
</code></pre>
<h3 id="checking-agreement-status-1"><a class="header" href="#checking-agreement-status-1">Checking Agreement Status</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

async function checkAgreementStatus(agreementPath) {
  const agent = new JacsAgent();
  await agent.load('./jacs.config.json');

  const agreementDoc = fs.readFileSync(agreementPath, 'utf-8');
  const statusJson = await agent.checkAgreement(agreementDoc);
  const status = JSON.parse(statusJson);

  console.log('Agreement Status:');
  console.log('  Complete:', status.complete);
  console.log('  Required agents:', status.requiredAgents);
  console.log('  Signed by:', status.signedBy || []);
  console.log('  Missing:', status.missing || []);

  return status;
}

checkAgreementStatus('./agreement.json');
</code></pre>
<h2 id="document-store"><a class="header" href="#document-store">Document Store</a></h2>
<h3 id="simple-file-based-store"><a class="header" href="#simple-file-based-store">Simple File-Based Store</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';
import path from 'path';

class JacsDocumentStore {
  constructor(configPath, dataDir = './documents') {
    this.configPath = configPath;
    this.dataDir = dataDir;
    this.agent = null;
  }

  async initialize() {
    this.agent = new JacsAgent();
    await this.agent.load(this.configPath);

    if (!fs.existsSync(this.dataDir)) {
      fs.mkdirSync(this.dataDir, { recursive: true });
    }
  }

  async create(content) {
    const signedDoc = await this.agent.createDocument(JSON.stringify(content));
    const doc = JSON.parse(signedDoc);

    const filename = `${doc.jacsId}.json`;
    const filepath = path.join(this.dataDir, filename);

    fs.writeFileSync(filepath, signedDoc);

    return { id: doc.jacsId, version: doc.jacsVersion, path: filepath };
  }

  async get(documentId) {
    const filepath = path.join(this.dataDir, `${documentId}.json`);

    if (!fs.existsSync(filepath)) {
      return null;
    }

    const docString = fs.readFileSync(filepath, 'utf-8');
    return JSON.parse(docString);
  }

  async verify(documentId) {
    const filepath = path.join(this.dataDir, `${documentId}.json`);

    if (!fs.existsSync(filepath)) {
      return { valid: false, error: 'Document not found' };
    }

    const docString = fs.readFileSync(filepath, 'utf-8');
    const isValid = await this.agent.verifyDocument(docString);

    return { valid: isValid, document: JSON.parse(docString) };
  }

  list() {
    const files = fs.readdirSync(this.dataDir);
    return files
      .filter(f =&gt; f.endsWith('.json'))
      .map(f =&gt; f.replace('.json', ''));
  }
}

// Usage
async function main() {
  const store = new JacsDocumentStore('./jacs.config.json');
  await store.initialize();

  // Create document
  const result = await store.create({
    type: 'note',
    title: 'Meeting Notes',
    content: 'Discussed project timeline...'
  });
  console.log('Created:', result.id);

  // Verify document
  const verification = await store.verify(result.id);
  console.log('Valid:', verification.valid);

  // List all documents
  const docs = store.list();
  console.log('Documents:', docs);
}

main();
</code></pre>
<h2 id="error-handling-12"><a class="header" href="#error-handling-12">Error Handling</a></h2>
<h3 id="robust-error-handling-pattern"><a class="header" href="#robust-error-handling-pattern">Robust Error Handling Pattern</a></h3>
<pre><code class="language-javascript">import { JacsAgent } from '@hai.ai/jacs';

class JacsError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'JacsError';
    this.code = code;
    this.details = details;
  }
}

async function robustDocumentCreate(configPath, content) {
  let agent;

  try {
    agent = new JacsAgent();
    await agent.load(configPath);
  } catch (error) {
    throw new JacsError(
      'Failed to initialize JACS agent',
      'INIT_ERROR',
      { originalError: error.message }
    );
  }

  try {
    const signedDoc = await agent.createDocument(JSON.stringify(content));
    return JSON.parse(signedDoc);
  } catch (error) {
    throw new JacsError(
      'Failed to create document',
      'CREATE_ERROR',
      { originalError: error.message, content }
    );
  }
}

async function robustDocumentVerify(configPath, docString) {
  let agent;

  try {
    agent = new JacsAgent();
    await agent.load(configPath);
  } catch (error) {
    throw new JacsError(
      'Failed to initialize JACS agent',
      'INIT_ERROR',
      { originalError: error.message }
    );
  }

  try {
    const isValid = await agent.verifyDocument(docString);
    return { valid: isValid };
  } catch (error) {
    throw new JacsError(
      'Verification error',
      'VERIFY_ERROR',
      { originalError: error.message }
    );
  }
}

// Usage with error handling
async function main() {
  try {
    const doc = await robustDocumentCreate('./jacs.config.json', {
      title: 'Test'
    });
    console.log('Created:', doc.jacsId);
  } catch (error) {
    if (error instanceof JacsError) {
      console.error(`JACS Error [${error.code}]:`, error.message);
      console.error('Details:', error.details);
    } else {
      console.error('Unexpected error:', error);
    }
  }
}

main();
</code></pre>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<h3 id="jest-test-setup"><a class="header" href="#jest-test-setup">Jest Test Setup</a></h3>
<pre><code class="language-javascript">// tests/jacs.test.js
import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';
import path from 'path';
import os from 'os';

describe('JACS Document Operations', () =&gt; {
  let agent;
  let tempDir;
  let configPath;

  beforeAll(async () =&gt; {
    // Create temp directory
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'jacs-test-'));
    const dataDir = path.join(tempDir, 'data');
    const keyDir = path.join(tempDir, 'keys');

    fs.mkdirSync(dataDir);
    fs.mkdirSync(keyDir);

    // Create test config
    const config = {
      jacs_data_directory: dataDir,
      jacs_key_directory: keyDir,
      jacs_agent_key_algorithm: 'ring-Ed25519',
      jacs_default_storage: 'fs'
    };

    configPath = path.join(tempDir, 'jacs.config.json');
    fs.writeFileSync(configPath, JSON.stringify(config));

    // Initialize agent
    agent = new JacsAgent();
    await agent.load(configPath);
  });

  afterAll(() =&gt; {
    fs.rmSync(tempDir, { recursive: true });
  });

  test('creates a signed document', async () =&gt; {
    const content = { title: 'Test Document', value: 42 };
    const signedDoc = await agent.createDocument(JSON.stringify(content));
    const doc = JSON.parse(signedDoc);

    expect(doc.jacsId).toBeDefined();
    expect(doc.jacsVersion).toBeDefined();
    expect(doc.jacsSignature).toBeDefined();
    expect(doc.title).toBe('Test Document');
  });

  test('verifies a valid document', async () =&gt; {
    const content = { title: 'Verify Test' };
    const signedDoc = await agent.createDocument(JSON.stringify(content));

    const isValid = await agent.verifyDocument(signedDoc);
    expect(isValid).toBe(true);
  });

  test('detects tampered document', async () =&gt; {
    const content = { title: 'Tamper Test' };
    const signedDoc = await agent.createDocument(JSON.stringify(content));

    // Tamper with document
    const doc = JSON.parse(signedDoc);
    doc.title = 'Modified Title';
    const tamperedDoc = JSON.stringify(doc);

    const isValid = await agent.verifyDocument(tamperedDoc);
    expect(isValid).toBe(false);
  });
});
</code></pre>
<h2 id="see-also-23"><a class="header" href="#see-also-23">See Also</a></h2>
<ul>
<li><a href="examples/../nodejs/installation.html">Node.js Installation</a> - Setup guide</li>
<li><a href="examples/../nodejs/api.html">Node.js API Reference</a> - Complete API documentation</li>
<li><a href="examples/../nodejs/mcp.html">MCP Integration</a> - MCP details</li>
<li><a href="examples/../nodejs/http.html">HTTP Server</a> - HTTP integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-examples"><a class="header" href="#python-examples">Python Examples</a></h1>
<p>This chapter provides practical Python examples using the <code>jacs</code> (jacspy) package.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<pre><code class="language-bash"># Install dependencies
pip install jacs fastmcp fastapi uvicorn
</code></pre>
<pre><code class="language-python"># Initialize JACS
import jacs

agent = jacs.JacsAgent()
agent.load('./jacs.config.json')
</code></pre>
<h2 id="basic-document-operations-1"><a class="header" href="#basic-document-operations-1">Basic Document Operations</a></h2>
<h3 id="creating-and-signing-documents-1"><a class="header" href="#creating-and-signing-documents-1">Creating and Signing Documents</a></h3>
<pre><code class="language-python">import jacs
import json

def create_signed_document():
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Create document content
    content = {
        "title": "Invoice",
        "invoiceNumber": "INV-001",
        "amount": 1500.00,
        "customer": "Acme Corp",
        "items": [
            {"description": "Consulting", "quantity": 10, "price": 150}
        ]
    }

    # Create and sign the document
    signed_doc = agent.create_document(json.dumps(content))

    # Parse the result
    doc = json.loads(signed_doc)
    print(f"Document ID: {doc['jacsId']}")
    print(f"Version: {doc['jacsVersion']}")
    print(f"Signature: {'Present' if 'jacsSignature' in doc else 'Missing'}")

    return doc

if __name__ == "__main__":
    create_signed_document()
</code></pre>
<h3 id="verifying-documents-7"><a class="header" href="#verifying-documents-7">Verifying Documents</a></h3>
<pre><code class="language-python">import jacs
import json

def verify_document(file_path: str) -&gt; bool:
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Read the document
    with open(file_path, 'r') as f:
        doc_string = f.read()

    # Verify signature
    is_valid = agent.verify_document(doc_string)

    if is_valid:
        doc = json.loads(doc_string)
        print("‚úì Document signature is valid")
        print(f"  Signed by: {doc.get('jacsSignature', {}).get('agentID')}")
        print(f"  Signed at: {doc.get('jacsSignature', {}).get('date')}")
    else:
        print("‚úó Document signature is INVALID")

    return is_valid

if __name__ == "__main__":
    verify_document('./invoice.json')
</code></pre>
<h3 id="updating-documents-7"><a class="header" href="#updating-documents-7">Updating Documents</a></h3>
<pre><code class="language-python">import jacs
import json

def update_document(original_path: str, new_content: dict) -&gt; dict:
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Read original document
    with open(original_path, 'r') as f:
        original_doc = f.read()

    # Update with new content (preserves version chain)
    updated_doc = agent.update_document(
        original_doc,
        json.dumps(new_content)
    )

    doc = json.loads(updated_doc)
    print(f"Updated Document ID: {doc['jacsId']}")
    print(f"New Version: {doc['jacsVersion']}")

    return doc

if __name__ == "__main__":
    updated = update_document('./invoice-v1.json', {
        "title": "Invoice",
        "invoiceNumber": "INV-001",
        "amount": 1500.00,
        "customer": "Acme Corp",
        "status": "paid"  # New field
    })
</code></pre>
<h2 id="http-server-with-fastapi"><a class="header" href="#http-server-with-fastapi">HTTP Server with FastAPI</a></h2>
<h3 id="complete-fastapi-server"><a class="header" href="#complete-fastapi-server">Complete FastAPI Server</a></h3>
<pre><code class="language-python">from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import PlainTextResponse
import jacs
import json

app = FastAPI(title="JACS API")

# Initialize JACS agent at startup
agent = None

@app.on_event("startup")
async def startup():
    global agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

# Health check (no JACS)
@app.get("/health")
async def health():
    return {"status": "ok"}

# JACS-protected endpoint
@app.post("/api/echo")
async def echo(request: Request):
    # Read raw body
    body = await request.body()
    body_str = body.decode('utf-8')

    # Verify JACS request
    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid JACS request")

    # Process and respond
    result = {
        "echo": payload,
        "serverTime": str(datetime.now())
    }

    # Sign response
    signed_response = jacs.sign_response(result)
    return PlainTextResponse(content=signed_response)

# Create document endpoint
@app.post("/api/documents")
async def create_document(request: Request):
    body = await request.body()
    body_str = body.decode('utf-8')

    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid JACS request")

    # Create signed document
    signed_doc = agent.create_document(json.dumps(payload))
    doc = json.loads(signed_doc)

    result = {
        "success": True,
        "documentId": doc['jacsId'],
        "version": doc['jacsVersion']
    }

    signed_response = jacs.sign_response(result)
    return PlainTextResponse(content=signed_response)

# Calculate endpoint
@app.post("/api/calculate")
async def calculate(request: Request):
    body = await request.body()
    body_str = body.decode('utf-8')

    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid JACS request")

    operation = payload.get('operation')
    a = payload.get('a', 0)
    b = payload.get('b', 0)

    if operation == 'add':
        result = a + b
    elif operation == 'subtract':
        result = a - b
    elif operation == 'multiply':
        result = a * b
    elif operation == 'divide':
        result = a / b if b != 0 else None
    else:
        raise HTTPException(status_code=400, detail="Unknown operation")

    response = {"operation": operation, "a": a, "b": b, "result": result}
    signed_response = jacs.sign_response(response)
    return PlainTextResponse(content=signed_response)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h3 id="http-client-3"><a class="header" href="#http-client-3">HTTP Client</a></h3>
<pre><code class="language-python">import jacs
import requests
import json

def call_jacs_api(url: str, payload: dict) -&gt; dict:
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.client.config.json')

    # Sign the request
    signed_request = jacs.sign_request(payload)

    # Send HTTP request
    response = requests.post(
        url,
        data=signed_request,
        headers={"Content-Type": "text/plain"}
    )

    if response.status_code != 200:
        raise Exception(f"HTTP {response.status_code}")

    # Verify and extract response
    verified = jacs.verify_response(response.text)
    return json.loads(verified).get('payload')

if __name__ == "__main__":
    # Call echo endpoint
    echo_result = call_jacs_api(
        'http://localhost:8000/api/echo',
        {"message": "Hello, server!"}
    )
    print("Echo:", echo_result)

    # Call calculate endpoint
    calc_result = call_jacs_api(
        'http://localhost:8000/api/calculate',
        {"operation": "multiply", "a": 7, "b": 6}
    )
    print("Calculate:", calc_result)
</code></pre>
<h2 id="mcp-integration-4"><a class="header" href="#mcp-integration-4">MCP Integration</a></h2>
<h3 id="fastmcp-server-with-jacs"><a class="header" href="#fastmcp-server-with-jacs">FastMCP Server with JACS</a></h3>
<pre><code class="language-python">import jacs
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import uvicorn

# Initialize JACS
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create FastMCP server with JACS
mcp = JACSMCPServer(FastMCP("JACS Demo Server"))

@mcp.tool()
def echo(message: str) -&gt; str:
    """Echo the input message"""
    return f"Echo: {message}"

@mcp.tool()
def calculate(operation: str, a: float, b: float) -&gt; str:
    """Perform basic arithmetic"""
    if operation == 'add':
        result = a + b
    elif operation == 'subtract':
        result = a - b
    elif operation == 'multiply':
        result = a * b
    elif operation == 'divide':
        result = a / b if b != 0 else "undefined"
    else:
        return f"Unknown operation: {operation}"

    return f"{a} {operation} {b} = {result}"

@mcp.resource("info://server")
def server_info() -&gt; str:
    """Get server information"""
    return json.dumps({
        "name": "JACS Demo Server",
        "version": "1.0.0",
        "tools": ["echo", "calculate"]
    })

# Get ASGI app with JACS middleware
app = mcp.sse_app()

if __name__ == "__main__":
    print("Starting JACS MCP Server...")
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h3 id="mcp-client-with-jacs-1"><a class="header" href="#mcp-client-with-jacs-1">MCP Client with JACS</a></h3>
<pre><code class="language-python">import asyncio
import jacs
from jacs.mcp import JACSMCPClient

async def main():
    # Initialize JACS
    agent = jacs.JacsAgent()
    agent.load('./jacs.client.config.json')

    # Create authenticated client
    client = JACSMCPClient("http://localhost:8000/sse")

    async with client:
        # Call echo tool
        echo_result = await client.call_tool("echo", {
            "message": "Hello from JACS client!"
        })
        print(f"Echo: {echo_result}")

        # Call calculate tool
        calc_result = await client.call_tool("calculate", {
            "operation": "multiply",
            "a": 6,
            "b": 7
        })
        print(f"Calculate: {calc_result}")

        # Read resource
        info = await client.read_resource("info://server")
        print(f"Server info: {info}")

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<h2 id="agreements-5"><a class="header" href="#agreements-5">Agreements</a></h2>
<h3 id="creating-multi-party-agreements-1"><a class="header" href="#creating-multi-party-agreements-1">Creating Multi-Party Agreements</a></h3>
<pre><code class="language-python">import jacs
import json

def create_agreement():
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Create contract document
    contract = {
        "type": "service_agreement",
        "title": "Professional Services Agreement",
        "parties": ["Company A", "Company B"],
        "terms": "Terms and conditions here...",
        "value": 50000,
        "effectiveDate": "2024-02-01"
    }

    signed_contract = agent.create_document(json.dumps(contract))

    # Define required signers (replace with actual UUIDs)
    agent_ids = [
        "agent1-uuid-here",
        "agent2-uuid-here"
    ]

    # Create agreement
    agreement_doc = agent.create_agreement(
        signed_contract,
        agent_ids,
        question="Do you agree to the terms of this service agreement?",
        context="This is a legally binding agreement"
    )

    doc = json.loads(agreement_doc)
    print("Agreement created")
    print(f"Document ID: {doc['jacsId']}")
    print(f"Required signatures: {len(doc.get('jacsAgreement', {}).get('agentIDs', []))}")

    # Save for signing
    with open('agreement-pending.json', 'w') as f:
        f.write(agreement_doc)

    return doc

if __name__ == "__main__":
    create_agreement()
</code></pre>
<h3 id="signing-agreements-2"><a class="header" href="#signing-agreements-2">Signing Agreements</a></h3>
<pre><code class="language-python">import jacs
import json

def sign_agreement(agreement_path: str, output_path: str) -&gt; dict:
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    # Read agreement
    with open(agreement_path, 'r') as f:
        agreement_doc = f.read()

    # Sign agreement
    signed_agreement = agent.sign_agreement(agreement_doc)

    # Check status
    status_json = agent.check_agreement(signed_agreement)
    status = json.loads(status_json)

    print("Agreement signed")
    print(f"Status: {'Complete' if status.get('complete') else 'Pending'}")
    print(f"Signatures: {len(status.get('signatures', []))}")

    # Save
    with open(output_path, 'w') as f:
        f.write(signed_agreement)

    return status

if __name__ == "__main__":
    sign_agreement('./agreement-pending.json', './agreement-signed.json')
</code></pre>
<h3 id="checking-agreement-status-2"><a class="header" href="#checking-agreement-status-2">Checking Agreement Status</a></h3>
<pre><code class="language-python">import jacs
import json

def check_agreement_status(agreement_path: str) -&gt; dict:
    # Initialize agent
    agent = jacs.JacsAgent()
    agent.load('./jacs.config.json')

    with open(agreement_path, 'r') as f:
        agreement_doc = f.read()

    status_json = agent.check_agreement(agreement_doc)
    status = json.loads(status_json)

    print("Agreement Status:")
    print(f"  Complete: {status.get('complete')}")
    print(f"  Required agents: {status.get('requiredAgents', [])}")
    print(f"  Signed by: {status.get('signedBy', [])}")
    print(f"  Missing: {status.get('missing', [])}")

    return status

if __name__ == "__main__":
    check_agreement_status('./agreement.json')
</code></pre>
<h2 id="document-store-1"><a class="header" href="#document-store-1">Document Store</a></h2>
<h3 id="simple-file-based-store-1"><a class="header" href="#simple-file-based-store-1">Simple File-Based Store</a></h3>
<pre><code class="language-python">import jacs
import json
import os
from pathlib import Path
from typing import Optional, Dict, List

class JacsDocumentStore:
    def __init__(self, config_path: str, data_dir: str = './documents'):
        self.config_path = config_path
        self.data_dir = Path(data_dir)
        self.agent = None

    def initialize(self):
        self.agent = jacs.JacsAgent()
        self.agent.load(self.config_path)
        self.data_dir.mkdir(parents=True, exist_ok=True)

    def create(self, content: dict) -&gt; dict:
        signed_doc = self.agent.create_document(json.dumps(content))
        doc = json.loads(signed_doc)

        filename = f"{doc['jacsId']}.json"
        filepath = self.data_dir / filename

        with open(filepath, 'w') as f:
            f.write(signed_doc)

        return {
            'id': doc['jacsId'],
            'version': doc['jacsVersion'],
            'path': str(filepath)
        }

    def get(self, document_id: str) -&gt; Optional[dict]:
        filepath = self.data_dir / f"{document_id}.json"

        if not filepath.exists():
            return None

        with open(filepath, 'r') as f:
            return json.load(f)

    def verify(self, document_id: str) -&gt; dict:
        filepath = self.data_dir / f"{document_id}.json"

        if not filepath.exists():
            return {'valid': False, 'error': 'Document not found'}

        with open(filepath, 'r') as f:
            doc_string = f.read()

        is_valid = self.agent.verify_document(doc_string)
        return {'valid': is_valid, 'document': json.loads(doc_string)}

    def list(self) -&gt; List[str]:
        return [
            f.stem for f in self.data_dir.glob('*.json')
        ]

if __name__ == "__main__":
    store = JacsDocumentStore('./jacs.config.json')
    store.initialize()

    # Create document
    result = store.create({
        'type': 'note',
        'title': 'Meeting Notes',
        'content': 'Discussed project timeline...'
    })
    print(f"Created: {result['id']}")

    # Verify document
    verification = store.verify(result['id'])
    print(f"Valid: {verification['valid']}")

    # List all documents
    docs = store.list()
    print(f"Documents: {docs}")
</code></pre>
<h2 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h2>
<h3 id="batch-document-creator"><a class="header" href="#batch-document-creator">Batch Document Creator</a></h3>
<pre><code class="language-python">import jacs
import json
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

class BatchDocumentProcessor:
    def __init__(self, config_path: str):
        self.config_path = config_path

    def create_documents(self, documents: list, output_dir: str) -&gt; list:
        """Create multiple signed documents"""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        results = []

        # Initialize agent
        agent = jacs.JacsAgent()
        agent.load(self.config_path)

        for i, content in enumerate(documents):
            try:
                signed_doc = agent.create_document(json.dumps(content))
                doc = json.loads(signed_doc)

                filename = f"{doc['jacsId']}.json"
                filepath = output_path / filename

                with open(filepath, 'w') as f:
                    f.write(signed_doc)

                results.append({
                    'success': True,
                    'index': i,
                    'id': doc['jacsId'],
                    'path': str(filepath)
                })
            except Exception as e:
                results.append({
                    'success': False,
                    'index': i,
                    'error': str(e)
                })

        return results

    def verify_documents(self, input_dir: str) -&gt; list:
        """Verify all documents in a directory"""
        input_path = Path(input_dir)

        # Initialize agent
        agent = jacs.JacsAgent()
        agent.load(self.config_path)

        results = []

        for filepath in input_path.glob('*.json'):
            try:
                with open(filepath, 'r') as f:
                    doc_string = f.read()

                is_valid = agent.verify_document(doc_string)
                doc = json.loads(doc_string)

                results.append({
                    'file': filepath.name,
                    'valid': is_valid,
                    'id': doc.get('jacsId')
                })
            except Exception as e:
                results.append({
                    'file': filepath.name,
                    'valid': False,
                    'error': str(e)
                })

        return results

if __name__ == "__main__":
    processor = BatchDocumentProcessor('./jacs.config.json')

    # Create batch of documents
    documents = [
        {'type': 'invoice', 'number': f'INV-{i:03d}', 'amount': i * 100}
        for i in range(1, 11)
    ]

    results = processor.create_documents(documents, './batch-output')

    success_count = sum(1 for r in results if r['success'])
    print(f"Created {success_count}/{len(documents)} documents")

    # Verify all documents
    verification_results = processor.verify_documents('./batch-output')

    valid_count = sum(1 for r in verification_results if r['valid'])
    print(f"Valid: {valid_count}/{len(verification_results)} documents")
</code></pre>
<h2 id="testing-5"><a class="header" href="#testing-5">Testing</a></h2>
<h3 id="pytest-setup"><a class="header" href="#pytest-setup">Pytest Setup</a></h3>
<pre><code class="language-python"># tests/test_jacs.py
import pytest
import jacs
import json
import tempfile
import shutil
from pathlib import Path

@pytest.fixture
def jacs_agent():
    """Create a test JACS agent with temporary directories"""
    temp_dir = tempfile.mkdtemp()
    data_dir = Path(temp_dir) / 'data'
    key_dir = Path(temp_dir) / 'keys'

    data_dir.mkdir()
    key_dir.mkdir()

    config = {
        'jacs_data_directory': str(data_dir),
        'jacs_key_directory': str(key_dir),
        'jacs_agent_key_algorithm': 'ring-Ed25519',
        'jacs_default_storage': 'fs'
    }

    config_path = Path(temp_dir) / 'jacs.config.json'
    with open(config_path, 'w') as f:
        json.dump(config, f)

    agent = jacs.JacsAgent()
    agent.load(str(config_path))

    yield agent

    shutil.rmtree(temp_dir)

class TestDocumentOperations:
    def test_create_document(self, jacs_agent):
        content = {'title': 'Test Document', 'value': 42}
        signed_doc = jacs_agent.create_document(json.dumps(content))
        doc = json.loads(signed_doc)

        assert 'jacsId' in doc
        assert 'jacsVersion' in doc
        assert 'jacsSignature' in doc
        assert doc['title'] == 'Test Document'

    def test_verify_valid_document(self, jacs_agent):
        content = {'title': 'Verify Test'}
        signed_doc = jacs_agent.create_document(json.dumps(content))

        is_valid = jacs_agent.verify_document(signed_doc)
        assert is_valid is True

    def test_detect_tampered_document(self, jacs_agent):
        content = {'title': 'Tamper Test'}
        signed_doc = jacs_agent.create_document(json.dumps(content))

        # Tamper with document
        doc = json.loads(signed_doc)
        doc['title'] = 'Modified Title'
        tampered_doc = json.dumps(doc)

        is_valid = jacs_agent.verify_document(tampered_doc)
        assert is_valid is False

    def test_different_content_different_signatures(self, jacs_agent):
        doc1 = jacs_agent.create_document(json.dumps({'a': 1}))
        doc2 = jacs_agent.create_document(json.dumps({'a': 2}))

        parsed1 = json.loads(doc1)
        parsed2 = json.loads(doc2)

        sig1 = parsed1['jacsSignature']['signature']
        sig2 = parsed2['jacsSignature']['signature']

        assert sig1 != sig2
</code></pre>
<h2 id="error-handling-13"><a class="header" href="#error-handling-13">Error Handling</a></h2>
<h3 id="robust-error-handling-pattern-1"><a class="header" href="#robust-error-handling-pattern-1">Robust Error Handling Pattern</a></h3>
<pre><code class="language-python">import jacs
import json
from typing import Optional

class JacsError(Exception):
    def __init__(self, message: str, code: str, details: dict = None):
        super().__init__(message)
        self.code = code
        self.details = details or {}

def robust_create_document(config_path: str, content: dict) -&gt; dict:
    """Create a document with comprehensive error handling"""
    try:
        agent = jacs.JacsAgent()
        agent.load(config_path)
    except FileNotFoundError:
        raise JacsError(
            "Configuration file not found",
            "CONFIG_NOT_FOUND",
            {"path": config_path}
        )
    except Exception as e:
        raise JacsError(
            "Failed to initialize JACS agent",
            "INIT_ERROR",
            {"original_error": str(e)}
        )

    try:
        signed_doc = agent.create_document(json.dumps(content))
        return json.loads(signed_doc)
    except Exception as e:
        raise JacsError(
            "Failed to create document",
            "CREATE_ERROR",
            {"original_error": str(e), "content": content}
        )

def robust_verify_document(config_path: str, doc_string: str) -&gt; dict:
    """Verify a document with comprehensive error handling"""
    try:
        agent = jacs.JacsAgent()
        agent.load(config_path)
    except Exception as e:
        raise JacsError(
            "Failed to initialize JACS agent",
            "INIT_ERROR",
            {"original_error": str(e)}
        )

    try:
        is_valid = agent.verify_document(doc_string)
        return {"valid": is_valid}
    except Exception as e:
        raise JacsError(
            "Verification error",
            "VERIFY_ERROR",
            {"original_error": str(e)}
        )

if __name__ == "__main__":
    try:
        doc = robust_create_document('./jacs.config.json', {'title': 'Test'})
        print(f"Created: {doc['jacsId']}")
    except JacsError as e:
        print(f"JACS Error [{e.code}]: {e}")
        print(f"Details: {e.details}")
    except Exception as e:
        print(f"Unexpected error: {e}")
</code></pre>
<h2 id="see-also-24"><a class="header" href="#see-also-24">See Also</a></h2>
<ul>
<li><a href="examples/../python/installation.html">Python Installation</a> - Setup guide</li>
<li><a href="examples/../python/api.html">Python API Reference</a> - Complete API documentation</li>
<li><a href="examples/../python/mcp.html">Python MCP Integration</a> - MCP details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h1>
<p>This chapter provides complete, production-ready integration examples combining multiple JACS features.</p>
<h2 id="multi-agent-contract-signing-system"><a class="header" href="#multi-agent-contract-signing-system">Multi-Agent Contract Signing System</a></h2>
<p>A complete example of a contract signing workflow with multiple agents.</p>
<h3 id="overview-16"><a class="header" href="#overview-16">Overview</a></h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Seller     ‚îÇ     ‚îÇ   Contract   ‚îÇ     ‚îÇ   Buyer      ‚îÇ
‚îÇ   Agent      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ&gt;‚îÇ   Document   ‚îÇ&lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   Agent      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                    ‚îÇ                    ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ   Signed     ‚îÇ
                   ‚îÇ   Agreement  ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre><code class="language-javascript">// contract-system.js
import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';

class ContractSigningSystem {
  constructor() {
    this.agents = new Map();
  }

  async registerAgent(name, configPath) {
    const agent = new JacsAgent();
    await agent.load(configPath);
    this.agents.set(name, { agent, configPath });
    return agent;
  }

  async createContract(content, sellerName) {
    const seller = this.agents.get(sellerName);
    if (!seller) throw new Error(`Agent ${sellerName} not found`);

    // Create and sign the contract
    const signedContract = await seller.agent.createDocument(
      JSON.stringify(content)
    );

    return JSON.parse(signedContract);
  }

  async createAgreement(contract, agentNames, question) {
    const firstAgent = this.agents.get(agentNames[0]);
    if (!firstAgent) throw new Error(`Agent ${agentNames[0]} not found`);

    // Get agent IDs
    const agentIds = [];
    for (const name of agentNames) {
      const agent = this.agents.get(name);
      if (!agent) throw new Error(`Agent ${name} not found`);
      // Get agent ID from config
      const config = JSON.parse(fs.readFileSync(agent.configPath, 'utf-8'));
      agentIds.push(config.jacs_agent_id_and_version.split(':')[0]);
    }

    const agreementDoc = await firstAgent.agent.createAgreement(
      JSON.stringify(contract),
      agentIds,
      question,
      'Legal contract requiring signatures from all parties'
    );

    return JSON.parse(agreementDoc);
  }

  async signAgreement(agreement, agentName) {
    const agent = this.agents.get(agentName);
    if (!agent) throw new Error(`Agent ${agentName} not found`);

    const signedDoc = await agent.agent.signAgreement(
      JSON.stringify(agreement)
    );

    return JSON.parse(signedDoc);
  }

  async checkAgreementStatus(agreement, agentName) {
    const agent = this.agents.get(agentName);
    if (!agent) throw new Error(`Agent ${agentName} not found`);

    const statusJson = await agent.agent.checkAgreement(
      JSON.stringify(agreement)
    );

    return JSON.parse(statusJson);
  }
}

// Usage
async function runContractWorkflow() {
  const system = new ContractSigningSystem();

  // Register agents
  await system.registerAgent('seller', './seller.config.json');
  await system.registerAgent('buyer', './buyer.config.json');

  // Create contract
  const contract = await system.createContract({
    type: 'purchase_agreement',
    parties: {
      seller: 'Widget Corp',
      buyer: 'Acme Inc'
    },
    items: [
      { name: 'Premium Widgets', quantity: 1000, unitPrice: 10.00 }
    ],
    totalValue: 10000,
    terms: 'Payment due within 30 days of delivery',
    effectiveDate: new Date().toISOString()
  }, 'seller');

  console.log('Contract created:', contract.jacsId);

  // Create agreement
  const agreement = await system.createAgreement(
    contract,
    ['seller', 'buyer'],
    'Do you agree to the terms of this purchase agreement?'
  );

  console.log('Agreement created, awaiting signatures');

  // Seller signs
  let signedAgreement = await system.signAgreement(agreement, 'seller');
  console.log('Seller signed');

  // Check status
  let status = await system.checkAgreementStatus(signedAgreement, 'seller');
  console.log('Status after seller:', status.complete ? 'Complete' : 'Pending');

  // Buyer signs
  signedAgreement = await system.signAgreement(signedAgreement, 'buyer');
  console.log('Buyer signed');

  // Final status
  status = await system.checkAgreementStatus(signedAgreement, 'buyer');
  console.log('Final status:', status.complete ? 'Complete' : 'Pending');

  // Save completed agreement
  fs.writeFileSync(
    './completed-agreement.json',
    JSON.stringify(signedAgreement, null, 2)
  );

  return signedAgreement;
}

runContractWorkflow().catch(console.error);
</code></pre>
<h2 id="secure-api-gateway-with-mcp-tools"><a class="header" href="#secure-api-gateway-with-mcp-tools">Secure API Gateway with MCP Tools</a></h2>
<p>A complete API gateway that authenticates requests and provides MCP tools.</p>
<h3 id="nodejs-implementation"><a class="header" href="#nodejs-implementation">Node.js Implementation</a></h3>
<pre><code class="language-javascript">// api-gateway.js
import express from 'express';
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';
import { JacsAgent } from '@hai.ai/jacs';
import { z } from 'zod';

// Initialize Express
const app = express();
const PORT = 3000;

// Initialize JACS
const agent = new JacsAgent();
await agent.load('./jacs.config.json');

// Create MCP server with tools
const mcpServer = new McpServer({
  name: "secure-api-gateway",
  version: "1.0.0"
});

// Document operations tool
mcpServer.tool("create_document", {
  content: z.object({}).passthrough().describe("Document content"),
  type: z.string().optional().describe("Document type")
}, async ({ content, type }) =&gt; {
  const doc = await agent.createDocument(JSON.stringify({
    ...content,
    documentType: type || 'generic'
  }));
  const parsed = JSON.parse(doc);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        documentId: parsed.jacsId,
        version: parsed.jacsVersion
      })
    }]
  };
});

mcpServer.tool("verify_document", {
  document: z.string().describe("JSON document string to verify")
}, async ({ document }) =&gt; {
  try {
    const isValid = await agent.verifyDocument(document);
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ valid: isValid })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ valid: false, error: error.message })
      }]
    };
  }
});

// Health check (unauthenticated)
app.get('/health', (req, res) =&gt; {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// REST API routes (JACS authenticated)
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Document REST endpoint
app.post('/api/documents', async (req, res) =&gt; {
  if (!req.jacsPayload) {
    return res.status(400).send({ error: 'Invalid JACS request' });
  }

  try {
    const signedDoc = await agent.createDocument(
      JSON.stringify(req.jacsPayload)
    );
    const doc = JSON.parse(signedDoc);

    res.send({
      success: true,
      documentId: doc.jacsId,
      version: doc.jacsVersion
    });
  } catch (error) {
    res.status(500).send({ error: error.message });
  }
});

app.post('/api/documents/verify', async (req, res) =&gt; {
  if (!req.jacsPayload) {
    return res.status(400).send({ error: 'Invalid JACS request' });
  }

  try {
    const isValid = await agent.verifyDocument(
      JSON.stringify(req.jacsPayload.document)
    );
    res.send({ valid: isValid });
  } catch (error) {
    res.status(500).send({ error: error.message });
  }
});

// MCP SSE endpoint (JACS authenticated)
const activeSessions = new Map();

app.get('/mcp/sse', async (req, res) =&gt; {
  const sessionId = Date.now().toString();

  // Create SSE transport with JACS
  const baseTransport = new SSEServerTransport('/mcp/messages', res);
  const secureTransport = createJACSTransportProxy(
    baseTransport,
    './jacs.config.json',
    'server'
  );

  activeSessions.set(sessionId, { transport: secureTransport, res });

  // Connect MCP server
  await mcpServer.connect(secureTransport);

  res.on('close', () =&gt; {
    activeSessions.delete(sessionId);
  });
});

app.post('/mcp/messages', express.text({ type: '*/*' }), async (req, res) =&gt; {
  // Find the active session and handle the message
  for (const [id, session] of activeSessions) {
    try {
      await session.transport.handlePostMessage(req, res, req.body);
      return;
    } catch (error) {
      // Try next session
    }
  }
  res.status(404).send({ error: 'No active session' });
});

// Start server
app.listen(PORT, () =&gt; {
  console.log(`Secure API Gateway running on port ${PORT}`);
  console.log(`  REST API: http://localhost:${PORT}/api`);
  console.log(`  MCP SSE:  http://localhost:${PORT}/mcp/sse`);
});
</code></pre>
<h3 id="python-implementation"><a class="header" href="#python-implementation">Python Implementation</a></h3>
<pre><code class="language-python"># api_gateway.py
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import PlainTextResponse
import jacs
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import uvicorn
import json

app = FastAPI(title="Secure API Gateway")

# Initialize JACS
agent = jacs.JacsAgent()
agent.load('./jacs.config.json')

# Create MCP server with JACS
mcp = JACSMCPServer(FastMCP("secure-api-gateway"))

@mcp.tool()
def create_document(content: dict, document_type: str = "generic") -&gt; str:
    """Create a signed JACS document"""
    doc_content = {**content, "documentType": document_type}
    signed_doc = agent.create_document(json.dumps(doc_content))
    parsed = json.loads(signed_doc)
    return json.dumps({
        "success": True,
        "documentId": parsed["jacsId"],
        "version": parsed["jacsVersion"]
    })

@mcp.tool()
def verify_document(document: str) -&gt; str:
    """Verify a JACS document signature"""
    try:
        is_valid = agent.verify_document(document)
        return json.dumps({"valid": is_valid})
    except Exception as e:
        return json.dumps({"valid": False, "error": str(e)})

# Health check
@app.get("/health")
async def health():
    return {"status": "healthy"}

# REST API endpoints
@app.post("/api/documents")
async def create_doc(request: Request):
    body = await request.body()
    body_str = body.decode('utf-8')

    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid JACS request")

    signed_doc = agent.create_document(json.dumps(payload))
    doc = json.loads(signed_doc)

    result = {
        "success": True,
        "documentId": doc["jacsId"],
        "version": doc["jacsVersion"]
    }

    signed_response = jacs.sign_response(result)
    return PlainTextResponse(content=signed_response)

@app.post("/api/documents/verify")
async def verify_doc(request: Request):
    body = await request.body()
    body_str = body.decode('utf-8')

    try:
        verified = jacs.verify_request(body_str)
        payload = json.loads(verified).get('payload')
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid JACS request")

    document = payload.get("document")
    is_valid = agent.verify_document(json.dumps(document))

    result = {"valid": is_valid}
    signed_response = jacs.sign_response(result)
    return PlainTextResponse(content=signed_response)

# Mount MCP SSE endpoint
app.mount("/mcp", mcp.sse_app())

if __name__ == "__main__":
    print("Secure API Gateway running")
    print("  REST API: http://localhost:8000/api")
    print("  MCP SSE:  http://localhost:8000/mcp/sse")
    uvicorn.run(app, host="localhost", port=8000)
</code></pre>
<h2 id="document-audit-trail-system"><a class="header" href="#document-audit-trail-system">Document Audit Trail System</a></h2>
<p>Track and verify document history with cryptographic proofs.</p>
<pre><code class="language-javascript">// audit-trail.js
import { JacsAgent } from '@hai.ai/jacs';
import fs from 'fs';
import path from 'path';

class AuditTrailSystem {
  constructor(configPath, auditDir = './audit') {
    this.configPath = configPath;
    this.auditDir = auditDir;
    this.agent = null;
  }

  async initialize() {
    this.agent = new JacsAgent();
    await this.agent.load(this.configPath);

    if (!fs.existsSync(this.auditDir)) {
      fs.mkdirSync(this.auditDir, { recursive: true });
    }
  }

  async createDocument(content, metadata = {}) {
    const auditEntry = {
      action: 'create',
      timestamp: new Date().toISOString(),
      content,
      metadata
    };

    const signedDoc = await this.agent.createDocument(
      JSON.stringify({ ...content, _audit: auditEntry })
    );

    const doc = JSON.parse(signedDoc);

    // Save to audit log
    await this.logAuditEntry(doc.jacsId, 'create', doc);

    return doc;
  }

  async updateDocument(originalDoc, newContent, metadata = {}) {
    const auditEntry = {
      action: 'update',
      timestamp: new Date().toISOString(),
      previousVersion: originalDoc.jacsVersion,
      changes: this.computeChanges(originalDoc, newContent),
      metadata
    };

    const updatedDoc = await this.agent.updateDocument(
      JSON.stringify(originalDoc),
      JSON.stringify({ ...newContent, _audit: auditEntry })
    );

    const doc = JSON.parse(updatedDoc);

    // Save to audit log
    await this.logAuditEntry(doc.jacsId, 'update', doc);

    return doc;
  }

  computeChanges(original, updated) {
    const changes = [];

    for (const [key, value] of Object.entries(updated)) {
      if (key.startsWith('_')) continue;

      if (!(key in original)) {
        changes.push({ field: key, type: 'added', newValue: value });
      } else if (JSON.stringify(original[key]) !== JSON.stringify(value)) {
        changes.push({
          field: key,
          type: 'modified',
          oldValue: original[key],
          newValue: value
        });
      }
    }

    for (const key of Object.keys(original)) {
      if (key.startsWith('_') || key.startsWith('jacs')) continue;
      if (!(key in updated)) {
        changes.push({ field: key, type: 'removed', oldValue: original[key] });
      }
    }

    return changes;
  }

  async logAuditEntry(documentId, action, document) {
    const logFile = path.join(this.auditDir, `${documentId}.audit.jsonl`);

    const entry = {
      timestamp: new Date().toISOString(),
      action,
      documentId,
      version: document.jacsVersion,
      signature: document.jacsSignature,
      hash: document.jacsSha256
    };

    fs.appendFileSync(logFile, JSON.stringify(entry) + '\n');
  }

  async getAuditTrail(documentId) {
    const logFile = path.join(this.auditDir, `${documentId}.audit.jsonl`);

    if (!fs.existsSync(logFile)) {
      return [];
    }

    const lines = fs.readFileSync(logFile, 'utf-8').trim().split('\n');
    return lines.map(line =&gt; JSON.parse(line));
  }

  async verifyAuditTrail(documentId) {
    const trail = await this.getAuditTrail(documentId);
    const results = [];

    for (const entry of trail) {
      // Load and verify each version
      const docPath = path.join(
        this.auditDir,
        'documents',
        documentId,
        `${entry.version}.json`
      );

      if (fs.existsSync(docPath)) {
        const docString = fs.readFileSync(docPath, 'utf-8');
        const isValid = await this.agent.verifyDocument(docString);

        results.push({
          version: entry.version,
          timestamp: entry.timestamp,
          action: entry.action,
          valid: isValid
        });
      } else {
        results.push({
          version: entry.version,
          timestamp: entry.timestamp,
          action: entry.action,
          valid: null,
          error: 'Document file not found'
        });
      }
    }

    return results;
  }
}

// Usage
async function runAuditExample() {
  const audit = new AuditTrailSystem('./jacs.config.json');
  await audit.initialize();

  // Create a document
  const doc = await audit.createDocument({
    type: 'financial_report',
    period: 'Q1 2024',
    revenue: 1000000,
    expenses: 750000
  }, { author: 'Finance Team' });

  console.log('Created document:', doc.jacsId);

  // Update the document
  const updated = await audit.updateDocument(doc, {
    type: 'financial_report',
    period: 'Q1 2024',
    revenue: 1000000,
    expenses: 750000,
    profit: 250000,  // Added field
    status: 'approved'
  }, { author: 'CFO', reason: 'Added profit calculation' });

  console.log('Updated to version:', updated.jacsVersion);

  // Get audit trail
  const trail = await audit.getAuditTrail(doc.jacsId);
  console.log('Audit trail:');
  for (const entry of trail) {
    console.log(`  ${entry.timestamp} - ${entry.action} (v${entry.version})`);
  }
}

runAuditExample().catch(console.error);
</code></pre>
<h2 id="multi-tenant-document-service"><a class="header" href="#multi-tenant-document-service">Multi-Tenant Document Service</a></h2>
<p>A complete multi-tenant document service with isolated agents per tenant.</p>
<pre><code class="language-python"># multi_tenant.py
import jacs
import json
import os
from pathlib import Path
from typing import Dict, Optional

class TenantManager:
    def __init__(self, base_dir: str = './tenants'):
        self.base_dir = Path(base_dir)
        self.agents: Dict[str, jacs.JacsAgent] = {}

    def initialize_tenant(self, tenant_id: str) -&gt; dict:
        """Create a new tenant with its own JACS agent"""
        tenant_dir = self.base_dir / tenant_id
        data_dir = tenant_dir / 'data'
        key_dir = tenant_dir / 'keys'

        # Create directories
        data_dir.mkdir(parents=True, exist_ok=True)
        key_dir.mkdir(parents=True, exist_ok=True)

        # Create tenant config
        config = {
            "jacs_data_directory": str(data_dir),
            "jacs_key_directory": str(key_dir),
            "jacs_agent_key_algorithm": "ring-Ed25519",
            "jacs_default_storage": "fs"
        }

        config_path = tenant_dir / 'jacs.config.json'
        with open(config_path, 'w') as f:
            json.dump(config, f, indent=2)

        # Initialize agent
        agent = jacs.JacsAgent()
        agent.load(str(config_path))
        self.agents[tenant_id] = agent

        return {
            "tenant_id": tenant_id,
            "config_path": str(config_path),
            "initialized": True
        }

    def get_agent(self, tenant_id: str) -&gt; Optional[jacs.JacsAgent]:
        """Get the JACS agent for a tenant"""
        if tenant_id not in self.agents:
            # Try to load existing tenant
            config_path = self.base_dir / tenant_id / 'jacs.config.json'
            if config_path.exists():
                agent = jacs.JacsAgent()
                agent.load(str(config_path))
                self.agents[tenant_id] = agent

        return self.agents.get(tenant_id)

    def create_document(self, tenant_id: str, content: dict) -&gt; dict:
        """Create a document for a tenant"""
        agent = self.get_agent(tenant_id)
        if not agent:
            raise ValueError(f"Tenant {tenant_id} not found")

        signed_doc = agent.create_document(json.dumps(content))
        return json.loads(signed_doc)

    def verify_document(self, tenant_id: str, doc_string: str) -&gt; bool:
        """Verify a document for a tenant"""
        agent = self.get_agent(tenant_id)
        if not agent:
            raise ValueError(f"Tenant {tenant_id} not found")

        return agent.verify_document(doc_string)

    def list_tenants(self) -&gt; list:
        """List all tenants"""
        if not self.base_dir.exists():
            return []

        return [
            d.name for d in self.base_dir.iterdir()
            if d.is_dir() and (d / 'jacs.config.json').exists()
        ]

class MultiTenantDocumentService:
    def __init__(self):
        self.tenant_manager = TenantManager()

    def create_tenant(self, tenant_id: str) -&gt; dict:
        return self.tenant_manager.initialize_tenant(tenant_id)

    def create_document(self, tenant_id: str, content: dict) -&gt; dict:
        doc = self.tenant_manager.create_document(tenant_id, content)

        # Save document
        tenant_dir = self.tenant_manager.base_dir / tenant_id / 'documents'
        tenant_dir.mkdir(parents=True, exist_ok=True)

        doc_path = tenant_dir / f"{doc['jacsId']}.json"
        with open(doc_path, 'w') as f:
            json.dump(doc, f, indent=2)

        return {
            "tenant_id": tenant_id,
            "document_id": doc['jacsId'],
            "version": doc['jacsVersion'],
            "path": str(doc_path)
        }

    def get_document(self, tenant_id: str, document_id: str) -&gt; Optional[dict]:
        doc_path = (
            self.tenant_manager.base_dir / tenant_id /
            'documents' / f"{document_id}.json"
        )

        if not doc_path.exists():
            return None

        with open(doc_path, 'r') as f:
            return json.load(f)

    def verify_document(self, tenant_id: str, document_id: str) -&gt; dict:
        doc = self.get_document(tenant_id, document_id)
        if not doc:
            return {"valid": False, "error": "Document not found"}

        is_valid = self.tenant_manager.verify_document(
            tenant_id, json.dumps(doc)
        )

        return {
            "tenant_id": tenant_id,
            "document_id": document_id,
            "valid": is_valid
        }

# Usage
if __name__ == "__main__":
    service = MultiTenantDocumentService()

    # Create tenants
    tenant1 = service.create_tenant("acme-corp")
    tenant2 = service.create_tenant("globex-inc")
    print(f"Created tenants: {tenant1['tenant_id']}, {tenant2['tenant_id']}")

    # Create documents for each tenant
    doc1 = service.create_document("acme-corp", {
        "type": "invoice",
        "amount": 5000,
        "customer": "John Doe"
    })
    print(f"Acme Corp document: {doc1['document_id']}")

    doc2 = service.create_document("globex-inc", {
        "type": "contract",
        "value": 100000,
        "parties": ["Globex", "Initech"]
    })
    print(f"Globex Inc document: {doc2['document_id']}")

    # Verify documents
    verify1 = service.verify_document("acme-corp", doc1['document_id'])
    verify2 = service.verify_document("globex-inc", doc2['document_id'])
    print(f"Acme Corp verification: {verify1['valid']}")
    print(f"Globex Inc verification: {verify2['valid']}")

    # Cross-tenant verification should fail
    cross = service.verify_document("acme-corp", doc2['document_id'])
    print(f"Cross-tenant verification: {cross}")
</code></pre>
<h2 id="webhook-notification-system"><a class="header" href="#webhook-notification-system">Webhook Notification System</a></h2>
<p>Notify external systems when documents are signed.</p>
<pre><code class="language-javascript">// webhook-notifier.js
import { JacsAgent } from '@hai.ai/jacs';
import express from 'express';
import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

const app = express();
const PORT = 3000;

// Initialize JACS
const agent = new JacsAgent();
await agent.load('./jacs.config.json');

// Webhook configuration
const webhooks = new Map();

// Register a webhook
app.post('/webhooks', express.json(), (req, res) =&gt; {
  const { url, events, secret } = req.body;
  const webhookId = crypto.randomUUID();

  webhooks.set(webhookId, { url, events, secret, active: true });

  res.json({ webhookId, message: 'Webhook registered' });
});

// JACS-protected document endpoints
app.use('/api', express.text({ type: '*/*' }));
app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

app.post('/api/documents', async (req, res) =&gt; {
  if (!req.jacsPayload) {
    return res.status(400).send({ error: 'Invalid JACS request' });
  }

  // Create document
  const signedDoc = await agent.createDocument(
    JSON.stringify(req.jacsPayload)
  );
  const doc = JSON.parse(signedDoc);

  // Notify webhooks
  await notifyWebhooks('document.created', {
    documentId: doc.jacsId,
    version: doc.jacsVersion,
    timestamp: new Date().toISOString()
  });

  res.send({
    success: true,
    documentId: doc.jacsId
  });
});

async function notifyWebhooks(event, payload) {
  for (const [id, webhook] of webhooks) {
    if (!webhook.active) continue;
    if (!webhook.events.includes(event) &amp;&amp; !webhook.events.includes('*')) continue;

    try {
      // Sign the webhook payload with JACS
      const signedPayload = await agent.signRequest({
        event,
        payload,
        timestamp: new Date().toISOString(),
        webhookId: id
      });

      // Send webhook
      const response = await fetch(webhook.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain',
          'X-JACS-Signature': 'v1',
          'X-Webhook-Secret': webhook.secret
        },
        body: signedPayload
      });

      if (!response.ok) {
        console.error(`Webhook ${id} failed: ${response.status}`);
      }
    } catch (error) {
      console.error(`Webhook ${id} error:`, error.message);
    }
  }
}

app.listen(PORT, () =&gt; {
  console.log(`Webhook notification server running on port ${PORT}`);
});
</code></pre>
<h2 id="see-also-25"><a class="header" href="#see-also-25">See Also</a></h2>
<ul>
<li><a href="examples/cli.html">CLI Examples</a> - Command-line examples</li>
<li><a href="examples/nodejs.html">Node.js Examples</a> - Node.js code examples</li>
<li><a href="examples/python.html">Python Examples</a> - Python code examples</li>
<li><a href="examples/../integrations/mcp.html">MCP Integration</a> - MCP details</li>
<li><a href="examples/../integrations/web-servers.html">Web Servers</a> - HTTP integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-command-reference"><a class="header" href="#cli-command-reference">CLI Command Reference</a></h1>
<p>This page provides a comprehensive reference for all JACS command-line interface commands.</p>
<h2 id="global-commands"><a class="header" href="#global-commands">Global Commands</a></h2>
<h3 id="jacs-version"><a class="header" href="#jacs-version"><code>jacs version</code></a></h3>
<p>Prints version and build information for the JACS installation.</p>
<pre><code class="language-bash">jacs version
</code></pre>
<h3 id="jacs-quickstart"><a class="header" href="#jacs-quickstart"><code>jacs quickstart</code></a></h3>
<p>Create an ephemeral agent and optionally sign data -- no config file, no setup. This is the fastest way to start using JACS.</p>
<pre><code class="language-bash"># Print agent info (ID, algorithm)
jacs quickstart

# Sign JSON from stdin
echo '{"action":"approve"}' | jacs quickstart --sign

# Sign a file
jacs quickstart --sign --file mydata.json

# Use a specific algorithm
jacs quickstart --algorithm ring-Ed25519
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>--algorithm &lt;algo&gt;</code> - Signing algorithm (default: <code>pq2025</code>). Also: <code>ring-Ed25519</code>, <code>RSA-PSS</code></li>
<li><code>--sign</code> - Sign input (from stdin or <code>--file</code>) instead of printing info</li>
<li><code>--file &lt;path&gt;</code> - Read JSON input from file instead of stdin (requires <code>--sign</code>)</li>
</ul>
<h3 id="jacs-init"><a class="header" href="#jacs-init"><code>jacs init</code></a></h3>
<p>Initialize JACS by creating both configuration and agent (with cryptographic keys). Use this for persistent agent setup.</p>
<pre><code class="language-bash">jacs init
</code></pre>
<h3 id="jacs-help"><a class="header" href="#jacs-help"><code>jacs help</code></a></h3>
<p>Print help information for JACS commands.</p>
<pre><code class="language-bash">jacs help [COMMAND]
</code></pre>
<h2 id="configuration-commands-1"><a class="header" href="#configuration-commands-1">Configuration Commands</a></h2>
<h3 id="jacs-config"><a class="header" href="#jacs-config"><code>jacs config</code></a></h3>
<p>Work with JACS configuration settings.</p>
<pre><code class="language-bash">jacs config [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for config are not detailed in the current help output.</em></p>
<h2 id="agent-commands-1"><a class="header" href="#agent-commands-1">Agent Commands</a></h2>
<h3 id="jacs-agent"><a class="header" href="#jacs-agent"><code>jacs agent</code></a></h3>
<p>Work with JACS agents - the cryptographic identities that sign and verify documents.</p>
<pre><code class="language-bash">jacs agent [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for agent management are not detailed in the current help output.</em></p>
<h2 id="task-commands-1"><a class="header" href="#task-commands-1">Task Commands</a></h2>
<h3 id="jacs-task"><a class="header" href="#jacs-task"><code>jacs task</code></a></h3>
<p>Work with JACS agent tasks - structured workflows between agents.</p>
<pre><code class="language-bash">jacs task [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for task management are not detailed in the current help output.</em></p>
<h2 id="document-commands-1"><a class="header" href="#document-commands-1">Document Commands</a></h2>
<p>The <code>jacs document</code> command provides comprehensive document management capabilities.</p>
<h3 id="jacs-document-create"><a class="header" href="#jacs-document-create"><code>jacs document create</code></a></h3>
<p>Create a new JACS document, either by embedding or parsing a document with optional file attachments.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document create [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file. If not specified, uses config <code>jacs_agent_id_and_version</code></li>
<li><code>-f &lt;filename&gt;</code> - Path to input file. Must be JSON format</li>
<li><code>-o &lt;output&gt;</code> - Output filename for the created document</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files. Files should end with <code>.json</code></li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-n, --no-save</code> - Instead of saving files, print to stdout</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file to use for validation</li>
<li><code>--attach &lt;attach&gt;</code> - Path to file or directory for file attachments</li>
<li><code>-e, --embed &lt;embed&gt;</code> - Embed documents or keep them external [possible values: true, false]</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Create document from JSON file
jacs document create -f my-document.json

# Create document with embedded attachment
jacs document create -f document.json --attach ./image.jpg --embed true

# Create document with referenced attachment
jacs document create -f document.json --attach ./data.csv --embed false

# Create from directory of JSON files
jacs document create -d ./documents/

# Create with custom schema validation
jacs document create -f document.json -s custom-schema.json

# Print to stdout instead of saving
jacs document create -f document.json --no-save
</code></pre>
<h3 id="jacs-document-update"><a class="header" href="#jacs-document-update"><code>jacs document update</code></a></h3>
<p>Create a new version of an existing document. Requires both the original JACS file and the modified JACS metadata.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document update [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to original document file</li>
<li><code>-n &lt;new-file&gt;</code> - Path to new/modified document file</li>
<li><code>-o &lt;output&gt;</code> - Output filename for updated document</li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-n, --no-save</code> - Print to stdout instead of saving</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file for validation</li>
<li><code>--attach &lt;attach&gt;</code> - Path to file or directory for additional attachments</li>
<li><code>-e, --embed &lt;embed&gt;</code> - Embed new attachments or keep them external</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Update document with new version
jacs document update -f original.json -n modified.json -o updated.json

# Update and add new attachments
jacs document update -f original.json -n modified.json --attach ./new-file.pdf --embed false
</code></pre>
<h3 id="jacs-document-verify"><a class="header" href="#jacs-document-verify"><code>jacs document verify</code></a></h3>
<p>Verify a document's hash, signatures, and schema compliance.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document verify [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to input file. Must be JSON format</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files. Files should end with <code>.json</code></li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file to use for validation</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Verify single document
jacs document verify -f signed-document.json

# Verify all documents in directory
jacs document verify -d ./documents/

# Verify with custom schema
jacs document verify -f document.json -s custom-schema.json
</code></pre>
<p><strong>Verification Process:</strong></p>
<ol>
<li><strong>Hash verification</strong> - Confirms document integrity</li>
<li><strong>Signature verification</strong> - Validates cryptographic signatures</li>
<li><strong>Schema validation</strong> - Ensures document structure compliance</li>
<li><strong>File integrity</strong> - Checks SHA256 checksums of attached files</li>
</ol>
<h3 id="jacs-document-extract"><a class="header" href="#jacs-document-extract"><code>jacs document extract</code></a></h3>
<p>Extract embedded file contents from documents back to the filesystem.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document extract [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to input file containing embedded files</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files to process</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file for validation</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Extract embedded files from single document
jacs document extract -f document-with-embedded-files.json

# Extract from all documents in directory  
jacs document extract -d ./documents/
</code></pre>
<p><strong>Extract Process:</strong></p>
<ol>
<li>Reads embedded file contents from document</li>
<li>Decodes base64-encoded data</li>
<li>Writes files to their original paths</li>
<li>Creates backup of existing files (with timestamp)</li>
</ol>
<h3 id="agreement-commands-1"><a class="header" href="#agreement-commands-1">Agreement Commands</a></h3>
<p>JACS provides specialized commands for managing multi-agent agreements.</p>
<h4 id="jacs-document-check-agreement"><a class="header" href="#jacs-document-check-agreement"><code>jacs document check-agreement</code></a></h4>
<p>Given a document, provide a list of agents that should sign the document.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document check-agreement [OPTIONS]
</code></pre>
<h4 id="jacs-document-create-agreement"><a class="header" href="#jacs-document-create-agreement"><code>jacs document create-agreement</code></a></h4>
<p>Create an agreement structure for a document that requires multiple agent signatures.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document create-agreement [OPTIONS]
</code></pre>
<h4 id="jacs-document-sign-agreement"><a class="header" href="#jacs-document-sign-agreement"><code>jacs document sign-agreement</code></a></h4>
<p>Sign the agreement section of a document with the current agent's cryptographic signature.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document sign-agreement [OPTIONS]
</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="basic-document-lifecycle"><a class="header" href="#basic-document-lifecycle">Basic Document Lifecycle</a></h3>
<pre><code class="language-bash"># 1. Initialize JACS
jacs init

# 2. Create document with attachments
jacs document create -f document.json --attach ./files/ --embed true

# 3. Verify document integrity
jacs document verify -f created-document.json

# 4. Update document if needed
jacs document update -f original.json -n modified.json

# 5. Extract embedded files when needed
jacs document extract -f document.json
</code></pre>
<h3 id="working-with-attachments"><a class="header" href="#working-with-attachments">Working with Attachments</a></h3>
<pre><code class="language-bash"># Embed small files for portability
jacs document create -f doc.json --attach ./small-image.png --embed true

# Reference large files to save space
jacs document create -f doc.json --attach ./large-video.mp4 --embed false

# Attach multiple files from directory
jacs document create -f doc.json --attach ./attachments/ --embed false
</code></pre>
<h3 id="schema-validation-workflow"><a class="header" href="#schema-validation-workflow">Schema Validation Workflow</a></h3>
<pre><code class="language-bash"># Create with schema validation
jacs document create -f document.json -s schema.json

# Verify against specific schema
jacs document verify -f document.json -s schema.json
</code></pre>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<p>Most commands support these common options:</p>
<ul>
<li><code>-h, --help</code> - Show help information</li>
<li><code>-v, --verbose</code> - Enable verbose output for debugging</li>
<li><code>-a &lt;agent-file&gt;</code> - Specify custom agent file (overrides config default)</li>
</ul>
<h2 id="exit-codes-1"><a class="header" href="#exit-codes-1">Exit Codes</a></h2>
<ul>
<li><code>0</code> - Success</li>
<li><code>1</code> - General error (invalid arguments, file not found, etc.)</li>
<li><code>2</code> - Verification failure (hash mismatch, invalid signature, etc.)</li>
<li><code>3</code> - Schema validation failure</li>
</ul>
<h2 id="environment-variables-8"><a class="header" href="#environment-variables-8">Environment Variables</a></h2>
<ul>
<li><code>JACS_CONFIG_PATH</code> - Override default configuration file location</li>
<li><code>JACS_DATA_DIR</code> - Override default data directory location</li>
<li><code>JACS_AGENT_FILE</code> - Default agent file to use (if not specified with <code>-a</code>)</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<h3 id="input-files"><a class="header" href="#input-files">Input Files</a></h3>
<ul>
<li><strong>JSON documents</strong> - Must be valid JSON format</li>
<li><strong>Schema files</strong> - JSON Schema format (draft-07 compatible)</li>
<li><strong>Agent files</strong> - JACS agent format with cryptographic keys</li>
<li><strong>Attachments</strong> - Any file type (automatically detected MIME type)</li>
</ul>
<h3 id="output-files"><a class="header" href="#output-files">Output Files</a></h3>
<ul>
<li><strong>JACS documents</strong> - JSON format with JACS metadata, signatures, and checksums</li>
<li><strong>Extracted files</strong> - Original format of embedded attachments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<h2 id="overview-17"><a class="header" href="#overview-17">Overview</a></h2>
<h3 id="key-resolution-for-verifiers"><a class="header" href="#key-resolution-for-verifiers">Key resolution for verifiers</a></h3>
<p>When verifying signed documents, JACS resolves the signer‚Äôs public key using a configurable order of sources. Set <strong><code>JACS_KEY_RESOLUTION</code></strong> (environment variable or in config) to a comma-separated list of sources: <code>local</code> (trust store), <code>dns</code> (DNS TXT record), <code>hai</code> (HAI key service). Example: <code>JACS_KEY_RESOLUTION=local,hai</code> or <code>local,dns,hai</code>. The first source that returns a key for the signer‚Äôs ID is used. Use <code>verify_standalone()</code> with explicit <code>keyResolution</code> for one-off verification without loading a full config.</p>
<h2 id="zero-config-path"><a class="header" href="#zero-config-path">Zero-Config Path</a></h2>
<p>If you just want to sign and verify without any configuration, use <code>quickstart()</code>:</p>
<pre><code class="language-python">import jacs.simple as jacs
jacs.quickstart()  # No config file needed
</code></pre>
<pre><code class="language-javascript">const jacs = require('@hai.ai/jacs/simple');
jacs.quickstart();  // No config file needed
</code></pre>
<pre><code class="language-bash">jacs quickstart  # CLI -- no config file needed
</code></pre>
<p><code>quickstart()</code> creates an ephemeral agent with keys in memory. No files are written to disk.</p>
<h2 id="minimal-configuration"><a class="header" href="#minimal-configuration">Minimal Configuration</a></h2>
<p>For persistent agents, a config file needs only two fields (plus <code>$schema</code>):</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_agent_id_and_version": "YOUR_AGENT_ID:YOUR_VERSION",
  "jacs_agent_key_algorithm": "ring-Ed25519"
}
</code></pre>
<p>All other settings use sensible defaults (<code>./jacs_data</code>, <code>./jacs_keys</code>, <code>fs</code> storage). Override only what you need.</p>
<h2 id="complete-example-configuration"><a class="header" href="#complete-example-configuration">Complete Example Configuration</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_use_security": "false",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_private_key_filename": "jacs.private.pem.enc",
  "jacs_agent_public_key_filename": "jacs.public.pem",
  "jacs_agent_key_algorithm": "RSA-PSS",
  "jacs_default_storage": "fs",
  "observability": {
    "logs": {
      "enabled": true,
      "level": "info",
      "destination": {
        "type": "file",
        "path": "./logs"
      },
      "headers": {
        "Authorization": "Bearer token",
        "X-API-Key": "secret"
      }
    },
    "metrics": {
      "enabled": true,
      "destination": {
        "type": "prometheus",
        "endpoint": "http://localhost:9090/api/v1/write",
        "headers": {
          "Authorization": "Basic dXNlcjpwYXNz"
        }
      },
      "export_interval_seconds": 60,
      "headers": {
        "X-Service": "jacs"
      }
    },
    "tracing": {
      "enabled": true,
      "sampling": {
        "ratio": 0.1,
        "parent_based": true,
        "rate_limit": 100
      },
      "resource": {
        "service_name": "jacs",
        "service_version": "0.4.0",
        "environment": "production",
        "attributes": {
          "team": "platform",
          "region": "us-west-2"
        }
      }
    }
  }
}
</code></pre>
<h2 id="observability-configuration-1"><a class="header" href="#observability-configuration-1">Observability Configuration</a></h2>
<p>JACS supports comprehensive observability through configurable logging, metrics, and tracing. All observability features are optional and can be configured in the <code>jacs.config.json</code> file.</p>
<h3 id="logs-configuration-1"><a class="header" href="#logs-configuration-1">Logs Configuration</a></h3>
<p>Controls how JACS generates and outputs log messages.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether logging is enabled</td></tr>
<tr><td><code>level</code></td><td>string</td><td>Yes</td><td>Minimum log level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code></td></tr>
<tr><td><code>destination</code></td><td>object</td><td>Yes</td><td>Where logs are sent (see destinations below)</td></tr>
<tr><td><code>headers</code></td><td>object</td><td>No</td><td>Additional headers for remote destinations</td></tr>
</tbody></table>
</div>
<h4 id="log-destinations-2"><a class="header" href="#log-destinations-2">Log Destinations</a></h4>
<p><strong>File Logging</strong></p>
<pre><code class="language-json">{
  "type": "file",
  "path": "./logs"
}
</code></pre>
<p>Writes logs to rotating files in the specified directory.</p>
<p><strong>Console Logging (stderr)</strong></p>
<pre><code class="language-json">{
  "type": "stderr"
}
</code></pre>
<p>Outputs logs to standard error stream.</p>
<p><strong>OpenTelemetry Protocol (OTLP)</strong></p>
<pre><code class="language-json">{
  "type": "otlp",
  "endpoint": "http://localhost:4317",
  "headers": {
    "Authorization": "Bearer token"
  }
}
</code></pre>
<p>Sends logs to an OTLP-compatible endpoint (like Jaeger, Grafana Cloud).</p>
<p><strong>Null (disabled)</strong></p>
<pre><code class="language-json">{
  "type": "null"
}
</code></pre>
<p>Discards all log output.</p>
<h3 id="metrics-configuration-1"><a class="header" href="#metrics-configuration-1">Metrics Configuration</a></h3>
<p>Controls collection and export of application metrics.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether metrics collection is enabled</td></tr>
<tr><td><code>destination</code></td><td>object</td><td>Yes</td><td>Where metrics are exported (see destinations below)</td></tr>
<tr><td><code>export_interval_seconds</code></td><td>integer</td><td>No</td><td>How often to export metrics (default: 60)</td></tr>
<tr><td><code>headers</code></td><td>object</td><td>No</td><td>Additional headers for remote destinations</td></tr>
</tbody></table>
</div>
<h4 id="metrics-destinations-2"><a class="header" href="#metrics-destinations-2">Metrics Destinations</a></h4>
<p><strong>Prometheus Remote Write</strong></p>
<pre><code class="language-json">{
  "type": "prometheus",
  "endpoint": "http://localhost:9090/api/v1/write",
  "headers": {
    "Authorization": "Basic dXNlcjpwYXNz"
  }
}
</code></pre>
<p>Exports metrics in Prometheus format to a remote write endpoint.</p>
<p><strong>OpenTelemetry Protocol (OTLP)</strong></p>
<pre><code class="language-json">{
  "type": "otlp",
  "endpoint": "http://localhost:4317",
  "headers": {
    "Authorization": "Bearer token"
  }
}
</code></pre>
<p>Exports metrics to an OTLP-compatible endpoint.</p>
<p><strong>File Export</strong></p>
<pre><code class="language-json">{
  "type": "file",
  "path": "./metrics.txt"
}
</code></pre>
<p>Writes metrics to a local file.</p>
<p><strong>Console Output (stdout)</strong></p>
<pre><code class="language-json">{
  "type": "stdout"
}
</code></pre>
<p>Prints metrics to standard output.</p>
<h3 id="tracing-configuration-1"><a class="header" href="#tracing-configuration-1">Tracing Configuration</a></h3>
<p>Controls distributed tracing for request flows.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether tracing is enabled</td></tr>
<tr><td><code>sampling</code></td><td>object</td><td>No</td><td>Sampling configuration (see below)</td></tr>
<tr><td><code>resource</code></td><td>object</td><td>No</td><td>Service identification (see below)</td></tr>
</tbody></table>
</div>
<h4 id="sampling-configuration-1"><a class="header" href="#sampling-configuration-1">Sampling Configuration</a></h4>
<p>Controls which traces are collected to manage overhead.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ratio</code></td><td>number</td><td>1.0</td><td>Fraction of traces to sample (0.0-1.0)</td></tr>
<tr><td><code>parent_based</code></td><td>boolean</td><td>true</td><td>Whether to respect parent trace sampling decisions</td></tr>
<tr><td><code>rate_limit</code></td><td>integer</td><td>none</td><td>Maximum traces per second</td></tr>
</tbody></table>
</div>
<p><strong>Examples:</strong></p>
<ul>
<li><code>"ratio": 1.0</code> - Sample all traces (100%)</li>
<li><code>"ratio": 0.1</code> - Sample 10% of traces</li>
<li><code>"ratio": 0.01</code> - Sample 1% of traces</li>
<li><code>"rate_limit": 10</code> - Maximum 10 traces per second</li>
</ul>
<h4 id="resource-configuration"><a class="header" href="#resource-configuration">Resource Configuration</a></h4>
<p>Identifies the service in distributed tracing systems.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>service_name</code></td><td>string</td><td>Yes</td><td>Name of the service</td></tr>
<tr><td><code>service_version</code></td><td>string</td><td>No</td><td>Version of the service</td></tr>
<tr><td><code>environment</code></td><td>string</td><td>No</td><td>Environment (dev, staging, prod)</td></tr>
<tr><td><code>attributes</code></td><td>object</td><td>No</td><td>Custom key-value attributes</td></tr>
</tbody></table>
</div>
<h2 id="authentication--headers"><a class="header" href="#authentication--headers">Authentication &amp; Headers</a></h2>
<p>For remote destinations (OTLP, Prometheus), you can specify authentication headers:</p>
<p><strong>Bearer Token Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "Authorization": "Bearer your-token-here"
}
</code></pre>
<p><strong>Basic Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "Authorization": "Basic dXNlcjpwYXNz"
}
</code></pre>
<p><strong>API Key Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "X-API-Key": "your-api-key",
  "X-Auth-Token": "your-auth-token"
}
</code></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "debug",
    "destination": { "type": "stderr" }
  },
  "metrics": {
    "enabled": true,
    "destination": { "type": "stdout" }
  }
}
</code></pre>
<h3 id="production-configuration-1"><a class="header" href="#production-configuration-1">Production Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "info",
    "destination": {
      "type": "otlp",
      "endpoint": "https://logs.example.com:4317",
      "headers": {
        "Authorization": "Bearer prod-token"
      }
    }
  },
  "metrics": {
    "enabled": true,
    "destination": {
      "type": "prometheus",
      "endpoint": "https://metrics.example.com/api/v1/write"
    },
    "export_interval_seconds": 30
  },
  "tracing": {
    "enabled": true,
    "sampling": {
      "ratio": 0.05,
      "rate_limit": 100
    },
    "resource": {
      "service_name": "jacs",
      "service_version": "0.4.0",
      "environment": "production"
    }
  }
}
</code></pre>
<h3 id="file-based-configuration"><a class="header" href="#file-based-configuration">File-based Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "info",
    "destination": {
      "type": "file",
      "path": "/var/log/jacs"
    }
  },
  "metrics": {
    "enabled": true,
    "destination": {
      "type": "file",
      "path": "/var/log/jacs/metrics.txt"
    },
    "export_interval_seconds": 60
  }
}
</code></pre>
<h2 id="environment-variable-integration"><a class="header" href="#environment-variable-integration">Environment Variable Integration</a></h2>
<p>The observability configuration works alongside JACS's core configuration system.</p>
<h3 id="required-environment-variable"><a class="header" href="#required-environment-variable">Required Environment Variable</a></h3>
<p>Only <strong>one</strong> environment variable is truly required:</p>
<ul>
<li><code>JACS_PRIVATE_KEY_PASSWORD</code> - Password for encrypting/decrypting private keys (required for cryptographic operations)</li>
</ul>
<h3 id="configuration-based-settings"><a class="header" href="#configuration-based-settings">Configuration-Based Settings</a></h3>
<p>All other JACS settings are <strong>configuration file fields</strong> that have sensible defaults:</p>
<ul>
<li><code>jacs_data_directory</code> - Where agent/document data is stored (default: <code>./jacs_data</code>)</li>
<li><code>jacs_key_directory</code> - Where cryptographic keys are stored (default: <code>./jacs_keys</code>)</li>
<li><code>jacs_agent_key_algorithm</code> - Cryptographic algorithm to use (default: <code>RSA-PSS</code>)</li>
<li><code>jacs_default_storage</code> - Storage backend (default: <code>fs</code>)</li>
<li><code>jacs_use_security</code> / <code>JACS_ENABLE_FILESYSTEM_QUARANTINE</code> - Enable filesystem quarantine of executable files (default: <code>false</code>). The env var <code>JACS_USE_SECURITY</code> is deprecated; use <code>JACS_ENABLE_FILESYSTEM_QUARANTINE</code> instead.</li>
</ul>
<p>These can be overridden by environment variables if needed, but they are primarily configured through the <code>jacs.config.json</code> file.</p>
<p>The observability configuration is completely optional - JACS will work without any observability configuration.</p>
<h2 id="storage-configuration-1"><a class="header" href="#storage-configuration-1">Storage Configuration</a></h2>
<p>The <code>jacs_default_storage</code> field determines where JACS stores agent data, documents, and keys. This is a critical configuration that affects how your data is persisted and accessed.</p>
<h3 id="available-storage-backends"><a class="header" href="#available-storage-backends">Available Storage Backends</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Backend</th><th>Value</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Filesystem</strong></td><td><code>"fs"</code></td><td>Local file system storage</td><td>Development, single-node deployments</td></tr>
<tr><td><strong>AWS S3</strong></td><td><code>"aws"</code></td><td>Amazon S3 object storage</td><td>Production, cloud deployments</td></tr>
<tr><td><strong>HAI Remote</strong></td><td><code>"hai"</code></td><td>HAI.ai remote storage service</td><td>HAI.ai platform integration</td></tr>
<tr><td><strong>Memory</strong></td><td><code>"memory"</code></td><td>In-memory storage (non-persistent)</td><td>Testing, temporary data</td></tr>
<tr><td><strong>Web Local</strong></td><td><code>"local"</code></td><td>Browser local storage (WASM only)</td><td>Web applications</td></tr>
</tbody></table>
</div>
<h3 id="backend-specific-configuration"><a class="header" href="#backend-specific-configuration">Backend-Specific Configuration</a></h3>
<h4 id="filesystem-storage-fs-1"><a class="header" href="#filesystem-storage-fs-1">Filesystem Storage (<code>"fs"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<p><strong>Requirements:</strong> None - works out of the box
<strong>Data location:</strong> Local directories as specified in config
<strong>Best for:</strong> Development, local testing, single-machine deployments</p>
<h4 id="aws-s3-storage-aws-1"><a class="header" href="#aws-s3-storage-aws-1">AWS S3 Storage (<code>"aws"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "aws"
}
</code></pre>
<p><strong>Required Environment Variables:</strong></p>
<ul>
<li><code>JACS_ENABLE_AWS_BUCKET_NAME</code> - S3 bucket name</li>
<li><code>AWS_ACCESS_KEY_ID</code> - AWS access key</li>
<li><code>AWS_SECRET_ACCESS_KEY</code> - AWS secret key</li>
<li><code>AWS_REGION</code> - AWS region (optional, defaults to us-east-1)</li>
</ul>
<p><strong>Best for:</strong> Production deployments, distributed systems, cloud-native applications</p>
<h4 id="hai-remote-storage-hai"><a class="header" href="#hai-remote-storage-hai">HAI Remote Storage (<code>"hai"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "hai"
}
</code></pre>
<p><strong>Required Environment Variables:</strong></p>
<ul>
<li><code>HAI_STORAGE_URL</code> - HAI.ai storage service endpoint</li>
</ul>
<p><strong>Best for:</strong> Integration with HAI.ai platform services</p>
<h4 id="memory-storage-memory"><a class="header" href="#memory-storage-memory">Memory Storage (<code>"memory"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "memory"
}
</code></pre>
<p><strong>Requirements:</strong> None
<strong>Data persistence:</strong> None - data is lost when application stops
<strong>Best for:</strong> Unit testing, temporary operations, development scenarios</p>
<h3 id="storage-behavior"><a class="header" href="#storage-behavior">Storage Behavior</a></h3>
<ul>
<li><strong>Agent data</strong> (agent definitions, signatures) are stored using the configured backend</li>
<li><strong>Documents</strong> are stored using the configured backend</li>
<li><strong>Cryptographic keys</strong> are stored using the configured backend</li>
<li><strong>Observability data</strong> (logs, metrics) can use separate storage via observability configuration</li>
</ul>
<h3 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h3>
<p><strong>Development Setup (Filesystem)</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./dev_data",
  "jacs_key_directory": "./dev_keys"
}
</code></pre>
<p><strong>Production Setup (AWS S3)</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "aws"
}
</code></pre>
<p>With environment variables:</p>
<pre><code class="language-bash">export JACS_ENABLE_AWS_BUCKET_NAME="my-jacs-production-bucket"
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_REGION="us-west-2"
</code></pre>
<p><strong>HAI Platform Integration</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "hai"
}
</code></pre>
<p>With environment variable:</p>
<pre><code class="language-bash">export HAI_STORAGE_URL="https://storage.hai.ai/v1"
</code></pre>
<h3 id="security-considerations-8"><a class="header" href="#security-considerations-8">Security Considerations</a></h3>
<ul>
<li><strong>AWS S3</strong>: Ensure proper IAM permissions for bucket access</li>
<li><strong>HAI Remote</strong>: Secure the <code>HAI_STORAGE_URL</code> endpoint and any required authentication</li>
<li><strong>Filesystem</strong>: Ensure proper file system permissions for data and key directories</li>
<li><strong>Keys</strong>: Regardless of storage backend, always set <code>JACS_PRIVATE_KEY_PASSWORD</code> for key encryption</li>
</ul>
<h3 id="migration-between-storage-backends"><a class="header" href="#migration-between-storage-backends">Migration Between Storage Backends</a></h3>
<p>When changing storage backends, you'll need to:</p>
<ol>
<li>Export existing data from the current backend</li>
<li>Update the <code>jacs_default_storage</code> configuration</li>
<li>Set any required environment variables for the new backend</li>
<li>Import data into the new backend</li>
</ol>
<p>JACS doesn't automatically migrate data between storage backends - this must be done manually or via custom scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h1>
<p>This reference documents error codes and messages you may encounter when using JACS.</p>
<h2 id="cli-exit-codes"><a class="header" href="#cli-exit-codes">CLI Exit Codes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Success</td><td>Operation completed successfully</td></tr>
<tr><td>1</td><td>General Error</td><td>Unspecified error occurred</td></tr>
<tr><td>2</td><td>Invalid Arguments</td><td>Command line arguments invalid</td></tr>
<tr><td>3</td><td>File Not Found</td><td>Specified file does not exist</td></tr>
<tr><td>4</td><td>Verification Failed</td><td>Document or signature verification failed</td></tr>
<tr><td>5</td><td>Signature Invalid</td><td>Cryptographic signature is invalid</td></tr>
</tbody></table>
</div>
<h2 id="configuration-errors"><a class="header" href="#configuration-errors">Configuration Errors</a></h2>
<h3 id="missing-configuration"><a class="header" href="#missing-configuration">Missing Configuration</a></h3>
<p><strong>Error:</strong> <code>Configuration file not found: jacs.config.json</code></p>
<p><strong>Cause:</strong> JACS cannot find the configuration file.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Initialize JACS to create configuration
jacs init

# Or specify a custom config path
JACS_CONFIG_PATH=./custom.config.json jacs agent verify
</code></pre>
<h3 id="invalid-configuration"><a class="header" href="#invalid-configuration">Invalid Configuration</a></h3>
<p><strong>Error:</strong> <code>Invalid configuration: missing required field 'jacs_key_directory'</code></p>
<p><strong>Cause:</strong> Configuration file is missing required fields.</p>
<p><strong>Solution:</strong> Ensure your <code>jacs.config.json</code> contains all required fields:</p>
<pre><code class="language-json">{
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_key_algorithm": "ring-Ed25519",
  "jacs_default_storage": "fs"
}
</code></pre>
<h3 id="key-directory-not-found"><a class="header" href="#key-directory-not-found">Key Directory Not Found</a></h3>
<p><strong>Error:</strong> <code>Key directory not found: ./jacs_keys</code></p>
<p><strong>Cause:</strong> The specified key directory does not exist.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Create the directory
mkdir -p ./jacs_keys

# Or run init to create everything
jacs init
</code></pre>
<h2 id="cryptographic-errors"><a class="header" href="#cryptographic-errors">Cryptographic Errors</a></h2>
<h3 id="private-key-not-found"><a class="header" href="#private-key-not-found">Private Key Not Found</a></h3>
<p><strong>Error:</strong> <code>Private key file not found: private.pem</code></p>
<p><strong>Cause:</strong> The private key file is missing from the key directory.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Generate new keys
jacs agent create --create-keys true
</code></pre>
<h3 id="invalid-key-format"><a class="header" href="#invalid-key-format">Invalid Key Format</a></h3>
<p><strong>Error:</strong> <code>Failed to parse private key: invalid PEM format</code></p>
<p><strong>Cause:</strong> The key file is corrupted or in wrong format.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Regenerate keys with <code>jacs agent create --create-keys true</code></li>
<li>Ensure the key file is not corrupted</li>
</ul>
<h3 id="key-password-required"><a class="header" href="#key-password-required">Key Password Required</a></h3>
<p><strong>Error:</strong> <code>Private key is encrypted but no password provided</code></p>
<p><strong>Cause:</strong> Encrypted private key requires password.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash">export JACS_PRIVATE_KEY_PASSWORD="your-password"
jacs document create -f doc.json
</code></pre>
<h3 id="algorithm-mismatch"><a class="header" href="#algorithm-mismatch">Algorithm Mismatch</a></h3>
<p><strong>Error:</strong> <code>Key algorithm 'ring-Ed25519' does not match configured algorithm 'RSA-PSS'</code></p>
<p><strong>Cause:</strong> The key file was created with a different algorithm than configured.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Update config to match key algorithm, or</li>
<li>Regenerate keys with the correct algorithm</li>
</ul>
<h2 id="signature-errors"><a class="header" href="#signature-errors">Signature Errors</a></h2>
<h3 id="verification-failed"><a class="header" href="#verification-failed">Verification Failed</a></h3>
<p><strong>Error:</strong> <code>Document verification failed: signature does not match content</code></p>
<p><strong>Cause:</strong> Document content has been modified after signing.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>The document may have been tampered with</li>
<li>Re-sign the document if you have the original content</li>
</ul>
<h3 id="missing-signature"><a class="header" href="#missing-signature">Missing Signature</a></h3>
<p><strong>Error:</strong> <code>Document missing jacsSignature field</code></p>
<p><strong>Cause:</strong> Document was not signed or signature was removed.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Create a signed document
jacs document create -f unsigned-doc.json
</code></pre>
<h3 id="invalid-signature-format"><a class="header" href="#invalid-signature-format">Invalid Signature Format</a></h3>
<p><strong>Error:</strong> <code>Invalid signature format: expected base64 encoded string</code></p>
<p><strong>Cause:</strong> The signature field is malformed.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Re-sign the document</li>
<li>Verify the document hasn't been corrupted</li>
</ul>
<h3 id="unknown-signing-algorithm"><a class="header" href="#unknown-signing-algorithm">Unknown Signing Algorithm</a></h3>
<p><strong>Error:</strong> <code>Unknown signing algorithm: unknown-algo</code></p>
<p><strong>Cause:</strong> Document was signed with an unsupported algorithm.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Use a supported algorithm: <code>ring-Ed25519</code>, <code>RSA-PSS</code>, <code>pq-dilithium</code>, <code>pq2025</code></li>
</ul>
<h2 id="dns-verification-errors"><a class="header" href="#dns-verification-errors">DNS Verification Errors</a></h2>
<h3 id="dnssec-validation-failed-1"><a class="header" href="#dnssec-validation-failed-1">DNSSEC Validation Failed</a></h3>
<p><strong>Error:</strong> <code>strict DNSSEC validation failed for &lt;owner&gt; (TXT not authenticated). Enable DNSSEC and publish DS at registrar</code></p>
<p><strong>Cause:</strong> DNSSEC mode was requested but the TXT response wasn't authenticated.</p>
<p><strong>Solution:</strong></p>
<ol>
<li>Enable DNSSEC for your domain zone</li>
<li>Publish the DS record at your registrar</li>
<li>Wait for propagation (up to 48 hours)</li>
</ol>
<h3 id="dns-record-not-found-1"><a class="header" href="#dns-record-not-found-1">DNS Record Not Found</a></h3>
<p><strong>Error:</strong> <code>DNS TXT lookup failed for &lt;owner&gt; (record missing or not yet propagated)</code></p>
<p><strong>Cause:</strong> The JACS TXT record doesn't exist or hasn't propagated.</p>
<p><strong>Solution:</strong></p>
<ol>
<li>Verify the TXT record was created:
<pre><code class="language-bash">dig _v1.agent.jacs.yourdomain.com TXT
</code></pre>
</li>
<li>Wait for DNS propagation (can take up to 48 hours)</li>
<li>Confirm record name and value are correct</li>
</ol>
<h3 id="dns-required"><a class="header" href="#dns-required">DNS Required</a></h3>
<p><strong>Error:</strong> <code>DNS TXT lookup required (domain configured) or provide embedded fingerprint</code></p>
<p><strong>Cause:</strong> Strict DNS mode is active because a domain is configured.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Publish the TXT record, or</li>
<li>Run with <code>--no-dns</code> during initial setup:
<pre><code class="language-bash">jacs agent verify --no-dns
</code></pre>
</li>
</ul>
<h3 id="dns-lookup-timeout"><a class="header" href="#dns-lookup-timeout">DNS Lookup Timeout</a></h3>
<p><strong>Error:</strong> <code>DNS lookup timed out for &lt;domain&gt;</code></p>
<p><strong>Cause:</strong> DNS server did not respond in time.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check network connectivity</li>
<li>Try again later</li>
<li>Verify DNS server is accessible</li>
</ul>
<h2 id="document-errors"><a class="header" href="#document-errors">Document Errors</a></h2>
<h3 id="invalid-json"><a class="header" href="#invalid-json">Invalid JSON</a></h3>
<p><strong>Error:</strong> <code>Failed to parse document: invalid JSON at line 5</code></p>
<p><strong>Cause:</strong> Document file contains invalid JSON.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Validate JSON with a linter</li>
<li>Check for syntax errors (missing commas, quotes)</li>
</ul>
<h3 id="schema-validation-failed"><a class="header" href="#schema-validation-failed">Schema Validation Failed</a></h3>
<p><strong>Error:</strong> <code>Schema validation failed: missing required field 'amount'</code></p>
<p><strong>Cause:</strong> Document doesn't conform to the specified schema.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Check which fields are required by the schema
cat schema.json | jq '.required'

# Add missing fields to your document
</code></pre>
<h3 id="document-not-found"><a class="header" href="#document-not-found">Document Not Found</a></h3>
<p><strong>Error:</strong> <code>Document not found: 550e8400-e29b-41d4-a716-446655440000</code></p>
<p><strong>Cause:</strong> The specified document ID doesn't exist in storage.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify the document ID is correct</li>
<li>Check the storage directory</li>
</ul>
<h3 id="version-mismatch"><a class="header" href="#version-mismatch">Version Mismatch</a></h3>
<p><strong>Error:</strong> <code>Document version mismatch: expected v2, got v1</code></p>
<p><strong>Cause:</strong> Attempting to update with incorrect base version.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Get the latest version of the document</li>
<li>Apply updates to the correct version</li>
</ul>
<h2 id="agreement-errors"><a class="header" href="#agreement-errors">Agreement Errors</a></h2>
<h3 id="agreement-not-found"><a class="header" href="#agreement-not-found">Agreement Not Found</a></h3>
<p><strong>Error:</strong> <code>Document has no jacsAgreement field</code></p>
<p><strong>Cause:</strong> Attempting agreement operations on a document without an agreement.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Create an agreement first
jacs document create-agreement -f doc.json -i agent1-id,agent2-id
</code></pre>
<h3 id="already-signed"><a class="header" href="#already-signed">Already Signed</a></h3>
<p><strong>Error:</strong> <code>Agent has already signed this agreement</code></p>
<p><strong>Cause:</strong> Attempting to sign an agreement that was already signed by this agent.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>No action needed, the signature is already present</li>
</ul>
<h3 id="not-authorized"><a class="header" href="#not-authorized">Not Authorized</a></h3>
<p><strong>Error:</strong> <code>Agent is not in the agreement's agentIDs list</code></p>
<p><strong>Cause:</strong> Attempting to sign with an agent not listed in the agreement.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Only agents listed in <code>jacsAgreement.agentIDs</code> can sign</li>
</ul>
<h3 id="agreement-locked"><a class="header" href="#agreement-locked">Agreement Locked</a></h3>
<p><strong>Error:</strong> <code>Cannot modify document: agreement is complete</code></p>
<p><strong>Cause:</strong> Attempting to modify a document with a completed agreement.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Create a new version/agreement if changes are needed</li>
</ul>
<h2 id="storage-errors"><a class="header" href="#storage-errors">Storage Errors</a></h2>
<h3 id="storage-backend-error"><a class="header" href="#storage-backend-error">Storage Backend Error</a></h3>
<p><strong>Error:</strong> <code>Storage error: failed to write to filesystem</code></p>
<p><strong>Cause:</strong> Unable to write to the configured storage backend.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check filesystem permissions</li>
<li>Verify storage directory exists</li>
<li>Check disk space</li>
</ul>
<h3 id="aws-s3-error"><a class="header" href="#aws-s3-error">AWS S3 Error</a></h3>
<p><strong>Error:</strong> <code>S3 error: AccessDenied</code></p>
<p><strong>Cause:</strong> AWS credentials don't have required permissions.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify IAM permissions include s3:GetObject, s3:PutObject</li>
<li>Check bucket policy</li>
<li>Verify credentials are correct</li>
</ul>
<h3 id="connection-error"><a class="header" href="#connection-error">Connection Error</a></h3>
<p><strong>Error:</strong> <code>Failed to connect to storage: connection refused</code></p>
<p><strong>Cause:</strong> Cannot connect to remote storage backend.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check network connectivity</li>
<li>Verify endpoint URL is correct</li>
<li>Check firewall rules</li>
</ul>
<h2 id="httpmcp-errors"><a class="header" href="#httpmcp-errors">HTTP/MCP Errors</a></h2>
<h3 id="request-verification-failed"><a class="header" href="#request-verification-failed">Request Verification Failed</a></h3>
<p><strong>Error:</strong> <code>JACS request verification failed</code></p>
<p><strong>Cause:</strong> Incoming HTTP request has invalid JACS signature.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure client is signing requests correctly</li>
<li>Verify client and server are using compatible keys</li>
</ul>
<h3 id="response-verification-failed"><a class="header" href="#response-verification-failed">Response Verification Failed</a></h3>
<p><strong>Error:</strong> <code>JACS response verification failed</code></p>
<p><strong>Cause:</strong> Server response has invalid signature.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check server JACS configuration</li>
<li>Verify server is signing responses</li>
</ul>
<h3 id="middleware-configuration-error"><a class="header" href="#middleware-configuration-error">Middleware Configuration Error</a></h3>
<p><strong>Error:</strong> <code>JACSExpressMiddleware: config file not found</code></p>
<p><strong>Cause:</strong> Middleware cannot find JACS configuration.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-javascript">app.use('/api', JACSExpressMiddleware({
  configPath: './jacs.config.json'  // Verify path is correct
}));
</code></pre>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<h3 id="enable-verbose-output"><a class="header" href="#enable-verbose-output">Enable Verbose Output</a></h3>
<pre><code class="language-bash"># CLI verbose mode
jacs document verify -f doc.json -v

# Environment variable
export JACS_DEBUG=true
</code></pre>
<h3 id="check-configuration"><a class="header" href="#check-configuration">Check Configuration</a></h3>
<pre><code class="language-bash"># Display current configuration
jacs config read
</code></pre>
<h3 id="verify-agent-3"><a class="header" href="#verify-agent-3">Verify Agent</a></h3>
<pre><code class="language-bash"># Verify agent is properly configured
jacs agent verify -v
</code></pre>
<h3 id="test-signing"><a class="header" href="#test-signing">Test Signing</a></h3>
<pre><code class="language-bash"># Create a test document
echo '{"test": true}' &gt; test.json
jacs document create -f test.json -v
</code></pre>
<h2 id="see-also-26"><a class="header" href="#see-also-26">See Also</a></h2>
<ul>
<li><a href="reference/configuration.html">Configuration Reference</a> - Configuration options</li>
<li><a href="reference/cli-commands.html">CLI Command Reference</a> - CLI usage</li>
<li><a href="reference/../advanced/security.html">Security Model</a> - Security details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h1>
<p>This guide covers migrating between JACS versions and common migration scenarios.</p>
<h2 id="version-compatibility"><a class="header" href="#version-compatibility">Version Compatibility</a></h2>
<p>JACS maintains backward compatibility for document verification:</p>
<ul>
<li>Documents signed with older versions can be verified with newer versions</li>
<li>Older JACS versions cannot verify documents using newer cryptographic algorithms</li>
</ul>
<h2 id="migrating-from-051-to-052"><a class="header" href="#migrating-from-051-to-052">Migrating from 0.5.1 to 0.5.2</a></h2>
<h3 id="migration-notes"><a class="header" href="#migration-notes">Migration Notes</a></h3>
<p><strong>PBKDF2 Iteration Count</strong>: New key encryptions use 600,000 iterations (up from 100,000). Existing encrypted keys are decrypted automatically via fallback. To upgrade existing keys, re-encrypt them:</p>
<pre><code class="language-bash"># Re-generate keys to use the new iteration count
jacs keygen
</code></pre>
<h3 id="deprecated-environment-variables"><a class="header" href="#deprecated-environment-variables">Deprecated Environment Variables</a></h3>
<ul>
<li><code>JACS_USE_SECURITY</code> is now <code>JACS_ENABLE_FILESYSTEM_QUARANTINE</code>. The old name still works with a deprecation warning.</li>
</ul>
<h3 id="new-environment-variables"><a class="header" href="#new-environment-variables">New Environment Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>JACS_MAX_SIGNATURE_AGE_SECONDS</code></td><td><code>0</code> (no expiration)</td><td>Maximum age of valid signatures. Set to a positive value to enable (e.g., <code>7776000</code> for 90 days).</td></tr>
<tr><td><code>JACS_REQUIRE_EXPLICIT_ALGORITHM</code></td><td><code>false</code></td><td>When <code>true</code>, reject verification if <code>signingAlgorithm</code> is missing.</td></tr>
<tr><td><code>JACS_ENABLE_FILESYSTEM_QUARANTINE</code></td><td><code>false</code></td><td>Enable filesystem quarantine (replaces <code>JACS_USE_SECURITY</code>).</td></tr>
</tbody></table>
</div>
<h2 id="migrating-from-02x-to-03x"><a class="header" href="#migrating-from-02x-to-03x">Migrating from 0.2.x to 0.3.x</a></h2>
<h3 id="configuration-changes"><a class="header" href="#configuration-changes">Configuration Changes</a></h3>
<p><strong>New Configuration Fields:</strong></p>
<pre><code class="language-json">{
  "observability": {
    "logs": { "enabled": true, "level": "info" },
    "metrics": { "enabled": false },
    "tracing": { "enabled": false }
  }
}
</code></pre>
<p><strong>Deprecated Fields:</strong></p>
<ul>
<li><code>jacs_log_level</code> ‚Üí Use <code>observability.logs.level</code></li>
<li><code>jacs_log_file</code> ‚Üí Use <code>observability.logs.destination</code></li>
</ul>
<h3 id="migration-steps"><a class="header" href="#migration-steps">Migration Steps</a></h3>
<ol>
<li>
<p><strong>Update Configuration:</strong></p>
<pre><code class="language-bash"># Backup current config
cp jacs.config.json jacs.config.json.backup

# Update to new format
# Add observability section if needed
</code></pre>
</li>
<li>
<p><strong>Update Dependencies:</strong></p>
<pre><code class="language-bash"># Node.js
npm install @hai.ai/jacs@latest

# Python
pip install --upgrade jacs
</code></pre>
</li>
<li>
<p><strong>Verify Existing Documents:</strong></p>
<pre><code class="language-bash">jacs document verify -d ./jacs_data/documents/
</code></pre>
</li>
</ol>
<h2 id="migrating-storage-backends"><a class="header" href="#migrating-storage-backends">Migrating Storage Backends</a></h2>
<h3 id="filesystem-to-aws-s3"><a class="header" href="#filesystem-to-aws-s3">Filesystem to AWS S3</a></h3>
<ol>
<li>
<p><strong>Create S3 Bucket:</strong></p>
<pre><code class="language-bash">aws s3 mb s3://my-jacs-bucket
</code></pre>
</li>
<li>
<p><strong>Update Configuration:</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "aws",
  "jacs_data_directory": "s3://my-jacs-bucket/data"
}
</code></pre>
</li>
<li>
<p><strong>Set Environment Variables:</strong></p>
<pre><code class="language-bash">export AWS_ACCESS_KEY_ID="your-key"
export AWS_SECRET_ACCESS_KEY="your-secret"
export AWS_REGION="us-east-1"
</code></pre>
</li>
<li>
<p><strong>Migrate Documents:</strong></p>
<pre><code class="language-bash"># Upload existing documents
aws s3 sync ./jacs_data/ s3://my-jacs-bucket/data/
</code></pre>
</li>
<li>
<p><strong>Verify Migration:</strong></p>
<pre><code class="language-bash">jacs document verify -d s3://my-jacs-bucket/data/documents/
</code></pre>
</li>
</ol>
<h3 id="aws-s3-to-filesystem"><a class="header" href="#aws-s3-to-filesystem">AWS S3 to Filesystem</a></h3>
<ol>
<li>
<p><strong>Download Documents:</strong></p>
<pre><code class="language-bash">aws s3 sync s3://my-jacs-bucket/data/ ./jacs_data/
</code></pre>
</li>
<li>
<p><strong>Update Configuration:</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data"
}
</code></pre>
</li>
<li>
<p><strong>Verify Documents:</strong></p>
<pre><code class="language-bash">jacs document verify -d ./jacs_data/documents/
</code></pre>
</li>
</ol>
<h2 id="migrating-cryptographic-algorithms"><a class="header" href="#migrating-cryptographic-algorithms">Migrating Cryptographic Algorithms</a></h2>
<h3 id="ed25519-to-post-quantum"><a class="header" href="#ed25519-to-post-quantum">Ed25519 to Post-Quantum</a></h3>
<p>For increased security, you may want to migrate to post-quantum algorithms.</p>
<ol>
<li>
<p><strong>Create New Agent with New Algorithm:</strong></p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium"
}
</code></pre>
<pre><code class="language-bash">jacs agent create --create-keys true -f new-agent.json
</code></pre>
</li>
<li>
<p><strong>Update Configuration:</strong></p>
<pre><code class="language-json">{
  "jacs_agent_key_algorithm": "pq-dilithium",
  "jacs_agent_id_and_version": "new-agent-id:new-version"
}
</code></pre>
</li>
<li>
<p><strong>Re-sign Critical Documents (Optional):</strong></p>
<pre><code class="language-javascript">// Re-sign documents with new algorithm
const oldDoc = JSON.parse(fs.readFileSync('./old-doc.json'));

// Remove old signature fields
delete oldDoc.jacsSignature;
delete oldDoc.jacsSha256;

// Create new signed version
const newDoc = await agent.createDocument(JSON.stringify(oldDoc));
</code></pre>
</li>
</ol>
<p><strong>Note:</strong> Old documents remain valid with old signatures. Re-signing is only needed for documents that require the new algorithm.</p>
<h2 id="migrating-between-platforms"><a class="header" href="#migrating-between-platforms">Migrating Between Platforms</a></h2>
<h3 id="nodejs-to-python"><a class="header" href="#nodejs-to-python">Node.js to Python</a></h3>
<p>Both platforms use the same document format:</p>
<pre><code class="language-javascript">// Node.js - create document
const signedDoc = await agent.createDocument(JSON.stringify(content));
fs.writeFileSync('doc.json', signedDoc);
</code></pre>
<pre><code class="language-python"># Python - verify the same document
with open('doc.json', 'r') as f:
    doc_string = f.read()

is_valid = agent.verify_document(doc_string)
</code></pre>
<h3 id="sharing-agents-between-platforms"><a class="header" href="#sharing-agents-between-platforms">Sharing Agents Between Platforms</a></h3>
<p>Agents can be used across platforms by sharing configuration:</p>
<ol>
<li>
<p><strong>Export Agent Files:</strong></p>
<pre><code>jacs_keys/
‚îú‚îÄ‚îÄ private.pem
‚îî‚îÄ‚îÄ public.pem
jacs.config.json
</code></pre>
</li>
<li>
<p><strong>Use Same Config in Both:</strong></p>
<pre><code class="language-javascript">// Node.js
await agent.load('./jacs.config.json');
</code></pre>
<pre><code class="language-python"># Python
agent.load('./jacs.config.json')
</code></pre>
</li>
</ol>
<h2 id="migrating-key-formats"><a class="header" href="#migrating-key-formats">Migrating Key Formats</a></h2>
<h3 id="unencrypted-to-encrypted-keys"><a class="header" href="#unencrypted-to-encrypted-keys">Unencrypted to Encrypted Keys</a></h3>
<ol>
<li>
<p><strong>Encrypt Existing Key:</strong></p>
<pre><code class="language-bash"># Backup original
cp jacs_keys/private.pem jacs_keys/private.pem.backup

# Encrypt with password
openssl pkcs8 -topk8 -in jacs_keys/private.pem \
  -out jacs_keys/private.pem.enc -v2 aes-256-cbc

# Remove unencrypted key
rm jacs_keys/private.pem
mv jacs_keys/private.pem.enc jacs_keys/private.pem
</code></pre>
</li>
<li>
<p><strong>Update Configuration:</strong></p>
<pre><code class="language-json">{
  "jacs_agent_private_key_filename": "private.pem"
}
</code></pre>
</li>
<li>
<p><strong>Set Password:</strong></p>
<pre><code class="language-bash">export JACS_PRIVATE_KEY_PASSWORD="your-secure-password"
</code></pre>
</li>
</ol>
<h2 id="database-migration"><a class="header" href="#database-migration">Database Migration</a></h2>
<h3 id="adding-database-storage"><a class="header" href="#adding-database-storage">Adding Database Storage</a></h3>
<p>If migrating from filesystem to include database storage:</p>
<ol>
<li>
<p><strong>Create Database Schema:</strong></p>
<pre><code class="language-sql">CREATE TABLE jacs_documents (
  id UUID PRIMARY KEY,
  version_id UUID NOT NULL,
  document JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(id, version_id)
);
</code></pre>
</li>
<li>
<p><strong>Import Existing Documents:</strong></p>
<pre><code class="language-javascript">const fs = require('fs');
const path = require('path');
const { Pool } = require('pg');

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const docsDir = './jacs_data/documents';

async function importDocuments() {
  const docDirs = fs.readdirSync(docsDir);

  for (const docId of docDirs) {
    const docPath = path.join(docsDir, docId);
    const versions = fs.readdirSync(docPath);

    for (const versionFile of versions) {
      const docString = fs.readFileSync(
        path.join(docPath, versionFile),
        'utf-8'
      );
      const doc = JSON.parse(docString);

      await pool.query(`
        INSERT INTO jacs_documents (id, version_id, document)
        VALUES ($1, $2, $3)
        ON CONFLICT (id, version_id) DO NOTHING
      `, [doc.jacsId, doc.jacsVersion, doc]);
    }
  }
}

importDocuments();
</code></pre>
</li>
</ol>
<h2 id="mcp-integration-migration"><a class="header" href="#mcp-integration-migration">MCP Integration Migration</a></h2>
<h3 id="adding-jacs-to-existing-mcp-server"><a class="header" href="#adding-jacs-to-existing-mcp-server">Adding JACS to Existing MCP Server</a></h3>
<ol>
<li>
<p><strong>Install JACS:</strong></p>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
</li>
<li>
<p><strong>Wrap Existing Transport:</strong></p>
<pre><code class="language-javascript">// Before
const transport = new StdioServerTransport();
await server.connect(transport);

// After
import { createJACSTransportProxy } from '@hai.ai/jacs/mcp';

const baseTransport = new StdioServerTransport();
const secureTransport = createJACSTransportProxy(
  baseTransport,
  './jacs.config.json',
  'server'
);
await server.connect(secureTransport);
</code></pre>
</li>
<li>
<p><strong>Update Client:</strong></p>
<pre><code class="language-javascript">// Client also needs JACS
const baseTransport = new StdioClientTransport({ command: 'node', args: ['server.js'] });
const secureTransport = createJACSTransportProxy(
  baseTransport,
  './jacs.client.config.json',
  'client'
);
await client.connect(secureTransport);
</code></pre>
</li>
</ol>
<h2 id="http-api-migration"><a class="header" href="#http-api-migration">HTTP API Migration</a></h2>
<h3 id="adding-jacs-to-existing-express-api"><a class="header" href="#adding-jacs-to-existing-express-api">Adding JACS to Existing Express API</a></h3>
<ol>
<li>
<p><strong>Install Middleware:</strong></p>
<pre><code class="language-bash">npm install @hai.ai/jacs
</code></pre>
</li>
<li>
<p><strong>Add Middleware to Routes:</strong></p>
<pre><code class="language-javascript">import { JACSExpressMiddleware } from '@hai.ai/jacs/http';

// Before
app.use('/api', express.json());

// After - for JACS-protected routes
app.use('/api/secure', express.text({ type: '*/*' }));
app.use('/api/secure', JACSExpressMiddleware({
  configPath: './jacs.config.json'
}));

// Keep non-JACS routes unchanged
app.use('/api/public', express.json());
</code></pre>
</li>
<li>
<p><strong>Update Route Handlers:</strong></p>
<pre><code class="language-javascript">// Before
app.post('/api/data', (req, res) =&gt; {
  const payload = req.body;
  // ...
});

// After
app.post('/api/secure/data', (req, res) =&gt; {
  const payload = req.jacsPayload;  // Verified payload
  // ...
});
</code></pre>
</li>
</ol>
<h2 id="troubleshooting-migration"><a class="header" href="#troubleshooting-migration">Troubleshooting Migration</a></h2>
<h3 id="common-issues-5"><a class="header" href="#common-issues-5">Common Issues</a></h3>
<p><strong>Documents Not Verifying After Migration:</strong></p>
<ul>
<li>Check algorithm compatibility</li>
<li>Verify keys were copied correctly</li>
<li>Ensure configuration paths are correct</li>
</ul>
<p><strong>Key File Errors:</strong></p>
<ul>
<li>Verify file permissions (600 for private key)</li>
<li>Check key format matches algorithm</li>
<li>Ensure password is set for encrypted keys</li>
</ul>
<p><strong>Storage Errors After Migration:</strong></p>
<ul>
<li>Verify storage backend is accessible</li>
<li>Check credentials/permissions</li>
<li>Ensure directory structure is correct</li>
</ul>
<h3 id="verification-checklist"><a class="header" href="#verification-checklist">Verification Checklist</a></h3>
<p>After any migration:</p>
<ol>
<li>
<p><strong>Verify Configuration:</strong></p>
<pre><code class="language-bash">jacs config read
</code></pre>
</li>
<li>
<p><strong>Verify Agent:</strong></p>
<pre><code class="language-bash">jacs agent verify
</code></pre>
</li>
<li>
<p><strong>Verify Sample Document:</strong></p>
<pre><code class="language-bash">jacs document verify -f ./sample-doc.json
</code></pre>
</li>
<li>
<p><strong>Test Document Creation:</strong></p>
<pre><code class="language-bash">echo '{"test": true}' &gt; test.json
jacs document create -f test.json
</code></pre>
</li>
<li>
<p><strong>Verify Version:</strong></p>
<pre><code class="language-bash">jacs version
</code></pre>
</li>
</ol>
<h2 id="rollback-procedures"><a class="header" href="#rollback-procedures">Rollback Procedures</a></h2>
<p>If migration fails:</p>
<ol>
<li>
<p><strong>Restore Configuration:</strong></p>
<pre><code class="language-bash">cp jacs.config.json.backup jacs.config.json
</code></pre>
</li>
<li>
<p><strong>Restore Keys:</strong></p>
<pre><code class="language-bash">cp -r jacs_keys.backup/* jacs_keys/
</code></pre>
</li>
<li>
<p><strong>Restore Dependencies:</strong></p>
<pre><code class="language-bash"># Node.js
npm install @hai.ai/jacs@previous-version

# Python
pip install jacs==previous-version
</code></pre>
</li>
<li>
<p><strong>Verify Rollback:</strong></p>
<pre><code class="language-bash">jacs agent verify
jacs document verify -d ./jacs_data/documents/
</code></pre>
</li>
</ol>
<h2 id="see-also-27"><a class="header" href="#see-also-27">See Also</a></h2>
<ul>
<li><a href="reference/configuration.html">Configuration Reference</a> - Configuration options</li>
<li><a href="reference/../advanced/crypto.html">Cryptographic Algorithms</a> - Algorithm details</li>
<li><a href="reference/../advanced/storage.html">Storage Backends</a> - Storage options</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
