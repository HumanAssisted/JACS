<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JACS Usage Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="getting-started/what-is-jacs.html"><strong aria-hidden="true">1.</strong> What is JACS?</a></li><li class="chapter-item expanded "><a href="getting-started/concepts.html"><strong aria-hidden="true">2.</strong> Core Concepts</a></li><li class="chapter-item expanded "><a href="getting-started/quick-start.html"><strong aria-hidden="true">3.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="rust/installation.html"><strong aria-hidden="true">4.</strong> Installation</a></li><li class="chapter-item expanded "><a href="rust/cli.html"><strong aria-hidden="true">5.</strong> CLI Usage</a></li><li class="chapter-item expanded "><a href="rust/agent.html"><strong aria-hidden="true">6.</strong> Creating an Agent</a></li><li class="chapter-item expanded "><a href="rust/documents.html"><strong aria-hidden="true">7.</strong> Working with Documents</a></li><li class="chapter-item expanded "><a href="rust/agreements.html"><strong aria-hidden="true">8.</strong> Creating and Using Agreements</a></li><li class="chapter-item expanded "><a href="rust/library.html"><strong aria-hidden="true">9.</strong> Rust Library API</a></li><li class="chapter-item expanded "><a href="rust/observability.html"><strong aria-hidden="true">10.</strong> Observability</a></li><li class="chapter-item expanded "><a href="nodejs/installation.html"><strong aria-hidden="true">11.</strong> Installation</a></li><li class="chapter-item expanded "><a href="nodejs/basic-usage.html"><strong aria-hidden="true">12.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="nodejs/mcp.html"><strong aria-hidden="true">13.</strong> MCP Integration</a></li><li class="chapter-item expanded "><a href="nodejs/http.html"><strong aria-hidden="true">14.</strong> HTTP Server</a></li><li class="chapter-item expanded "><a href="nodejs/express.html"><strong aria-hidden="true">15.</strong> Express Middleware</a></li><li class="chapter-item expanded "><a href="nodejs/api.html"><strong aria-hidden="true">16.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="python/installation.html"><strong aria-hidden="true">17.</strong> Installation</a></li><li class="chapter-item expanded "><a href="python/basic-usage.html"><strong aria-hidden="true">18.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="python/mcp.html"><strong aria-hidden="true">19.</strong> MCP Integration</a></li><li class="chapter-item expanded "><a href="python/api.html"><strong aria-hidden="true">20.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="schemas/overview.html"><strong aria-hidden="true">21.</strong> JSON Schemas</a></li><li class="chapter-item expanded "><a href="schemas/agent.html"><strong aria-hidden="true">22.</strong> Agent Schema</a></li><li class="chapter-item expanded "><a href="schemas/document.html"><strong aria-hidden="true">23.</strong> Document Schema</a></li><li class="chapter-item expanded "><a href="schemas/task.html"><strong aria-hidden="true">24.</strong> Task Schema</a></li><li class="chapter-item expanded "><a href="schemas/configuration.html"><strong aria-hidden="true">25.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="advanced/security.html"><strong aria-hidden="true">26.</strong> Security Model</a></li><li class="chapter-item expanded "><a href="advanced/crypto.html"><strong aria-hidden="true">27.</strong> Cryptographic Algorithms</a></li><li class="chapter-item expanded "><a href="advanced/storage.html"><strong aria-hidden="true">28.</strong> Storage Backends</a></li><li class="chapter-item expanded "><a href="advanced/custom-schemas.html"><strong aria-hidden="true">29.</strong> Custom Schemas</a></li><li class="chapter-item expanded "><a href="advanced/testing.html"><strong aria-hidden="true">30.</strong> Testing</a></li><li class="chapter-item expanded "><a href="integrations/mcp.html"><strong aria-hidden="true">31.</strong> Model Context Protocol (MCP)</a></li><li class="chapter-item expanded "><a href="integrations/web-servers.html"><strong aria-hidden="true">32.</strong> Web Servers</a></li><li class="chapter-item expanded "><a href="integrations/databases.html"><strong aria-hidden="true">33.</strong> Databases</a></li><li class="chapter-item expanded "><a href="examples/cli.html"><strong aria-hidden="true">34.</strong> CLI Examples</a></li><li class="chapter-item expanded "><a href="examples/nodejs.html"><strong aria-hidden="true">35.</strong> Node.js Examples</a></li><li class="chapter-item expanded "><a href="examples/python.html"><strong aria-hidden="true">36.</strong> Python Examples</a></li><li class="chapter-item expanded "><a href="examples/integrations.html"><strong aria-hidden="true">37.</strong> Integration Examples</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli-commands.html"><strong aria-hidden="true">38.</strong> CLI Command Reference</a></li><li class="chapter-item expanded "><a href="reference/configuration.html"><strong aria-hidden="true">39.</strong> Configuration Reference</a></li><li class="chapter-item expanded "><a href="reference/errors.html"><strong aria-hidden="true">40.</strong> Error Codes</a></li><li class="chapter-item expanded "><a href="reference/migration.html"><strong aria-hidden="true">41.</strong> Migration Guide</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JACS Usage Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jacs-json-agent-communication-standard"><a class="header" href="#jacs-json-agent-communication-standard">JACS: JSON Agent Communication Standard</a></h1>
<p>Welcome to the <strong>JSON Agent Communication Standard (JACS)</strong> documentation! JACS is a comprehensive framework for creating, signing, and verifying JSON documents with cryptographic integrity, designed specifically for AI agent communication and task management.</p>
<h2 id="what-is-jacs"><a class="header" href="#what-is-jacs">What is JACS?</a></h2>
<p>JACS provides a standard way for AI agents to:</p>
<ul>
<li><strong>Create and sign</strong> JSON documents with cryptographic signatures</li>
<li><strong>Verify authenticity</strong> and integrity of documents</li>
<li><strong>Manage tasks and agreements</strong> between multiple agents</li>
<li><strong>Maintain audit trails</strong> of modifications and versioning</li>
<li><strong>Ensure trust</strong> in multi-agent systems</li>
</ul>
<p>As a developer, JACS gives you the tools to build trustworthy AI systems where agents can securely exchange tasks, agreements, and data with verifiable integrity.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>üîê <strong>Cryptographic Security</strong>: RSA, Ed25519, and post-quantum cryptographic algorithms</li>
<li>üìã <strong>JSON Schema Validation</strong>: Enforced document structure and validation</li>
<li>ü§ù <strong>Multi-Agent Agreements</strong>: Built-in support for agent collaboration and task agreements</li>
<li>üîç <strong>Full Audit Trail</strong>: Complete versioning and modification history</li>
<li>üåê <strong>Multiple Language Support</strong>: Rust, Node.js, and Python implementations</li>
<li>üîå <strong>MCP Integration</strong>: Native Model Context Protocol support</li>
<li>üìä <strong>Observability</strong>: Built-in logging and metrics for production systems</li>
</ul>
<h2 id="available-implementations"><a class="header" href="#available-implementations">Available Implementations</a></h2>
<p>JACS is available in three languages, each with its own strengths:</p>
<h3 id="-rust-core-library--cli"><a class="header" href="#-rust-core-library--cli">ü¶Ä Rust (Core Library + CLI)</a></h3>
<ul>
<li><strong>Performance</strong>: Fastest implementation with native performance</li>
<li><strong>CLI Tool</strong>: Complete command-line interface for agent and document management</li>
<li><strong>Library</strong>: Full-featured Rust library for embedded applications</li>
<li><strong>Observability</strong>: Advanced logging and metrics with OpenTelemetry support</li>
</ul>
<h3 id="-nodejs-jacsnpm"><a class="header" href="#-nodejs-jacsnpm">üü¢ Node.js (jacsnpm)</a></h3>
<ul>
<li><strong>Web Integration</strong>: Perfect for web servers and Express.js applications</li>
<li><strong>MCP Support</strong>: Native Model Context Protocol integration</li>
<li><strong>HTTP Server</strong>: Built-in HTTP server capabilities</li>
<li><strong>NPM Package</strong>: Easy installation and integration</li>
</ul>
<h3 id="-python-jacspy"><a class="header" href="#-python-jacspy">üêç Python (jacspy)</a></h3>
<ul>
<li><strong>AI/ML Integration</strong>: Ideal for AI and machine learning workflows</li>
<li><strong>FastMCP</strong>: Advanced MCP server implementations</li>
<li><strong>PyPI Package</strong>: Simple <code>pip install</code> integration</li>
<li><strong>Data Science</strong>: Perfect for Jupyter notebooks and data pipelines</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Choose your implementation and get started in minutes:</p>
<h3 id="rust-cli"><a class="header" href="#rust-cli">Rust CLI</a></h3>
<pre><code class="language-bash">cargo install jacs
jacs init  # Create config and agent
jacs agent create --type "MyAgent"
</code></pre>
<h3 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h3>
<pre><code class="language-bash">npm install jacsnpm
</code></pre>
<pre><code class="language-javascript">import { JacsAgent } from 'jacsnpm';
const agent = new JacsAgent('./config.json');
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<pre><code class="language-python">import jacs
agent = jacs.Agent("./config.json")
</code></pre>
<h2 id="when-to-use-jacs"><a class="header" href="#when-to-use-jacs">When to Use JACS</a></h2>
<p>JACS is ideal for scenarios where you need:</p>
<ul>
<li><strong>Multi-agent systems</strong> where agents need to trust each other</li>
<li><strong>Task delegation</strong> with verifiable completion and approval</li>
<li><strong>Audit trails</strong> for AI decision-making processes</li>
<li><strong>Secure data exchange</strong> between AI systems</li>
<li><strong>Compliance</strong> requirements for AI system interactions</li>
<li><strong>Version control</strong> for AI-generated content and decisions</li>
</ul>
<h2 id="why-jacs"><a class="header" href="#why-jacs">Why JACS?</a></h2>
<h3 id="-agent-focused-design"><a class="header" href="#-agent-focused-design">üéØ <strong>Agent-Focused Design</strong></a></h3>
<p>Unlike general-purpose signing frameworks, JACS is specifically designed for AI agent communication patterns - tasks, agreements, and collaborative workflows.</p>
<h3 id="-production-ready"><a class="header" href="#-production-ready">üöÄ <strong>Production Ready</strong></a></h3>
<p>With built-in observability, multiple storage backends, and comprehensive error handling, JACS is ready for production AI systems.</p>
<h3 id="-future-proof-security"><a class="header" href="#-future-proof-security">üîí <strong>Future-Proof Security</strong></a></h3>
<p>Support for both current (RSA, Ed25519) and post-quantum cryptographic algorithms ensures your system remains secure.</p>
<h3 id="-universal-compatibility"><a class="header" href="#-universal-compatibility">üåê <strong>Universal Compatibility</strong></a></h3>
<p>JSON-based documents work everywhere - store them in any database, transmit over any protocol, integrate with any system.</p>
<h3 id="-flexible-integration"><a class="header" href="#-flexible-integration">üß© <strong>Flexible Integration</strong></a></h3>
<p>Whether you're building a simple CLI tool or a complex multi-agent system, JACS adapts to your architecture.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li><strong><a href="getting-started/concepts.html">Core Concepts</a></strong> - Understand agents, documents, and agreements</li>
<li><strong><a href="getting-started/quick-start.html">Quick Start Guide</a></strong> - Get up and running in minutes</li>
<li><strong>Choose Your Implementation</strong>:
<ul>
<li><a href="rust/installation.html">Rust CLI &amp; Library</a></li>
<li><a href="nodejs/installation.html">Node.js Package</a></li>
<li><a href="python/installation.html">Python Package</a></li>
</ul>
</li>
</ol>
<h2 id="community-and-support"><a class="header" href="#community-and-support">Community and Support</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/HumanAssisted/JACS">HumanAssisted/JACS</a></li>
<li><strong>Issues</strong>: Report bugs and feature requests</li>
<li><strong>Examples</strong>: Complete examples for all implementations</li>
<li><strong>Documentation</strong>: This comprehensive guide</li>
</ul>
<hr />
<p><em>Ready to build trustworthy AI systems? Let's get started!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-jacs-1"><a class="header" href="#what-is-jacs-1">What is JACS?</a></h1>
<p><strong>JACS (JSON Agent Communication Standard)</strong> is a comprehensive framework designed to solve a critical problem in AI systems: <strong>How do agents communicate and collaborate securely with verifiable trust?</strong></p>
<h2 id="the-problem-jacs-solves"><a class="header" href="#the-problem-jacs-solves">The Problem JACS Solves</a></h2>
<p>As AI systems become more sophisticated, we're moving toward multi-agent architectures where different AI agents need to:</p>
<ul>
<li><strong>Exchange tasks</strong> and delegate work to each other</li>
<li><strong>Create agreements</strong> and verify their completion</li>
<li><strong>Share data</strong> with guaranteed authenticity</li>
<li><strong>Maintain audit trails</strong> of decisions and actions</li>
<li><strong>Establish trust</strong> without centralized authorities</li>
</ul>
<p>Traditional approaches fall short because they lack:</p>
<ul>
<li>Cryptographic integrity for agent communications</li>
<li>Standardized formats for agent interactions</li>
<li>Built-in versioning and audit trails</li>
<li>Support for multi-agent agreements and workflows</li>
</ul>
<h2 id="jacs-core-philosophy"><a class="header" href="#jacs-core-philosophy">JACS Core Philosophy</a></h2>
<h3 id="-agent-first-design"><a class="header" href="#-agent-first-design">üéØ <strong>Agent-First Design</strong></a></h3>
<p>JACS is built specifically for AI agent communication patterns, not as a general-purpose document signing system. It understands concepts like:</p>
<ul>
<li><strong>Agents</strong> with identities and capabilities</li>
<li><strong>Tasks</strong> that can be delegated and tracked</li>
<li><strong>Agreements</strong> between multiple parties</li>
<li><strong>Versioning</strong> for iterative improvements</li>
</ul>
<h3 id="-trust-through-cryptography"><a class="header" href="#-trust-through-cryptography">üîê <strong>Trust Through Cryptography</strong></a></h3>
<p>Every JACS document includes:</p>
<ul>
<li><strong>Digital signatures</strong> proving authenticity</li>
<li><strong>Hash verification</strong> ensuring integrity</li>
<li><strong>Public key cryptography</strong> for identity verification</li>
<li><strong>Timestamps</strong> for chronological ordering</li>
</ul>
<h3 id="-standards-based"><a class="header" href="#-standards-based">üìã <strong>Standards-Based</strong></a></h3>
<p>JACS builds on proven standards:</p>
<ul>
<li><strong>JSON</strong> for universal compatibility</li>
<li><strong>JSON Schema</strong> for structure validation</li>
<li><strong>RFC 3339</strong> timestamps for consistency</li>
<li><strong>Standard cryptographic algorithms</strong> (RSA, Ed25519, post-quantum)</li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="agents"><a class="header" href="#agents">Agents</a></h3>
<p>An <strong>Agent</strong> is an autonomous entity with:</p>
<ul>
<li>A unique identity (UUID)</li>
<li>Cryptographic keys for signing</li>
<li>Capabilities defined in services</li>
<li>The ability to create and verify documents</li>
</ul>
<h3 id="documents"><a class="header" href="#documents">Documents</a></h3>
<p>A <strong>Document</strong> is any JSON object that includes:</p>
<ul>
<li>JACS header fields (ID, version, creator, etc.)</li>
<li>A cryptographic signature</li>
<li>A hash for integrity verification</li>
<li>Business logic specific to the document type</li>
</ul>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p>A <strong>Task</strong> is a special document type representing:</p>
<ul>
<li>Work to be performed</li>
<li>Success/failure criteria</li>
<li>Input/output specifications</li>
<li>Delegation and completion tracking</li>
</ul>
<h3 id="agreements"><a class="header" href="#agreements">Agreements</a></h3>
<p>An <strong>Agreement</strong> is a mechanism for:</p>
<ul>
<li>Multiple agents to consent to terms</li>
<li>Tracking signatures from all required parties</li>
<li>Ensuring all participants have signed before proceeding</li>
<li>Creating binding commitments between agents</li>
</ul>
<h2 id="how-jacs-works"><a class="header" href="#how-jacs-works">How JACS Works</a></h2>
<pre><code class="language-mermaid">graph TD
    A[Agent A] --&gt;|Creates Task| T[JACS Task Document]
    T --&gt;|Contains| S[Digital Signature]
    T --&gt;|Contains| H[SHA256 Hash]
    T --&gt;|Contains| M[Metadata]
    
    A --&gt;|Sends to| B[Agent B]
    B --&gt;|Verifies| T
    B --&gt;|Signs Agreement| AG[Agreement Document]
    AG --&gt;|Returns to| A
</code></pre>
<ol>
<li><strong>Agent A</strong> creates a task document with their requirements</li>
<li>The document is <strong>signed</strong> with Agent A's private key</li>
<li>A <strong>hash</strong> is calculated for integrity verification</li>
<li><strong>Agent B</strong> receives and verifies the signature and hash</li>
<li>Agent B can <strong>create an agreement</strong> to accept the task</li>
<li>Both agents have a <strong>verifiable record</strong> of the interaction</li>
</ol>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="-ai-content-pipeline"><a class="header" href="#-ai-content-pipeline">ü§ñ <strong>AI Content Pipeline</strong></a></h3>
<pre><code>Content Agent ‚Üí Research Agent ‚Üí Review Agent ‚Üí Publishing Agent
</code></pre>
<p>Each handoff includes signed task documents with clear requirements and deliverables.</p>
<h3 id="-data-processing-workflow"><a class="header" href="#-data-processing-workflow">üìä <strong>Data Processing Workflow</strong></a></h3>
<pre><code>Data Ingestion Agent ‚Üí Processing Agent ‚Üí Validation Agent ‚Üí Storage Agent
</code></pre>
<p>Each step is tracked with verifiable completion certificates and quality metrics.</p>
<h3 id="-multi-agent-analysis"><a class="header" href="#-multi-agent-analysis">üîç <strong>Multi-Agent Analysis</strong></a></h3>
<pre><code>Query Agent ‚Üí Research Agent ‚Üí Analysis Agent ‚Üí Reporting Agent
</code></pre>
<p>Complex analysis tasks are broken down with clear accountability for each step.</p>
<h2 id="benefits-over-alternatives"><a class="header" href="#benefits-over-alternatives">Benefits Over Alternatives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>JACS</th><th>Traditional APIs</th><th>General Signing</th></tr></thead><tbody>
<tr><td><strong>Agent Identity</strong></td><td>‚úÖ Built-in</td><td>‚ùå Custom implementation</td><td>‚ùå Not agent-focused</td></tr>
<tr><td><strong>Task Management</strong></td><td>‚úÖ Native support</td><td>‚ùå Application-specific</td><td>‚ùå Not applicable</td></tr>
<tr><td><strong>Multi-Party Agreements</strong></td><td>‚úÖ Core feature</td><td>‚ùå Complex to implement</td><td>‚ö†Ô∏è Possible but difficult</td></tr>
<tr><td><strong>Audit Trails</strong></td><td>‚úÖ Automatic</td><td>‚ùå Manual logging</td><td>‚ö†Ô∏è Basic signing only</td></tr>
<tr><td><strong>Schema Validation</strong></td><td>‚úÖ JSON Schema</td><td>‚ùå Custom validation</td><td>‚ùå No structure</td></tr>
<tr><td><strong>Versioning</strong></td><td>‚úÖ Built-in</td><td>‚ùå Manual versioning</td><td>‚ùå Not supported</td></tr>
<tr><td><strong>Cross-Platform</strong></td><td>‚úÖ JSON everywhere</td><td>‚ö†Ô∏è Protocol dependent</td><td>‚ö†Ô∏è Format dependent</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use-jacs-1"><a class="header" href="#when-to-use-jacs-1">When to Use JACS</a></h2>
<p>‚úÖ <strong>Perfect for:</strong></p>
<ul>
<li>Multi-agent AI systems</li>
<li>Task delegation and tracking</li>
<li>Audit trail requirements</li>
<li>Cross-organization AI collaboration</li>
<li>Compliance-critical AI applications</li>
<li>Research environments with multiple AI models</li>
</ul>
<p>‚ö†Ô∏è <strong>Consider alternatives for:</strong></p>
<ul>
<li>Simple single-agent systems</li>
<li>Real-time streaming data</li>
<li>High-frequency micro-transactions</li>
<li>Systems where trust is not a concern</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Ready to dive deeper? Continue with:</p>
<ul>
<li><strong><a href="getting-started/concepts.html">Core Concepts</a></strong> - Learn about agents, documents, and agreements</li>
<li><strong><a href="getting-started/quick-start.html">Quick Start</a></strong> - Get hands-on experience</li>
<li><strong>Implementation guides</strong> for <a href="getting-started/../rust/installation.html">Rust</a>, <a href="getting-started/../nodejs/installation.html">Node.js</a>, or <a href="getting-started/../python/installation.html">Python</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Understanding JACS requires familiarity with several key concepts that work together to create a secure, verifiable communication framework for AI agents.</p>
<h2 id="agents-1"><a class="header" href="#agents-1">Agents</a></h2>
<p>An <strong>Agent</strong> is the fundamental entity in JACS - an autonomous participant that can create, sign, and verify documents.</p>
<h3 id="agent-identity"><a class="header" href="#agent-identity">Agent Identity</a></h3>
<pre><code class="language-json">{
  "jacsId": "550e8400-e29b-41d4-a716-446655440000",
  "jacsVersion": "123e4567-e89b-12d3-a456-426614174000",
  "jacsType": "agent",
  "name": "Content Creation Agent",
  "description": "Specialized in creating marketing content"
}
</code></pre>
<p><strong>Key Properties:</strong></p>
<ul>
<li><strong>jacsId</strong>: Permanent UUID identifying the agent</li>
<li><strong>jacsVersion</strong>: UUID that changes with each update</li>
<li><strong>Cryptographic Keys</strong>: Ed25519, RSA, or post-quantum key pairs</li>
<li><strong>Services</strong>: Capabilities the agent offers</li>
<li><strong>Contacts</strong>: How to reach the agent</li>
</ul>
<h3 id="agent-lifecycle"><a class="header" href="#agent-lifecycle">Agent Lifecycle</a></h3>
<ol>
<li><strong>Creation</strong>: Generate keys and initial agent document</li>
<li><strong>Registration</strong>: Store public keys for verification</li>
<li><strong>Operation</strong>: Create and sign documents</li>
<li><strong>Updates</strong>: Version changes while maintaining identity</li>
<li><strong>Verification</strong>: Other agents validate signatures</li>
</ol>
<h2 id="documents-1"><a class="header" href="#documents-1">Documents</a></h2>
<p>A <strong>Document</strong> is any JSON object that follows JACS conventions for identity, versioning, and cryptographic integrity.</p>
<h3 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h3>
<pre><code class="language-json">{
  "jacsId": "doc-uuid-here",
  "jacsVersion": "version-uuid-here",
  "jacsType": "task",
  "jacsVersionDate": "2024-01-15T10:30:00Z",
  "jacsPreviousVersion": "previous-version-uuid",
  
  "title": "Analyze Q4 Sales Data",
  "description": "Generate insights from sales data",
  
  "jacsSha256": "hash-of-document-content",
  "jacsSignature": {
    "agentID": "agent-uuid",
    "agentVersion": "agent-version-uuid", 
    "signature": "base64-signature",
    "signingAlgorithm": "Ed25519",
    "publicKeyHash": "hash-of-public-key",
    "date": "2024-01-15T10:30:00Z",
    "fields": ["jacsId", "title", "description"]
  }
}
</code></pre>
<h3 id="required-jacs-fields"><a class="header" href="#required-jacs-fields">Required JACS Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Purpose</th><th>Example</th></tr></thead><tbody>
<tr><td><code>jacsId</code></td><td>Permanent document identifier</td><td>UUID v4</td></tr>
<tr><td><code>jacsVersion</code></td><td>Version identifier (changes on update)</td><td>UUID v4</td></tr>
<tr><td><code>jacsType</code></td><td>Document type</td><td>"agent", "task", "message"</td></tr>
<tr><td><code>jacsVersionDate</code></td><td>When this version was created</td><td>RFC 3339 timestamp</td></tr>
<tr><td><code>jacsPreviousVersion</code></td><td>Previous version UUID</td><td>UUID v4 or null</td></tr>
<tr><td><code>jacsSha256</code></td><td>Hash of document content</td><td>SHA-256 hex string</td></tr>
<tr><td><code>jacsSignature</code></td><td>Cryptographic signature</td><td>Signature object</td></tr>
</tbody></table>
</div>
<h3 id="document-types"><a class="header" href="#document-types">Document Types</a></h3>
<p><strong>Agent Documents</strong></p>
<ul>
<li>Define agent identity and capabilities</li>
<li>Contain service definitions and contact information</li>
<li>Self-signed by the agent</li>
</ul>
<p><strong>Task Documents</strong></p>
<ul>
<li>Describe work to be performed</li>
<li>Include success/failure criteria</li>
<li>Can be delegated between agents</li>
</ul>
<p><strong>Message Documents</strong></p>
<ul>
<li>General communication between agents</li>
<li>Can include attachments and metadata</li>
<li>Support threaded conversations</li>
</ul>
<p><strong>Agreement Documents</strong></p>
<ul>
<li>Multi-party consent mechanisms</li>
<li>Track required and actual signatures</li>
<li>Enforce completion before proceeding</li>
</ul>
<h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<p>Tasks represent work that can be delegated, tracked, and verified between agents.</p>
<h3 id="task-structure"><a class="header" href="#task-structure">Task Structure</a></h3>
<pre><code class="language-json">{
  "jacsType": "task",
  "title": "Generate Marketing Copy",
  "description": "Create compelling copy for product launch",
  
  "actions": [
    {
      "id": "research",
      "name": "Research competitors",
      "description": "Analyze competitor messaging",
      "success": "Complete competitive analysis report",
      "failure": "Unable to access competitor data"
    }
  ],
  
  "jacsTaskCustomer": {
    "agentID": "customer-agent-uuid",
    "signature": "customer-signature"
  }
}
</code></pre>
<h3 id="task-lifecycle"><a class="header" href="#task-lifecycle">Task Lifecycle</a></h3>
<ol>
<li><strong>Creation</strong>: Customer agent creates task with requirements</li>
<li><strong>Delegation</strong>: Task sent to service provider agent</li>
<li><strong>Agreement</strong>: Provider signs agreement to accept task</li>
<li><strong>Execution</strong>: Provider performs the work</li>
<li><strong>Completion</strong>: Provider creates completion document</li>
<li><strong>Verification</strong>: Customer verifies and accepts results</li>
</ol>
<h3 id="task-components"><a class="header" href="#task-components">Task Components</a></h3>
<p><strong>Actions</strong>: Individual steps within a task</p>
<ul>
<li><strong>id</strong>: Unique identifier within the task</li>
<li><strong>name</strong>: Human-readable action name</li>
<li><strong>description</strong>: Detailed requirements</li>
<li><strong>success</strong>: Definition of successful completion</li>
<li><strong>failure</strong>: What constitutes failure</li>
</ul>
<p><strong>Services</strong>: Required capabilities</p>
<ul>
<li><strong>type</strong>: Service category</li>
<li><strong>requirements</strong>: Specific needs</li>
<li><strong>constraints</strong>: Limitations or restrictions</li>
</ul>
<h2 id="agreements-1"><a class="header" href="#agreements-1">Agreements</a></h2>
<p>Agreements enable multi-party consent and coordination between agents.</p>
<h3 id="agreement-structure"><a class="header" href="#agreement-structure">Agreement Structure</a></h3>
<pre><code class="language-json">{
  "jacsType": "agreement",
  "title": "Task Acceptance Agreement",
  "question": "Do you agree to complete the marketing copy task?",
  "context": "Task ID: abc123, Deadline: 2024-01-20",
  
  "agents": [
    "agent-1-uuid",
    "agent-2-uuid",
    "agent-3-uuid"
  ],
  
  "jacsAgreement": {
    "agent-1-uuid": {
      "agentID": "agent-1-uuid",
      "signature": "base64-signature",
      "date": "2024-01-15T10:30:00Z"
    },
    "agent-2-uuid": {
      "agentID": "agent-2-uuid", 
      "signature": "base64-signature",
      "date": "2024-01-15T11:15:00Z"
    }
    // agent-3-uuid has not signed yet
  },
  
  "jacsAgreementHash": "hash-of-agreement-content"
}
</code></pre>
<h3 id="agreement-process"><a class="header" href="#agreement-process">Agreement Process</a></h3>
<ol>
<li><strong>Creation</strong>: Initial agent creates agreement with required participants</li>
<li><strong>Distribution</strong>: Agreement sent to all required agents</li>
<li><strong>Review</strong>: Each agent reviews terms and conditions</li>
<li><strong>Signing</strong>: Agents add their signatures if they consent</li>
<li><strong>Completion</strong>: Agreement becomes binding when all parties have signed</li>
<li><strong>Verification</strong>: Any party can verify all signatures</li>
</ol>
<h3 id="agreement-types"><a class="header" href="#agreement-types">Agreement Types</a></h3>
<p><strong>Task Agreements</strong>: Consent to perform specific work
<strong>Service Agreements</strong>: Long-term service provision contracts<br />
<strong>Data Sharing Agreements</strong>: Permission to access or use data
<strong>Update Agreements</strong>: Consent to system or process changes</p>
<h2 id="cryptographic-security"><a class="header" href="#cryptographic-security">Cryptographic Security</a></h2>
<p>JACS uses industry-standard cryptographic primitives for security.</p>
<h3 id="supported-algorithms"><a class="header" href="#supported-algorithms">Supported Algorithms</a></h3>
<p><strong>Current Standards</strong></p>
<ul>
<li><strong>Ed25519</strong>: Fast elliptic curve signatures (recommended)</li>
<li><strong>RSA-PSS</strong>: Traditional RSA with probabilistic signature scheme</li>
</ul>
<p><strong>Post-Quantum</strong></p>
<ul>
<li><strong>Dilithium</strong>: NIST-standardized post-quantum signatures</li>
<li><strong>Falcon</strong>: Alternative post-quantum option</li>
</ul>
<h3 id="signature-process"><a class="header" href="#signature-process">Signature Process</a></h3>
<ol>
<li><strong>Content Extraction</strong>: Specific fields are extracted for signing</li>
<li><strong>Canonicalization</strong>: Fields are sorted and formatted consistently</li>
<li><strong>Hashing</strong>: SHA-256 hash of the canonical content</li>
<li><strong>Signing</strong>: Private key signs the hash</li>
<li><strong>Verification</strong>: Public key verifies the signature</li>
</ol>
<h3 id="key-management"><a class="header" href="#key-management">Key Management</a></h3>
<ul>
<li><strong>Agent Keys</strong>: Each agent has a unique key pair</li>
<li><strong>Public Key Distribution</strong>: Public keys shared through secure channels</li>
<li><strong>Key Rotation</strong>: Agents can update keys while maintaining identity</li>
<li><strong>Key Verification</strong>: Public key hashes ensure integrity</li>
</ul>
<h2 id="versioning-and-audit-trails"><a class="header" href="#versioning-and-audit-trails">Versioning and Audit Trails</a></h2>
<p>JACS provides comprehensive versioning for tracking document evolution.</p>
<h3 id="version-management"><a class="header" href="#version-management">Version Management</a></h3>
<ul>
<li><strong>Immutable IDs</strong>: <code>jacsId</code> never changes for a document</li>
<li><strong>Version IDs</strong>: <code>jacsVersion</code> changes with each update</li>
<li><strong>Previous Versions</strong>: <code>jacsPreviousVersion</code> creates a chain</li>
<li><strong>Timestamps</strong>: <code>jacsVersionDate</code> provides chronological order</li>
</ul>
<h3 id="audit-trail-benefits"><a class="header" href="#audit-trail-benefits">Audit Trail Benefits</a></h3>
<ul>
<li><strong>Complete History</strong>: Track all changes to any document</li>
<li><strong>Attribution</strong>: Know exactly who made each change</li>
<li><strong>Verification</strong>: Cryptographic proof of authenticity</li>
<li><strong>Compliance</strong>: Meet regulatory audit requirements</li>
</ul>
<h2 id="storage-and-transport"><a class="header" href="#storage-and-transport">Storage and Transport</a></h2>
<p>JACS documents are designed to be storage and transport agnostic.</p>
<h3 id="storage-options"><a class="header" href="#storage-options">Storage Options</a></h3>
<ul>
<li><strong>File System</strong>: Simple JSON files</li>
<li><strong>Databases</strong>: Store as JSON/JSONB fields</li>
<li><strong>Object Storage</strong>: S3, Azure Blob, Google Cloud Storage</li>
<li><strong>Version Control</strong>: Git repositories for change tracking</li>
</ul>
<h3 id="transport-mechanisms"><a class="header" href="#transport-mechanisms">Transport Mechanisms</a></h3>
<ul>
<li><strong>HTTP APIs</strong>: RESTful or GraphQL endpoints</li>
<li><strong>Message Queues</strong>: RabbitMQ, Kafka, SQS</li>
<li><strong>Email</strong>: Documents as attachments</li>
<li><strong>Direct Transfer</strong>: USB drives, file sharing</li>
</ul>
<h3 id="format-compatibility"><a class="header" href="#format-compatibility">Format Compatibility</a></h3>
<ul>
<li><strong>JSON</strong>: Universal compatibility across all systems</li>
<li><strong>Schema Validation</strong>: Ensures consistent structure</li>
<li><strong>Self-Contained</strong>: All necessary information in the document</li>
<li><strong>Human Readable</strong>: Can be inspected and debugged easily</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand the core concepts:</p>
<ol>
<li><strong><a href="getting-started/quick-start.html">Quick Start</a></strong> - Try JACS hands-on</li>
<li><strong>Choose Implementation</strong>:
<ul>
<li><a href="getting-started/../rust/installation.html">Rust CLI</a> for command-line usage</li>
<li><a href="getting-started/../nodejs/installation.html">Node.js</a> for web applications</li>
<li><a href="getting-started/../python/installation.html">Python</a> for AI/ML workflows</li>
</ul>
</li>
<li><strong><a href="getting-started/../examples/cli.html">Examples</a></strong> - See real-world usage patterns</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<p>This guide will get you up and running with JACS in under 10 minutes. We'll create an agent, generate a task, and demonstrate the core workflow across all three implementations.</p>
<h2 id="choose-your-implementation"><a class="header" href="#choose-your-implementation">Choose Your Implementation</a></h2>
<p>Select the implementation that best fits your needs:</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="tab-rust" name="tab-group" checked>
<label for="tab-rust">ü¶Ä Rust CLI</label>
<div class="content">
<h3 id="install-rust-cli"><a class="header" href="#install-rust-cli">Install Rust CLI</a></h3>
<pre><code class="language-bash"># Install from crates.io
cargo install jacs

# Or build from source
git clone https://github.com/HumanAssisted/JACS
cd JACS/jacs
cargo install --path . --features="cli"
</code></pre>
<h3 id="initialize-jacs"><a class="header" href="#initialize-jacs">Initialize JACS</a></h3>
<pre><code class="language-bash"># Create configuration and agent in one step
jacs init

# This creates:
# - ~/.jacs/config.json
# - Agent keys and documents
# - Basic directory structure
</code></pre>
<h3 id="create-your-first-agent"><a class="header" href="#create-your-first-agent">Create Your First Agent</a></h3>
<pre><code class="language-bash"># Create a specialized agent
jacs agent create --type "Content Creator" --name "ContentBot"

# View your agent
jacs agent show
</code></pre>
<h3 id="create-and-sign-a-task"><a class="header" href="#create-and-sign-a-task">Create and Sign a Task</a></h3>
<pre><code class="language-bash"># Create a task document
jacs task create \
  --title "Write Product Description" \
  --description "Create compelling copy for new product launch" \
  --success "Engaging 200-word description completed"

# The task is automatically signed by your agent
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="tab-nodejs" name="tab-group">
<label for="tab-nodejs">üü¢ Node.js</label>
<div class="content">
<h3 id="install-nodejs-package"><a class="header" href="#install-nodejs-package">Install Node.js Package</a></h3>
<pre><code class="language-bash">npm install jacsnpm
</code></pre>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h3>
<pre><code class="language-javascript">import { JacsAgent, JacsConfig } from 'jacsnpm';
import fs from 'fs';

// Create configuration
const config = {
  jacs_agent_id_and_version: null,
  jacs_data_directory: "./jacs_data",
  jacs_key_directory: "./jacs_keys",
  jacs_default_storage: "fs",
  jacs_agent_key_algorithm: "Ed25519"
};

// Save config
fs.writeFileSync('./jacs.config.json', JSON.stringify(config, null, 2));

// Create agent
const agent = new JacsAgent('./jacs.config.json');
</code></pre>
<h3 id="create-agent-document"><a class="header" href="#create-agent-document">Create Agent Document</a></h3>
<pre><code class="language-javascript">// Create agent with services
const agentData = {
  name: "Content Creator Bot",
  description: "AI agent specialized in content creation",
  services: [
    {
      type: "content_generation",
      name: "Product Description Writer",
      description: "Creates compelling product descriptions",
      success: "Engaging copy that converts visitors",
      failure: "Generic or low-quality content"
    }
  ]
};

// Generate keys and create agent
await agent.generateKeys();
const agentDoc = await agent.createAgent(agentData);
console.log('Agent created:', agentDoc.jacsId);
</code></pre>
<h3 id="create-a-task"><a class="header" href="#create-a-task">Create a Task</a></h3>
<pre><code class="language-javascript">// Create task document
const task = {
  title: "Write Product Description",
  description: "Create compelling copy for new product launch",
  actions: [
    {
      id: "research",
      name: "Product Research", 
      description: "Analyze product features and benefits",
      success: "Complete understanding of product value",
      failure: "Insufficient product knowledge"
    },
    {
      id: "write",
      name: "Write Copy",
      description: "Create engaging product description",
      success: "200-word compelling description",
      failure: "Generic or unconvincing copy"
    }
  ]
};

// Sign and create task
const signedTask = await agent.createTask(task);
console.log('Task created:', signedTask.jacsId);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="tab-python" name="tab-group">
<label for="tab-python">üêç Python</label>
<div class="content">
<h3 id="install-python-package"><a class="header" href="#install-python-package">Install Python Package</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<h3 id="basic-setup-1"><a class="header" href="#basic-setup-1">Basic Setup</a></h3>
<pre><code class="language-python">import jacs
import json
import os

# Create configuration
config = {
    "jacs_agent_id_and_version": None,
    "jacs_data_directory": "./jacs_data",
    "jacs_key_directory": "./jacs_keys", 
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519"
}

# Ensure directories exist
os.makedirs("./jacs_data", exist_ok=True)
os.makedirs("./jacs_keys", exist_ok=True)

# Save config
with open('jacs.config.json', 'w') as f:
    json.dump(config, f, indent=2)

# Create agent
agent = jacs.Agent("./jacs.config.json")
</code></pre>
<h3 id="create-agent-document-1"><a class="header" href="#create-agent-document-1">Create Agent Document</a></h3>
<pre><code class="language-python"># Define agent capabilities
agent_data = {
    "name": "Content Creator Bot",
    "description": "AI agent specialized in content creation",
    "services": [
        {
            "type": "content_generation",
            "name": "Product Description Writer", 
            "description": "Creates compelling product descriptions",
            "success": "Engaging copy that converts visitors",
            "failure": "Generic or low-quality content"
        }
    ]
}

# Generate keys and create agent
agent.generate_keys()
agent_doc = agent.create_agent(agent_data)
print(f'Agent created: {agent_doc["jacsId"]}')
</code></pre>
<h3 id="create-a-task-1"><a class="header" href="#create-a-task-1">Create a Task</a></h3>
<pre><code class="language-python"># Define task
task = {
    "title": "Write Product Description",
    "description": "Create compelling copy for new product launch",
    "actions": [
        {
            "id": "research",
            "name": "Product Research",
            "description": "Analyze product features and benefits", 
            "success": "Complete understanding of product value",
            "failure": "Insufficient product knowledge"
        },
        {
            "id": "write", 
            "name": "Write Copy",
            "description": "Create engaging product description",
            "success": "200-word compelling description",
            "failure": "Generic or unconvincing copy"
        }
    ]
}

# Sign and create task
signed_task = agent.create_task(task)
print(f'Task created: {signed_task["jacsId"]}')
</code></pre>
</div>
</div>
</div>
<h2 id="understanding-what-happened"><a class="header" href="#understanding-what-happened">Understanding What Happened</a></h2>
<p>When you completed the quick start, several important things occurred:</p>
<h3 id="1-agent-creation"><a class="header" href="#1-agent-creation">1. <strong>Agent Creation</strong></a></h3>
<ul>
<li>A unique identity (UUID) was generated for your agent</li>
<li>Cryptographic key pair was created for signing</li>
<li>Agent document was created and self-signed</li>
<li>Public key was stored for verification</li>
</ul>
<h3 id="2-configuration-setup"><a class="header" href="#2-configuration-setup">2. <strong>Configuration Setup</strong></a></h3>
<ul>
<li>Storage directories were configured</li>
<li>Cryptographic algorithm was selected</li>
<li>Agent identity was linked to configuration</li>
</ul>
<h3 id="3-task-creation"><a class="header" href="#3-task-creation">3. <strong>Task Creation</strong></a></h3>
<ul>
<li>Task document was structured according to JACS schema</li>
<li>Document was signed with your agent's private key</li>
<li>SHA-256 hash was calculated for integrity</li>
<li>Signature metadata was embedded in the document</li>
</ul>
<h2 id="verify-everything-works"><a class="header" href="#verify-everything-works">Verify Everything Works</a></h2>
<p>Let's verify that the documents are properly signed and can be validated:</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="verify-rust" name="verify-group" checked>
<label for="verify-rust">ü¶Ä Rust</label>
<div class="content">
<pre><code class="language-bash"># Verify agent signature
jacs agent verify

# List all documents
jacs document list

# Verify specific task
jacs document verify --file ./jacs_data/tasks/[task-id].json

# Show task details
jacs task show --id [task-id]
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="verify-nodejs" name="verify-group">
<label for="verify-nodejs">üü¢ Node.js</label>
<div class="content">
<pre><code class="language-javascript">// Verify agent signature
const isValid = await agent.verifyAgent();
console.log('Agent signature valid:', isValid);

// List all documents
const documents = await agent.listDocuments();
console.log('Documents:', documents.length);

// Verify task signature
const taskValid = await agent.verifyDocument(signedTask);
console.log('Task signature valid:', taskValid);

// Get document details
const taskDetails = await agent.getDocument(signedTask.jacsId);
console.log('Task details:', taskDetails);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="verify-python" name="verify-group">
<label for="verify-python">üêç Python</label>
<div class="content">
<pre><code class="language-python"># Verify agent signature
is_valid = agent.verify_agent()
print(f'Agent signature valid: {is_valid}')

# List all documents
documents = agent.list_documents()
print(f'Documents: {len(documents)}')

# Verify task signature  
task_valid = agent.verify_document(signed_task)
print(f'Task signature valid: {task_valid}')

# Get document details
task_details = agent.get_document(signed_task["jacsId"])
print(f'Task details: {task_details}')
</code></pre>
</div>
</div>
</div>
<h2 id="next-steps-multi-agent-workflow"><a class="header" href="#next-steps-multi-agent-workflow">Next Steps: Multi-Agent Workflow</a></h2>
<p>Now let's create a second agent and demonstrate inter-agent communication:</p>
<div class="tabs">
<div class="tab">
<input type="radio" id="multi-rust" name="multi-group" checked>
<label for="multi-rust">ü¶Ä Rust</label>
<div class="content">
<pre><code class="language-bash"># Create a second agent configuration
cp jacs.config.json reviewer.config.json

# Create reviewer agent
jacs agent create --config reviewer.config.json \
  --type "Content Reviewer" --name "ReviewBot"

# Create an agreement for the task
jacs agreement create \
  --task-id [task-id] \
  --agents [agent-1-id] [agent-2-id] \
  --question "Do you agree to collaborate on this content task?"

# Sign the agreement as first agent
jacs agreement sign --agreement-id [agreement-id]

# Sign as second agent (switch config)
jacs agreement sign --config reviewer.config.json \
  --agreement-id [agreement-id]

# Verify agreement is complete
jacs agreement verify --agreement-id [agreement-id]
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="multi-nodejs" name="multi-group">
<label for="multi-nodejs">üü¢ Node.js</label>
<div class="content">
<pre><code class="language-javascript">// Create second agent
const reviewerConfig = { ...config };
reviewerConfig.jacs_agent_id_and_version = null;

const reviewer = new JacsAgent(reviewerConfig);
await reviewer.generateKeys();

const reviewerDoc = await reviewer.createAgent({
  name: "Content Reviewer Bot",
  description: "AI agent specialized in content review"
});

// Create agreement between agents
const agreement = {
  title: "Content Collaboration Agreement",
  question: "Do you agree to collaborate on this content task?",
  context: `Task: ${signedTask.jacsId}`,
  agents: [agentDoc.jacsId, reviewerDoc.jacsId]
};

const signedAgreement = await agent.createAgreement(agreement);

// Both agents sign the agreement
await agent.signAgreement(signedAgreement.jacsId);
await reviewer.signAgreement(signedAgreement.jacsId);

// Verify all signatures
const agreementValid = await agent.verifyAgreement(signedAgreement.jacsId);
console.log('Agreement complete:', agreementValid);
</code></pre>
</div>
</div>
<div class="tab">
<input type="radio" id="multi-python" name="multi-group">
<label for="multi-python">üêç Python</label>
<div class="content">
<pre><code class="language-python"># Create second agent
reviewer_config = config.copy()
reviewer_config["jacs_agent_id_and_version"] = None

reviewer = jacs.Agent(reviewer_config)
reviewer.generate_keys()

reviewer_doc = reviewer.create_agent({
    "name": "Content Reviewer Bot", 
    "description": "AI agent specialized in content review"
})

# Create agreement between agents
agreement = {
    "title": "Content Collaboration Agreement",
    "question": "Do you agree to collaborate on this content task?",
    "context": f"Task: {signed_task['jacsId']}",
    "agents": [agent_doc["jacsId"], reviewer_doc["jacsId"]]
}

signed_agreement = agent.create_agreement(agreement)

# Both agents sign the agreement
agent.sign_agreement(signed_agreement["jacsId"])
reviewer.sign_agreement(signed_agreement["jacsId"])

# Verify all signatures
agreement_valid = agent.verify_agreement(signed_agreement["jacsId"])
print(f'Agreement complete: {agreement_valid}')
</code></pre>
</div>
</div>
</div>
<h2 id="what-youve-accomplished"><a class="header" href="#what-youve-accomplished">What You've Accomplished</a></h2>
<p>Congratulations! You've successfully:</p>
<p>‚úÖ <strong>Created JACS agents</strong> with cryptographic identities
‚úÖ <strong>Generated and signed documents</strong> with verifiable integrity<br />
‚úÖ <strong>Established multi-agent agreements</strong> with cryptographic consent
‚úÖ <strong>Verified signatures</strong> and document authenticity
‚úÖ <strong>Created an audit trail</strong> of all interactions</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li><strong>Everything is verifiable</strong>: All documents have cryptographic signatures</li>
<li><strong>Agents are autonomous</strong>: Each has its own identity and keys</li>
<li><strong>Agreements enable trust</strong>: Multi-party consent before proceeding</li>
<li><strong>Audit trails are automatic</strong>: Complete history of all interactions</li>
<li><strong>JSON is universal</strong>: Documents work everywhere</li>
</ul>
<h2 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to Go Next</a></h2>
<p>Now that you have the basics working:</p>
<ol>
<li><strong><a href="getting-started/../rust/library.html">Rust Deep Dive</a></strong> - Learn the full Rust API</li>
<li><strong><a href="getting-started/../nodejs/mcp.html">Node.js Integration</a></strong> - Add MCP support</li>
<li><strong><a href="getting-started/../python/fastmcp.html">Python FastMCP</a></strong> - Build MCP servers</li>
<li><strong><a href="getting-started/../advanced/observability.html">Production Setup</a></strong> - Add monitoring and logging</li>
<li><strong><a href="getting-started/../examples/integrations.html">Real Examples</a></strong> - See production patterns</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p><strong>Agent creation fails</strong>: Check that the data and key directories exist and are writable
<strong>Signature verification fails</strong>: Ensure public keys are properly stored and accessible
<strong>Agreement signing fails</strong>: Verify all agent IDs are correct and agents exist
<strong>Documents not found</strong>: Check the data directory configuration</p>
<p>Need help? Check the <a href="https://github.com/HumanAssisted/JACS/issues">GitHub issues</a> or review the detailed implementation guides.</p>
<style>
.tabs {
  display: flex;
  flex-wrap: wrap;
  max-width: 100%;
  font-family: sans-serif;
}

.tab {
  order: 1;
  flex-grow: 1;
}

.tab input[type="radio"] {
  display: none;
}

.tab label {
  display: block;
  padding: 1em;
  background: #f0f0f0;
  color: #666;
  border: 1px solid #ddd;
  cursor: pointer;
  margin-bottom: -1px;
}

.tab label:hover {
  background: #e0e0e0;
}

.tab input:checked + label {
  background: #007acc;
  color: white;
}

.tab .content {
  order: 99;
  flex-grow: 1;
  width: 100%;
  display: none;
  padding: 1em;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
}

.tab input:checked ~ .content {
  display: block;
}
</style> <div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-agent"><a class="header" href="#creating-an-agent">Creating an Agent</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-documents"><a class="header" href="#working-with-documents">Working with Documents</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-using-agreements"><a class="header" href="#creating-and-using-agreements">Creating and Using Agreements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-library-api"><a class="header" href="#rust-library-api">Rust Library API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability"><a class="header" href="#observability">Observability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-installation"><a class="header" href="#nodejs-installation">Node.js Installation</a></h1>
<p>The JACS Node.js package (<code>jacsnpm</code>) provides JavaScript/TypeScript bindings to the JACS Rust library, making it easy to integrate JACS into web applications, servers, and Node.js projects.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Node.js</strong>: Version 16.0 or higher</li>
<li><strong>npm</strong> or <strong>yarn</strong>: For package management</li>
<li><strong>Operating System</strong>: macOS, Linux, or Windows with WSL</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="using-npm"><a class="header" href="#using-npm">Using npm</a></h3>
<pre><code class="language-bash">npm install jacsnpm
</code></pre>
<h3 id="using-yarn"><a class="header" href="#using-yarn">Using yarn</a></h3>
<pre><code class="language-bash">yarn add jacsnpm
</code></pre>
<h3 id="using-pnpm"><a class="header" href="#using-pnpm">Using pnpm</a></h3>
<pre><code class="language-bash">pnpm add jacsnpm
</code></pre>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre><code class="language-javascript">// test.js
import { JacsAgent } from 'jacsnpm';

console.log('JACS Node.js bindings loaded successfully!');

// Test basic functionality
try {
  const config = {
    jacs_data_directory: "./test_data",
    jacs_key_directory: "./test_keys",
    jacs_default_storage: "fs",
    jacs_agent_key_algorithm: "Ed25519"
  };
  
  const agent = new JacsAgent(config);
  console.log('Agent created successfully!');
} catch (error) {
  console.error('Error creating agent:', error);
}
</code></pre>
<p>Run the test:</p>
<pre><code class="language-bash">node test.js
</code></pre>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<p>The <code>jacsnpm</code> package includes several modules:</p>
<h3 id="core-module-jacsnpm"><a class="header" href="#core-module-jacsnpm">Core Module (<code>jacsnpm</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsAgent,
  JacsConfig,
  JacsDocument,
  JacsError
} from 'jacsnpm';
</code></pre>
<h3 id="mcp-integration-jacsnpmmcp"><a class="header" href="#mcp-integration-jacsnpmmcp">MCP Integration (<code>jacsnpm/mcp</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsMcpServer,
  createJacsMiddleware 
} from 'jacsnpm/mcp';
</code></pre>
<h3 id="http-server-jacsnpmhttp"><a class="header" href="#http-server-jacsnpmhttp">HTTP Server (<code>jacsnpm/http</code>)</a></h3>
<pre><code class="language-javascript">import { 
  JacsHttpServer,
  createJacsRouter 
} from 'jacsnpm/http';
</code></pre>
<h2 id="typescript-support"><a class="header" href="#typescript-support">TypeScript Support</a></h2>
<p>The package includes full TypeScript definitions:</p>
<pre><code class="language-typescript">import { 
  JacsAgent, 
  JacsConfig, 
  AgentDocument, 
  TaskDocument,
  AgreementDocument 
} from 'jacsnpm';

interface MyConfig extends JacsConfig {
  custom_field?: string;
}

const config: MyConfig = {
  jacs_data_directory: "./data",
  jacs_key_directory: "./keys",
  jacs_default_storage: "fs",
  jacs_agent_key_algorithm: "Ed25519",
  custom_field: "value"
};

const agent: JacsAgent = new JacsAgent(config);
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h3>
<pre><code class="language-javascript">const config = {
  // Required fields
  jacs_data_directory: "./jacs_data",      // Where documents are stored
  jacs_key_directory: "./jacs_keys",       // Where keys are stored
  jacs_default_storage: "fs",              // Storage backend
  jacs_agent_key_algorithm: "Ed25519",     // Signing algorithm
  
  // Optional fields
  jacs_agent_id_and_version: null,         // Existing agent to load
  jacs_agent_private_key_filename: "private.pem",
  jacs_agent_public_key_filename: "public.pem"
};
</code></pre>
<h3 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h3>
<p>You can also use a JSON configuration file:</p>
<pre><code class="language-json">{
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys", 
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "Ed25519"
}
</code></pre>
<p>Load the configuration:</p>
<pre><code class="language-javascript">import fs from 'fs';

const config = JSON.parse(fs.readFileSync('./jacs.config.json', 'utf8'));
const agent = new JacsAgent(config);
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can override configuration with environment variables:</p>
<pre><code class="language-bash">export JACS_DATA_DIRECTORY="./production_data"
export JACS_KEY_DIRECTORY="./production_keys"
export JACS_AGENT_KEY_ALGORITHM="RSA"
</code></pre>
<pre><code class="language-javascript">const config = {
  jacs_data_directory: process.env.JACS_DATA_DIRECTORY || "./jacs_data",
  jacs_key_directory: process.env.JACS_KEY_DIRECTORY || "./jacs_keys",
  jacs_default_storage: "fs",
  jacs_agent_key_algorithm: process.env.JACS_AGENT_KEY_ALGORITHM || "Ed25519"
};
</code></pre>
<h2 id="storage-backends"><a class="header" href="#storage-backends">Storage Backends</a></h2>
<h3 id="file-system-default"><a class="header" href="#file-system-default">File System (Default)</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_default_storage: "fs",
  jacs_data_directory: "./jacs_data",
  jacs_key_directory: "./jacs_keys"
};
</code></pre>
<h3 id="s3-storage"><a class="header" href="#s3-storage">S3 Storage</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_default_storage: "s3",
  jacs_s3_bucket: "my-jacs-bucket",
  jacs_s3_region: "us-west-2",
  jacs_s3_prefix: "jacs/"
};
</code></pre>
<h3 id="azure-blob-storage"><a class="header" href="#azure-blob-storage">Azure Blob Storage</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_default_storage: "azure",
  jacs_azure_account: "myaccount",
  jacs_azure_container: "jacs",
  jacs_azure_key: process.env.AZURE_STORAGE_KEY
};
</code></pre>
<h2 id="cryptographic-algorithms"><a class="header" href="#cryptographic-algorithms">Cryptographic Algorithms</a></h2>
<h3 id="ed25519-recommended"><a class="header" href="#ed25519-recommended">Ed25519 (Recommended)</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_agent_key_algorithm: "Ed25519"
};
</code></pre>
<p><strong>Pros</strong>: Fast, secure, small signatures
<strong>Cons</strong>: Newer standard, less universal support</p>
<h3 id="rsa-pss"><a class="header" href="#rsa-pss">RSA-PSS</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_agent_key_algorithm: "RSA"
};
</code></pre>
<p><strong>Pros</strong>: Widely supported, proven security
<strong>Cons</strong>: Larger signatures, slower</p>
<h3 id="post-quantum-experimental"><a class="header" href="#post-quantum-experimental">Post-Quantum (Experimental)</a></h3>
<pre><code class="language-javascript">const config = {
  jacs_agent_key_algorithm: "Dilithium"
};
</code></pre>
<p><strong>Pros</strong>: Quantum-resistant
<strong>Cons</strong>: Experimental, large signatures</p>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code>my-jacs-project/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ jacs.config.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ agent.js
‚îÇ   ‚îú‚îÄ‚îÄ tasks.js
‚îÇ   ‚îî‚îÄ‚îÄ agreements.js
‚îú‚îÄ‚îÄ jacs_data/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îî‚îÄ‚îÄ documents/
‚îî‚îÄ‚îÄ jacs_keys/
    ‚îú‚îÄ‚îÄ private.pem
    ‚îî‚îÄ‚îÄ public.pem
</code></pre>
<h3 id="packagejson-setup"><a class="header" href="#packagejson-setup">Package.json Setup</a></h3>
<pre><code class="language-json">{
  "name": "my-jacs-app",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "jacsnpm": "^0.1.0",
    "express": "^4.18.0"
  },
  "scripts": {
    "start": "node src/app.js",
    "test": "node test/test.js",
    "dev": "nodemon src/app.js"
  }
}
</code></pre>
<h3 id="basic-application"><a class="header" href="#basic-application">Basic Application</a></h3>
<pre><code class="language-javascript">// src/app.js
import { JacsAgent } from 'jacsnpm';
import fs from 'fs';

// Load configuration
const config = JSON.parse(fs.readFileSync('./jacs.config.json', 'utf8'));

// Create agent
const agent = new JacsAgent(config);

// Initialize if needed
if (!config.jacs_agent_id_and_version) {
  await agent.generateKeys();
  const agentDoc = await agent.createAgent({
    name: "My JACS Agent",
    description: "Example Node.js JACS agent"
  });
  
  // Update config with agent ID
  config.jacs_agent_id_and_version = `${agentDoc.jacsId}:${agentDoc.jacsVersion}`;
  fs.writeFileSync('./jacs.config.json', JSON.stringify(config, null, 2));
}

console.log('JACS agent ready!');
</code></pre>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h3 id="module-not-found"><a class="header" href="#module-not-found">Module Not Found</a></h3>
<p>If you get <code>Module not found</code> errors:</p>
<pre><code class="language-bash"># Check Node.js version
node --version  # Should be 16+

# Clear node_modules and reinstall
rm -rf node_modules package-lock.json
npm install
</code></pre>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<p>If you get permission errors accessing files:</p>
<pre><code class="language-bash"># Check directory permissions
ls -la jacs_data/ jacs_keys/

# Fix permissions
chmod 755 jacs_data/ jacs_keys/
chmod 600 jacs_keys/*.pem
</code></pre>
<h3 id="binary-compatibility"><a class="header" href="#binary-compatibility">Binary Compatibility</a></h3>
<p>If you get binary compatibility errors:</p>
<pre><code class="language-bash"># Rebuild native modules
npm rebuild

# Or reinstall
npm uninstall jacsnpm
npm install jacsnpm
</code></pre>
<h3 id="typescript-issues"><a class="header" href="#typescript-issues">TypeScript Issues</a></h3>
<p>If TypeScript can't find definitions:</p>
<pre><code class="language-json">// tsconfig.json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you have JACS installed:</p>
<ol>
<li><strong><a href="nodejs/basic-usage.html">Basic Usage</a></strong> - Learn core JACS operations</li>
<li><strong><a href="nodejs/mcp.html">MCP Integration</a></strong> - Add Model Context Protocol support</li>
<li><strong><a href="nodejs/http.html">HTTP Server</a></strong> - Create JACS HTTP APIs</li>
<li><strong><a href="nodejs/express.html">Express Middleware</a></strong> - Integrate with Express.js</li>
<li><strong><a href="nodejs/api.html">API Reference</a></strong> - Complete API documentation</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Check out the complete examples in the <a href="nodejs/../examples/nodejs.html">examples directory</a>:</p>
<ul>
<li>Basic agent creation and task management</li>
<li>Express.js middleware integration</li>
<li>MCP server implementation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-context-protocol-mcp-integration"><a class="header" href="#model-context-protocol-mcp-integration">Model Context Protocol (MCP) Integration</a></h1>
<p>JACS provides native integration with the <a href="https://modelcontextprotocol.io/">Model Context Protocol (MCP)</a>, enabling secure agent communication within AI systems. This allows JACS agents to be used directly as MCP servers or clients.</p>
<h2 id="what-is-mcp"><a class="header" href="#what-is-mcp">What is MCP?</a></h2>
<p>Model Context Protocol is a standard for AI models to securely access external tools, data, and services. JACS enhances MCP by adding:</p>
<ul>
<li><strong>Cryptographic verification</strong> of tool outputs</li>
<li><strong>Agent identity</strong> for all operations</li>
<li><strong>Audit trails</strong> of all MCP interactions</li>
<li><strong>Multi-agent agreements</strong> for complex workflows</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="basic-mcp-server"><a class="header" href="#basic-mcp-server">Basic MCP Server</a></h3>
<pre><code class="language-javascript">import { JacsMcpServer } from 'jacsnpm/mcp';

// Create a JACS-enabled MCP server
const server = new JacsMcpServer({
  name: "JACS Task Server",
  version: "1.0.0",
  configPath: './jacs.config.json'
});

// Add JACS tools automatically
server.addJacsTools();

// Start the server
await server.start();
console.log('JACS MCP Server running!');
</code></pre>
<h3 id="using-with-existing-mcp-server"><a class="header" href="#using-with-existing-mcp-server">Using with Existing MCP Server</a></h3>
<pre><code class="language-javascript">import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { createJacsMiddleware } from 'jacsnpm/mcp';

const server = new McpServer({ 
  name: "MyServer", 
  version: "1.0.0" 
});

// Add JACS middleware
server.use(createJacsMiddleware({ 
  configPath: './jacs.config.json' 
}));

await server.start();
</code></pre>
<h2 id="available-tools"><a class="header" href="#available-tools">Available Tools</a></h2>
<p>When you add JACS to an MCP server, it provides these tools:</p>
<h3 id="agent-management"><a class="header" href="#agent-management">Agent Management</a></h3>
<ul>
<li><code>jacs_create_agent</code> - Create new JACS agents</li>
<li><code>jacs_update_agent</code> - Update agent information</li>
<li><code>jacs_verify_agent</code> - Verify agent signatures</li>
<li><code>jacs_list_agents</code> - List all known agents</li>
</ul>
<h3 id="task-management"><a class="header" href="#task-management">Task Management</a></h3>
<ul>
<li><code>jacs_create_task</code> - Create signed task documents</li>
<li><code>jacs_assign_task</code> - Delegate tasks to other agents</li>
<li><code>jacs_complete_task</code> - Mark tasks as completed</li>
<li><code>jacs_verify_task</code> - Verify task signatures</li>
</ul>
<h3 id="agreement-management"><a class="header" href="#agreement-management">Agreement Management</a></h3>
<ul>
<li><code>jacs_create_agreement</code> - Create multi-party agreements</li>
<li><code>jacs_sign_agreement</code> - Add signature to agreement</li>
<li><code>jacs_verify_agreement</code> - Check agreement completeness</li>
<li><code>jacs_list_agreements</code> - Show pending/completed agreements</li>
</ul>
<h3 id="document-operations"><a class="header" href="#document-operations">Document Operations</a></h3>
<ul>
<li><code>jacs_create_document</code> - Create and sign any document</li>
<li><code>jacs_verify_document</code> - Verify document integrity</li>
<li><code>jacs_list_documents</code> - List all documents</li>
<li><code>jacs_get_document</code> - Retrieve specific document</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h3>
<pre><code class="language-javascript">const serverConfig = {
  // MCP Server settings
  name: "JACS Agent Server",
  version: "1.0.0",
  
  // JACS Configuration
  configPath: './jacs.config.json',
  
  // Optional: Custom tools
  enabledTools: [
    'jacs_create_task',
    'jacs_verify_task', 
    'jacs_create_agreement',
    'jacs_sign_agreement'
  ],
  
  // Optional: Auto-initialization
  autoInit: true,
  createAgentOnInit: true
};

const server = new JacsMcpServer(serverConfig);
</code></pre>
<h3 id="middleware-configuration"><a class="header" href="#middleware-configuration">Middleware Configuration</a></h3>
<pre><code class="language-javascript">const middlewareConfig = {
  configPath: './jacs.config.json',
  
  // Agent initialization
  autoCreateAgent: true,
  agentName: "MCP JACS Agent",
  agentDescription: "Agent providing JACS services via MCP",
  
  // Tool selection
  tools: ['tasks', 'agreements', 'documents'],
  
  // Security options
  requireSignatures: true,
  verifyIncomingDocuments: true
};

server.use(createJacsMiddleware(middlewareConfig));
</code></pre>
<h2 id="tool-usage-examples"><a class="header" href="#tool-usage-examples">Tool Usage Examples</a></h2>
<h3 id="creating-a-task"><a class="header" href="#creating-a-task">Creating a Task</a></h3>
<pre><code class="language-javascript">// MCP Client code (Claude, other AI systems)
const taskResult = await mcpClient.callTool('jacs_create_task', {
  title: "Analyze Sales Data",
  description: "Generate insights from Q4 sales data",
  actions: [
    {
      id: "extract",
      name: "Extract Data",
      description: "Pull sales data from database",
      success: "Complete dataset extracted",
      failure: "Unable to connect to database"
    },
    {
      id: "analyze", 
      name: "Analyze Trends",
      description: "Identify patterns and insights",
      success: "Key insights identified",
      failure: "Insufficient data for analysis"
    }
  ]
});

console.log('Task created:', taskResult.jacsId);
console.log('Task signature:', taskResult.jacsSignature);
</code></pre>
<h3 id="creating-an-agreement"><a class="header" href="#creating-an-agreement">Creating an Agreement</a></h3>
<pre><code class="language-javascript">const agreementResult = await mcpClient.callTool('jacs_create_agreement', {
  title: "Data Analysis Agreement",
  question: "Do you agree to analyze the Q4 sales data?",
  context: "Task requires access to confidential sales database",
  agents: [
    "agent-1-uuid",
    "agent-2-uuid",
    "agent-3-uuid"
  ]
});

console.log('Agreement created:', agreementResult.jacsId);
console.log('Required signatures:', agreementResult.agents.length);
</code></pre>
<h3 id="verifying-documents"><a class="header" href="#verifying-documents">Verifying Documents</a></h3>
<pre><code class="language-javascript">const verificationResult = await mcpClient.callTool('jacs_verify_document', {
  documentId: "task-uuid-here"
});

console.log('Document valid:', verificationResult.valid);
console.log('Signature verified:', verificationResult.signatureValid);
console.log('Hash verified:', verificationResult.hashValid);
</code></pre>
<h2 id="advanced-integration"><a class="header" href="#advanced-integration">Advanced Integration</a></h2>
<h3 id="custom-tools"><a class="header" href="#custom-tools">Custom Tools</a></h3>
<p>Add your own JACS-aware tools:</p>
<pre><code class="language-javascript">import { JacsMcpServer } from 'jacsnpm/mcp';

const server = new JacsMcpServer(config);

// Custom tool that creates signed reports
server.addTool({
  name: "create_signed_report",
  description: "Create a cryptographically signed report",
  inputSchema: {
    type: "object",
    properties: {
      title: { type: "string" },
      content: { type: "string" },
      reportType: { type: "string", enum: ["analysis", "summary", "recommendation"] }
    },
    required: ["title", "content", "reportType"]
  }
}, async (params) =&gt; {
  const { title, content, reportType } = params;
  
  // Create report document
  const report = {
    jacsType: "report",
    title,
    content,
    reportType,
    generatedAt: new Date().toISOString()
  };
  
  // Sign with JACS agent
  const signedReport = await server.jacsAgent.createDocument(report);
  
  return {
    success: true,
    document: signedReport,
    verification: await server.jacsAgent.verifyDocument(signedReport)
  };
});
</code></pre>
<h3 id="multi-agent-workflows"><a class="header" href="#multi-agent-workflows">Multi-Agent Workflows</a></h3>
<p>Coordinate multiple agents through MCP:</p>
<pre><code class="language-javascript">// Agent A creates a task
const task = await agentA.callTool('jacs_create_task', {
  title: "Content Creation Pipeline",
  description: "Multi-stage content creation process"
});

// Create agreement for collaboration
const agreement = await agentA.callTool('jacs_create_agreement', {
  title: "Content Collaboration Agreement", 
  question: "Do you agree to participate in content creation?",
  context: `Task: ${task.jacsId}`,
  agents: [agentA.id, agentB.id, agentC.id]
});

// Each agent signs the agreement
await agentA.callTool('jacs_sign_agreement', { agreementId: agreement.jacsId });
await agentB.callTool('jacs_sign_agreement', { agreementId: agreement.jacsId });
await agentC.callTool('jacs_sign_agreement', { agreementId: agreement.jacsId });

// Verify all signatures before proceeding
const verification = await agentA.callTool('jacs_verify_agreement', { 
  agreementId: agreement.jacsId 
});

if (verification.complete) {
  console.log('All agents have signed - workflow can proceed');
}
</code></pre>
<h2 id="transport-options"><a class="header" href="#transport-options">Transport Options</a></h2>
<h3 id="stdio-transport-default"><a class="header" href="#stdio-transport-default">Stdio Transport (Default)</a></h3>
<pre><code class="language-javascript">import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new JacsMcpServer(config);
const transport = new StdioServerTransport();
await server.connect(transport);
</code></pre>
<h3 id="sse-transport-http"><a class="header" href="#sse-transport-http">SSE Transport (HTTP)</a></h3>
<pre><code class="language-javascript">import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';

const server = new JacsMcpServer(config);
const transport = new SSEServerTransport('/mcp', {
  port: 3000
});
await server.connect(transport);
</code></pre>
<h3 id="websocket-transport"><a class="header" href="#websocket-transport">WebSocket Transport</a></h3>
<pre><code class="language-javascript">import { WebSocketServerTransport } from '@modelcontextprotocol/sdk/server/websocket.js';

const server = new JacsMcpServer(config);
const transport = new WebSocketServerTransport({
  port: 3001
});
await server.connect(transport);
</code></pre>
<h2 id="client-integration"><a class="header" href="#client-integration">Client Integration</a></h2>
<h3 id="using-jacs-with-mcp-clients"><a class="header" href="#using-jacs-with-mcp-clients">Using JACS with MCP Clients</a></h3>
<pre><code class="language-javascript">import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

// Connect to JACS MCP server
const transport = new StdioClientTransport({
  command: 'node',
  args: ['jacs-mcp-server.js']
});

const client = new Client({
  name: "JACS MCP Client",
  version: "1.0.0"
}, {
  capabilities: {
    tools: {}
  }
});

await client.connect(transport);

// List available JACS tools
const tools = await client.listTools();
console.log('Available JACS tools:', tools.tools.map(t =&gt; t.name));

// Use JACS tools
const result = await client.callTool({
  name: "jacs_create_task",
  arguments: {
    title: "Example Task",
    description: "Task created via MCP client"
  }
});

console.log('Task created:', result.content);
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="signature-verification"><a class="header" href="#signature-verification">Signature Verification</a></h3>
<p>All JACS tools automatically verify signatures:</p>
<pre><code class="language-javascript">// Tool implementation with verification
server.addTool({
  name: "process_task_result",
  description: "Process results from task completion"
}, async (params) =&gt; {
  const { taskId, result } = params;
  
  // Verify the task exists and signature is valid
  const task = await server.jacsAgent.getDocument(taskId);
  const isValid = await server.jacsAgent.verifyDocument(task);
  
  if (!isValid) {
    throw new Error('Invalid task signature - refusing to process');
  }
  
  // Process the verified task result
  return processResult(result);
});
</code></pre>
<h3 id="agent-authentication"><a class="header" href="#agent-authentication">Agent Authentication</a></h3>
<p>Authenticate agent identity for sensitive operations:</p>
<pre><code class="language-javascript">server.addTool({
  name: "access_sensitive_data",
  description: "Access sensitive data with agent verification"
}, async (params, context) =&gt; {
  const { agentId, dataType } = params;
  
  // Verify the requesting agent has proper credentials
  const agent = await server.jacsAgent.getAgent(agentId);
  const hasPermission = await checkAgentPermissions(agent, dataType);
  
  if (!hasPermission) {
    throw new Error('Agent lacks permission for this data type');
  }
  
  return getSensitiveData(dataType);
});
</code></pre>
<h2 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h2>
<h3 id="request-logging"><a class="header" href="#request-logging">Request Logging</a></h3>
<pre><code class="language-javascript">const server = new JacsMcpServer({
  ...config,
  logging: {
    logRequests: true,
    logSignatures: true,
    logVerifications: true
  }
});

// Logs will include:
// - Tool calls with agent identity
// - Signature verification results  
// - Document creation/modification
// - Agreement signing events
</code></pre>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<pre><code class="language-javascript">import { recordMcpOperation } from 'jacsnpm/observability';

server.addTool({
  name: "example_tool"
}, async (params) =&gt; {
  const startTime = Date.now();
  
  try {
    const result = await performOperation(params);
    
    recordMcpOperation('example_tool', true, Date.now() - startTime);
    return result;
  } catch (error) {
    recordMcpOperation('example_tool', false, Date.now() - startTime);
    throw error;
  }
});
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>Complete MCP integration examples are available:</p>
<ul>
<li><strong><a href="nodejs/../examples/nodejs.html#mcp-server">Basic MCP Server</a></strong> - Simple JACS MCP server</li>
<li><strong><a href="nodejs/../examples/nodejs.html#express-mcp">Express Integration</a></strong> - MCP server with Express.js</li>
<li><strong><a href="nodejs/../examples/nodejs.html#multi-agent-mcp">Multi-Agent Workflow</a></strong> - Coordinated agent collaboration</li>
<li><strong><a href="nodejs/../examples/nodejs.html#custom-mcp-tools">Custom Tools</a></strong> - Building domain-specific JACS tools</li>
</ul>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="connection-issues"><a class="header" href="#connection-issues">Connection Issues</a></h3>
<pre><code class="language-bash"># Test MCP server connectivity
echo '{"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": {"protocolVersion": "2024-11-05", "capabilities": {}}}' | node jacs-mcp-server.js
</code></pre>
<h3 id="tool-registration-problems"><a class="header" href="#tool-registration-problems">Tool Registration Problems</a></h3>
<pre><code class="language-javascript">// Verify tools are registered correctly
const server = new JacsMcpServer(config);
await server.start();

const tools = await server.listTools();
console.log('Registered tools:', tools.map(t =&gt; t.name));
</code></pre>
<h3 id="signature-verification-failures"><a class="header" href="#signature-verification-failures">Signature Verification Failures</a></h3>
<pre><code class="language-javascript">// Debug signature issues
try {
  const result = await mcpClient.callTool('jacs_verify_document', {
    documentId: 'problematic-doc-id'
  });
} catch (error) {
  console.error('Verification details:', error.details);
  // Check agent keys, document integrity, etc.
}
</code></pre>
<p>For more details, see the <a href="nodejs/api.html">API Reference</a> and <a href="nodejs/../examples/nodejs.html">complete examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server"><a class="header" href="#http-server">HTTP Server</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-middleware"><a class="header" href="#express-middleware">Express Middleware</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-installation"><a class="header" href="#python-installation">Python Installation</a></h1>
<p>The JACS Python package (<code>jacs</code>) provides Python bindings to the JACS Rust library, making it easy to integrate JACS into AI/ML workflows, data science projects, and Python applications.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li><strong>Python</strong>: Version 3.10 or higher</li>
<li><strong>pip</strong>: For package management</li>
<li><strong>Operating System</strong>: Linux, macOS, or Windows with WSL</li>
<li><strong>Architecture</strong>: x86_64 or ARM64</li>
</ul>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<h3 id="using-pip"><a class="header" href="#using-pip">Using pip</a></h3>
<pre><code class="language-bash">pip install jacs
</code></pre>
<h3 id="using-conda"><a class="header" href="#using-conda">Using conda</a></h3>
<pre><code class="language-bash">conda install -c conda-forge jacs
</code></pre>
<h3 id="using-poetry"><a class="header" href="#using-poetry">Using poetry</a></h3>
<pre><code class="language-bash">poetry add jacs
</code></pre>
<h3 id="development-installation"><a class="header" href="#development-installation">Development Installation</a></h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/HumanAssisted/JACS
cd JACS/jacspy

# Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install in development mode
pip install -e .
</code></pre>
<h2 id="verify-installation-1"><a class="header" href="#verify-installation-1">Verify Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre><code class="language-python"># test.py
import jacs
import json

print('JACS Python bindings loaded successfully!')

# Test basic functionality
try:
    config = {
        "jacs_data_directory": "./test_data",
        "jacs_key_directory": "./test_keys",
        "jacs_default_storage": "fs",
        "jacs_agent_key_algorithm": "Ed25519"
    }
    
    agent = jacs.Agent(config)
    print('Agent created successfully!')
except Exception as error:
    print(f'Error creating agent: {error}')
</code></pre>
<p>Run the test:</p>
<pre><code class="language-bash">python test.py
</code></pre>
<h2 id="package-structure-1"><a class="header" href="#package-structure-1">Package Structure</a></h2>
<p>The <code>jacs</code> package includes several modules:</p>
<h3 id="core-module"><a class="header" href="#core-module">Core Module</a></h3>
<pre><code class="language-python">import jacs

# Core classes
agent = jacs.Agent(config)
document = jacs.Document(data)
task = jacs.Task(config)
</code></pre>
<h3 id="mcp-integration"><a class="header" href="#mcp-integration">MCP Integration</a></h3>
<pre><code class="language-python">from jacs.mcp import JacsMcpServer, create_jacs_middleware

# MCP server functionality
server = JacsMcpServer(config)
</code></pre>
<h3 id="fastmcp-integration"><a class="header" href="#fastmcp-integration">FastMCP Integration</a></h3>
<pre><code class="language-python">from jacs.fastmcp import FastMcpServer, JacsTools

# Advanced MCP server with FastMCP
server = FastMcpServer()
server.add_jacs_tools()
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="basic-configuration-1"><a class="header" href="#basic-configuration-1">Basic Configuration</a></h3>
<pre><code class="language-python">config = {
    # Required fields
    "jacs_data_directory": "./jacs_data",      # Where documents are stored
    "jacs_key_directory": "./jacs_keys",       # Where keys are stored
    "jacs_default_storage": "fs",              # Storage backend
    "jacs_agent_key_algorithm": "Ed25519",     # Signing algorithm
    
    # Optional fields
    "jacs_agent_id_and_version": None,         # Existing agent to load
    "jacs_agent_private_key_filename": "private.pem",
    "jacs_agent_public_key_filename": "public.pem"
}
</code></pre>
<h3 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration File</a></h3>
<p>You can also use a JSON configuration file:</p>
<pre><code class="language-json">{
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys", 
  "jacs_default_storage": "fs",
  "jacs_agent_key_algorithm": "Ed25519"
}
</code></pre>
<p>Load the configuration:</p>
<pre><code class="language-python">import json

with open('jacs.config.json', 'r') as f:
    config = json.load(f)

agent = jacs.Agent(config)
</code></pre>
<h3 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h3>
<p>You can override configuration with environment variables:</p>
<pre><code class="language-bash">export JACS_DATA_DIRECTORY="./production_data"
export JACS_KEY_DIRECTORY="./production_keys"
export JACS_AGENT_KEY_ALGORITHM="RSA"
</code></pre>
<pre><code class="language-python">import os

config = {
    "jacs_data_directory": os.getenv("JACS_DATA_DIRECTORY", "./jacs_data"),
    "jacs_key_directory": os.getenv("JACS_KEY_DIRECTORY", "./jacs_keys"),
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": os.getenv("JACS_AGENT_KEY_ALGORITHM", "Ed25519")
}
</code></pre>
<h2 id="storage-backends-1"><a class="header" href="#storage-backends-1">Storage Backends</a></h2>
<h3 id="file-system-default-1"><a class="header" href="#file-system-default-1">File System (Default)</a></h3>
<pre><code class="language-python">config = {
    "jacs_default_storage": "fs",
    "jacs_data_directory": "./jacs_data",
    "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<h3 id="s3-storage-1"><a class="header" href="#s3-storage-1">S3 Storage</a></h3>
<pre><code class="language-python">config = {
    "jacs_default_storage": "s3",
    "jacs_s3_bucket": "my-jacs-bucket",
    "jacs_s3_region": "us-west-2",
    "jacs_s3_prefix": "jacs/"
}
</code></pre>
<h3 id="azure-blob-storage-1"><a class="header" href="#azure-blob-storage-1">Azure Blob Storage</a></h3>
<pre><code class="language-python">config = {
    "jacs_default_storage": "azure",
    "jacs_azure_account": "myaccount",
    "jacs_azure_container": "jacs",
    "jacs_azure_key": os.getenv("AZURE_STORAGE_KEY")
}
</code></pre>
<h2 id="cryptographic-algorithms-1"><a class="header" href="#cryptographic-algorithms-1">Cryptographic Algorithms</a></h2>
<h3 id="ed25519-recommended-1"><a class="header" href="#ed25519-recommended-1">Ed25519 (Recommended)</a></h3>
<pre><code class="language-python">config = {
    "jacs_agent_key_algorithm": "Ed25519"
}
</code></pre>
<p><strong>Pros</strong>: Fast, secure, small signatures
<strong>Cons</strong>: Newer standard, less universal support</p>
<h3 id="rsa-pss-1"><a class="header" href="#rsa-pss-1">RSA-PSS</a></h3>
<pre><code class="language-python">config = {
    "jacs_agent_key_algorithm": "RSA"
}
</code></pre>
<p><strong>Pros</strong>: Widely supported, proven security
<strong>Cons</strong>: Larger signatures, slower</p>
<h3 id="post-quantum-experimental-1"><a class="header" href="#post-quantum-experimental-1">Post-Quantum (Experimental)</a></h3>
<pre><code class="language-python">config = {
    "jacs_agent_key_algorithm": "Dilithium"
}
</code></pre>
<p><strong>Pros</strong>: Quantum-resistant
<strong>Cons</strong>: Experimental, large signatures</p>
<h2 id="development-setup-1"><a class="header" href="#development-setup-1">Development Setup</a></h2>
<h3 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h3>
<pre><code>my-jacs-project/
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ jacs.config.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ agent.py
‚îÇ   ‚îú‚îÄ‚îÄ tasks.py
‚îÇ   ‚îî‚îÄ‚îÄ agreements.py
‚îú‚îÄ‚îÄ jacs_data/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îî‚îÄ‚îÄ documents/
‚îú‚îÄ‚îÄ jacs_keys/
‚îÇ   ‚îú‚îÄ‚îÄ private.pem
‚îÇ   ‚îî‚îÄ‚îÄ public.pem
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_jacs.py
</code></pre>
<h3 id="requirementstxt-setup"><a class="header" href="#requirementstxt-setup">Requirements.txt Setup</a></h3>
<pre><code>jacs&gt;=0.1.0
fastapi&gt;=0.100.0  # For FastMCP integration
uvicorn&gt;=0.23.0   # For ASGI server
pydantic&gt;=2.0.0   # For data validation
</code></pre>
<h3 id="basic-application-1"><a class="header" href="#basic-application-1">Basic Application</a></h3>
<pre><code class="language-python"># src/app.py
import jacs
import json
import os

def main():
    # Load configuration
    with open('jacs.config.json', 'r') as f:
        config = json.load(f)
    
    # Create agent
    agent = jacs.Agent(config)
    
    # Initialize if needed
    if not config.get("jacs_agent_id_and_version"):
        agent.generate_keys()
        agent_doc = agent.create_agent({
            "name": "My Python JACS Agent",
            "description": "Example Python JACS agent"
        })
        
        # Update config with agent ID
        config["jacs_agent_id_and_version"] = f"{agent_doc['jacsId']}:{agent_doc['jacsVersion']}"
        
        with open('jacs.config.json', 'w') as f:
            json.dump(config, f, indent=2)
    
    print('JACS agent ready!')
    return agent

if __name__ == "__main__":
    agent = main()
</code></pre>
<h2 id="virtual-environment-setup"><a class="header" href="#virtual-environment-setup">Virtual Environment Setup</a></h2>
<h3 id="using-venv"><a class="header" href="#using-venv">Using venv</a></h3>
<pre><code class="language-bash"># Create virtual environment
python -m venv jacs-env

# Activate (Linux/macOS)
source jacs-env/bin/activate

# Activate (Windows)
jacs-env\Scripts\activate

# Install JACS
pip install jacs
</code></pre>
<h3 id="using-conda-1"><a class="header" href="#using-conda-1">Using conda</a></h3>
<pre><code class="language-bash"># Create conda environment
conda create -n jacs-env python=3.11

# Activate environment
conda activate jacs-env

# Install JACS
pip install jacs
</code></pre>
<h3 id="using-poetry-1"><a class="header" href="#using-poetry-1">Using poetry</a></h3>
<pre><code class="language-bash"># Initialize poetry project
poetry init

# Add JACS dependency
poetry add jacs

# Install dependencies
poetry install

# Activate shell
poetry shell
</code></pre>
<h2 id="jupyter-notebook-setup"><a class="header" href="#jupyter-notebook-setup">Jupyter Notebook Setup</a></h2>
<pre><code class="language-bash"># Install Jupyter in your JACS environment
pip install jupyter

# Start Jupyter
jupyter notebook
</code></pre>
<pre><code class="language-python"># In your notebook
import jacs
import json
import os

# Setup configuration
config = {
    "jacs_data_directory": "./notebook_data",
    "jacs_key_directory": "./notebook_keys", 
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519"
}

# Ensure directories exist
os.makedirs(config["jacs_data_directory"], exist_ok=True)
os.makedirs(config["jacs_key_directory"], exist_ok=True)

# Create agent
agent = jacs.Agent(config)

print("JACS ready for notebook use!")
</code></pre>
<h2 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h2>
<h3 id="module-not-found-1"><a class="header" href="#module-not-found-1">Module Not Found</a></h3>
<p>If you get <code>ModuleNotFoundError: No module named 'jacs'</code>:</p>
<pre><code class="language-bash"># Check Python version
python --version  # Should be 3.10+

# Check if jacs is installed
pip list | grep jacs

# Reinstall if needed
pip uninstall jacs
pip install jacs
</code></pre>
<h3 id="permission-errors-1"><a class="header" href="#permission-errors-1">Permission Errors</a></h3>
<p>If you get permission errors accessing files:</p>
<pre><code class="language-bash"># Check directory permissions
ls -la jacs_data/ jacs_keys/

# Fix permissions
chmod 755 jacs_data/ jacs_keys/
chmod 600 jacs_keys/*.pem
</code></pre>
<h3 id="binary-compatibility-1"><a class="header" href="#binary-compatibility-1">Binary Compatibility</a></h3>
<p>If you get binary compatibility errors:</p>
<pre><code class="language-bash"># Update pip and reinstall
pip install --upgrade pip
pip uninstall jacs
pip install jacs --no-cache-dir
</code></pre>
<h3 id="windows-issues"><a class="header" href="#windows-issues">Windows Issues</a></h3>
<p>On Windows, you may need Visual C++ Build Tools:</p>
<pre><code class="language-bash"># Install Visual C++ Build Tools
# Or use conda-forge
conda install -c conda-forge jacs
</code></pre>
<h2 id="type-hints-and-ide-support"><a class="header" href="#type-hints-and-ide-support">Type Hints and IDE Support</a></h2>
<p>JACS includes type hints for better IDE support:</p>
<pre><code class="language-python">from typing import Dict, List, Any
import jacs

# Type hints work with modern IDEs
config: Dict[str, Any] = {
    "jacs_data_directory": "./data",
    "jacs_key_directory": "./keys",
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519"
}

agent: jacs.Agent = jacs.Agent(config)
agent_doc: Dict[str, Any] = agent.create_agent({
    "name": "Typed Agent",
    "description": "Agent with type hints"
})
</code></pre>
<h2 id="testing-setup"><a class="header" href="#testing-setup">Testing Setup</a></h2>
<pre><code class="language-python"># tests/test_jacs.py
import unittest
import tempfile
import os
import jacs

class TestJACS(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.config = {
            "jacs_data_directory": os.path.join(self.temp_dir, "data"),
            "jacs_key_directory": os.path.join(self.temp_dir, "keys"),
            "jacs_default_storage": "fs",
            "jacs_agent_key_algorithm": "Ed25519"
        }
        
        # Create directories
        os.makedirs(self.config["jacs_data_directory"])
        os.makedirs(self.config["jacs_key_directory"])
        
        self.agent = jacs.Agent(self.config)
    
    def test_agent_creation(self):
        self.agent.generate_keys()
        agent_doc = self.agent.create_agent({
            "name": "Test Agent",
            "description": "Agent for testing"
        })
        
        self.assertIn("jacsId", agent_doc)
        self.assertIn("jacsVersion", agent_doc)
        self.assertIn("name", agent_doc)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)

if __name__ == "__main__":
    unittest.main()
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that you have JACS installed:</p>
<ol>
<li><strong><a href="python/basic-usage.html">Basic Usage</a></strong> - Learn core JACS operations</li>
<li><strong><a href="python/mcp.html">MCP Integration</a></strong> - Add Model Context Protocol support</li>
<li><strong><a href="python/fastmcp.html">FastMCP Integration</a></strong> - Build advanced MCP servers</li>
<li><strong><a href="python/api.html">API Reference</a></strong> - Complete API documentation</li>
</ol>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>Check out the complete examples in the <a href="python/../examples/python.html">examples directory</a>:</p>
<ul>
<li>Basic agent creation and task management</li>
<li>Jupyter notebook workflows</li>
<li>FastMCP server implementation</li>
<li>AI/ML pipeline integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h1>
<p>This guide covers the fundamental operations you can perform with JACS in Python, from creating agents to managing tasks and documents.</p>
<h2 id="quick-start-example"><a class="header" href="#quick-start-example">Quick Start Example</a></h2>
<p>Here's a complete example that demonstrates the core JACS workflow:</p>
<pre><code class="language-python">import jacs
import json
import os

# Configuration
config = {
    "jacs_data_directory": "./jacs_data",
    "jacs_key_directory": "./jacs_keys",
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519"
}

# Ensure directories exist
os.makedirs(config["jacs_data_directory"], exist_ok=True)
os.makedirs(config["jacs_key_directory"], exist_ok=True)

# Create agent
agent = jacs.Agent(config)

# Generate keys and create agent document
agent.generate_keys()
agent_doc = agent.create_agent({
    "name": "My Python Agent",
    "description": "A JACS agent for Python workflows",
    "type": "automation"
})

print(f"Created agent: {agent_doc['name']}")
print(f"Agent ID: {agent_doc['jacsId']}")

# Create a task
task_doc = agent.create_task({
    "title": "Process Data",
    "description": "Analyze customer data and generate report",
    "priority": "high",
    "status": "pending"
})

print(f"Created task: {task_doc['title']}")
print(f"Task ID: {task_doc['jacsId']}")

# Update task status
updated_task = agent.update_task(task_doc['jacsId'], {
    "status": "in_progress",
    "progress": 25
})

print(f"Updated task status: {updated_task['status']}")
</code></pre>
<h2 id="agent-management-1"><a class="header" href="#agent-management-1">Agent Management</a></h2>
<h3 id="creating-an-agent-1"><a class="header" href="#creating-an-agent-1">Creating an Agent</a></h3>
<pre><code class="language-python">import jacs

# Basic agent creation
config = {
    "jacs_data_directory": "./jacs_data",
    "jacs_key_directory": "./jacs_keys",
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519"
}

agent = jacs.Agent(config)

# Generate cryptographic keys
agent.generate_keys()

# Create agent document
agent_doc = agent.create_agent({
    "name": "Data Processor",
    "description": "Agent specialized in data processing tasks",
    "type": "data_processor",
    "capabilities": ["data_analysis", "report_generation"],
    "version": "1.0.0"
})

print(f"Agent created with ID: {agent_doc['jacsId']}")
</code></pre>
<h3 id="loading-an-existing-agent"><a class="header" href="#loading-an-existing-agent">Loading an Existing Agent</a></h3>
<pre><code class="language-python"># If you have an existing agent, specify it in config
config = {
    "jacs_data_directory": "./jacs_data",
    "jacs_key_directory": "./jacs_keys",
    "jacs_default_storage": "fs",
    "jacs_agent_key_algorithm": "Ed25519",
    "jacs_agent_id_and_version": "agent_123:1"  # Load existing agent
}

agent = jacs.Agent(config)

# Agent is now loaded and ready to use
print("Existing agent loaded successfully")
</code></pre>
<h3 id="agent-information"><a class="header" href="#agent-information">Agent Information</a></h3>
<pre><code class="language-python"># Get agent information
agent_info = agent.get_agent_info()
print(f"Agent Name: {agent_info['name']}")
print(f"Agent Type: {agent_info['type']}")
print(f"Capabilities: {agent_info.get('capabilities', [])}")
</code></pre>
<h2 id="task-management-1"><a class="header" href="#task-management-1">Task Management</a></h2>
<h3 id="creating-tasks"><a class="header" href="#creating-tasks">Creating Tasks</a></h3>
<pre><code class="language-python"># Simple task
task = agent.create_task({
    "title": "Data Analysis",
    "description": "Analyze sales data for Q4",
    "status": "pending"
})

# Detailed task with metadata
detailed_task = agent.create_task({
    "title": "Generate Monthly Report",
    "description": "Create comprehensive monthly performance report",
    "priority": "high",
    "status": "pending",
    "assignee": "data_team",
    "due_date": "2024-02-01",
    "tags": ["reporting", "monthly", "performance"],
    "metadata": {
        "department": "analytics",
        "report_type": "performance",
        "data_sources": ["sales", "marketing", "support"]
    }
})

print(f"Created task: {detailed_task['jacsId']}")
</code></pre>
<h3 id="updating-tasks"><a class="header" href="#updating-tasks">Updating Tasks</a></h3>
<pre><code class="language-python"># Update task status
updated_task = agent.update_task(task['jacsId'], {
    "status": "in_progress",
    "progress": 50,
    "notes": "Data collection completed, starting analysis"
})

# Add results to completed task
completed_task = agent.update_task(task['jacsId'], {
    "status": "completed",
    "progress": 100,
    "results": {
        "total_sales": 1250000,
        "growth_rate": 15.3,
        "top_products": ["Product A", "Product B", "Product C"]
    },
    "completion_date": "2024-01-15"
})
</code></pre>
<h3 id="querying-tasks"><a class="header" href="#querying-tasks">Querying Tasks</a></h3>
<pre><code class="language-python"># Get all tasks
all_tasks = agent.list_tasks()
print(f"Total tasks: {len(all_tasks)}")

# Filter tasks by status
pending_tasks = [task for task in all_tasks if task.get('status') == 'pending']
print(f"Pending tasks: {len(pending_tasks)}")

# Get specific task
task_details = agent.get_task(task['jacsId'])
print(f"Task: {task_details['title']}")
</code></pre>
<h2 id="document-management"><a class="header" href="#document-management">Document Management</a></h2>
<h3 id="creating-documents"><a class="header" href="#creating-documents">Creating Documents</a></h3>
<pre><code class="language-python"># Create a generic document
document = agent.create_document({
    "type": "report",
    "title": "Q4 Sales Analysis",
    "content": {
        "summary": "Sales increased by 15% in Q4",
        "details": {
            "total_revenue": 1250000,
            "units_sold": 5000,
            "average_order_value": 250
        }
    },
    "author": "analytics_team",
    "created_date": "2024-01-15"
})

print(f"Document created: {document['jacsId']}")
</code></pre>
<h3 id="document-versioning"><a class="header" href="#document-versioning">Document Versioning</a></h3>
<pre><code class="language-python"># Update document (creates new version)
updated_document = agent.update_document(document['jacsId'], {
    "content": {
        "summary": "Sales increased by 15.3% in Q4 (revised)",
        "details": {
            "total_revenue": 1253000,  # Corrected figure
            "units_sold": 5012,
            "average_order_value": 250.1
        }
    },
    "revision_notes": "Corrected revenue figures"
})

print(f"Document updated to version: {updated_document['jacsVersion']}")
</code></pre>
<h3 id="document-verification"><a class="header" href="#document-verification">Document Verification</a></h3>
<pre><code class="language-python"># Verify document signature
is_valid = agent.verify_document(document['jacsId'])
print(f"Document signature valid: {is_valid}")

# Get document history
history = agent.get_document_history(document['jacsId'])
print(f"Document has {len(history)} versions")
</code></pre>
<h2 id="agreement-management-1"><a class="header" href="#agreement-management-1">Agreement Management</a></h2>
<h3 id="creating-agreements"><a class="header" href="#creating-agreements">Creating Agreements</a></h3>
<pre><code class="language-python"># Create a multi-party agreement
agreement = agent.create_agreement({
    "title": "Data Sharing Agreement",
    "description": "Agreement for sharing customer data between departments",
    "parties": ["analytics_team", "marketing_team", "legal_team"],
    "terms": {
        "data_types": ["customer_demographics", "purchase_history"],
        "usage_restrictions": ["no_external_sharing", "anonymization_required"],
        "duration": "12_months"
    },
    "status": "draft"
})

print(f"Agreement created: {agreement['jacsId']}")
</code></pre>
<h3 id="agreement-workflow"><a class="header" href="#agreement-workflow">Agreement Workflow</a></h3>
<pre><code class="language-python"># Submit agreement for approval
submitted_agreement = agent.update_agreement(agreement['jacsId'], {
    "status": "pending_approval",
    "submitted_by": "analytics_team",
    "submitted_date": "2024-01-15"
})

# Approve agreement (would be done by each party)
approved_agreement = agent.approve_agreement(agreement['jacsId'], {
    "approver": "legal_team",
    "approval_date": "2024-01-16",
    "notes": "Approved with standard terms"
})

# Finalize agreement
final_agreement = agent.finalize_agreement(agreement['jacsId'])
print(f"Agreement status: {final_agreement['status']}")
</code></pre>
<h2 id="working-with-json-schemas"><a class="header" href="#working-with-json-schemas">Working with JSON Schemas</a></h2>
<h3 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h3>
<pre><code class="language-python"># Define a custom schema for your documents
task_schema = {
    "type": "object",
    "properties": {
        "title": {"type": "string", "minLength": 1},
        "description": {"type": "string"},
        "priority": {"type": "string", "enum": ["low", "medium", "high"]},
        "status": {"type": "string", "enum": ["pending", "in_progress", "completed"]},
        "assignee": {"type": "string"},
        "due_date": {"type": "string", "format": "date"}
    },
    "required": ["title", "description", "status"]
}

# Create task with schema validation
try:
    validated_task = agent.create_task({
        "title": "Validated Task",
        "description": "This task follows the schema",
        "priority": "high",
        "status": "pending",
        "assignee": "john_doe",
        "due_date": "2024-02-01"
    }, schema=task_schema)
    print("Task created and validated successfully")
except Exception as e:
    print(f"Schema validation failed: {e}")
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h3>
<pre><code class="language-python">import jacs

try:
    agent = jacs.Agent(config)
    
    # Attempt to create agent
    agent.generate_keys()
    agent_doc = agent.create_agent({
        "name": "Test Agent",
        "description": "Testing error handling"
    })
    
except jacs.ConfigurationError as e:
    print(f"Configuration error: {e}")
    # Handle configuration issues
    
except jacs.CryptographicError as e:
    print(f"Cryptographic error: {e}")
    # Handle key generation or signing issues
    
except jacs.ValidationError as e:
    print(f"Validation error: {e}")
    # Handle schema validation failures
    
except jacs.StorageError as e:
    print(f"Storage error: {e}")
    # Handle file system or cloud storage issues
    
except Exception as e:
    print(f"Unexpected error: {e}")
    # Handle any other errors
</code></pre>
<h3 id="robust-error-handling"><a class="header" href="#robust-error-handling">Robust Error Handling</a></h3>
<pre><code class="language-python">def create_agent_safely(config):
    """Create agent with comprehensive error handling"""
    try:
        agent = jacs.Agent(config)
        
        # Check if keys exist
        if not agent.has_keys():
            print("Generating new keys...")
            agent.generate_keys()
        
        # Check if agent document exists
        if not config.get("jacs_agent_id_and_version"):
            print("Creating new agent...")
            agent_doc = agent.create_agent({
                "name": "Robust Agent",
                "description": "Agent with error handling"
            })
            return agent, agent_doc
        else:
            print("Loading existing agent...")
            return agent, None
            
    except Exception as e:
        print(f"Failed to create agent: {e}")
        return None, None

# Usage
agent, agent_doc = create_agent_safely(config)
if agent:
    print("Agent ready for use")
else:
    print("Failed to initialize agent")
</code></pre>
<h2 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h2>
<h3 id="environment-based-configuration"><a class="header" href="#environment-based-configuration">Environment-Based Configuration</a></h3>
<pre><code class="language-python">import os
import json

def load_config():
    """Load configuration from environment or file"""
    
    # Try environment variables first
    if os.getenv("JACS_DATA_DIRECTORY"):
        return {
            "jacs_data_directory": os.getenv("JACS_DATA_DIRECTORY"),
            "jacs_key_directory": os.getenv("JACS_KEY_DIRECTORY"),
            "jacs_default_storage": os.getenv("JACS_DEFAULT_STORAGE", "fs"),
            "jacs_agent_key_algorithm": os.getenv("JACS_AGENT_KEY_ALGORITHM", "Ed25519")
        }
    
    # Fall back to config file
    try:
        with open("jacs.config.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        # Default configuration
        return {
            "jacs_data_directory": "./jacs_data",
            "jacs_key_directory": "./jacs_keys",
            "jacs_default_storage": "fs",
            "jacs_agent_key_algorithm": "Ed25519"
        }

# Usage
config = load_config()
agent = jacs.Agent(config)
</code></pre>
<h3 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h3>
<pre><code class="language-python">def validate_config(config):
    """Validate JACS configuration"""
    required_fields = [
        "jacs_data_directory",
        "jacs_key_directory", 
        "jacs_default_storage",
        "jacs_agent_key_algorithm"
    ]
    
    for field in required_fields:
        if field not in config:
            raise ValueError(f"Missing required configuration field: {field}")
    
    # Validate algorithm
    valid_algorithms = ["Ed25519", "RSA", "Dilithium"]
    if config["jacs_agent_key_algorithm"] not in valid_algorithms:
        raise ValueError(f"Invalid algorithm: {config['jacs_agent_key_algorithm']}")
    
    # Validate storage
    valid_storage = ["fs", "s3", "azure"]
    if config["jacs_default_storage"] not in valid_storage:
        raise ValueError(f"Invalid storage backend: {config['jacs_default_storage']}")
    
    return True

# Usage
try:
    validate_config(config)
    agent = jacs.Agent(config)
except ValueError as e:
    print(f"Configuration error: {e}")
</code></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<pre><code class="language-python"># Create multiple tasks efficiently
tasks_data = [
    {"title": f"Task {i}", "description": f"Description {i}", "status": "pending"}
    for i in range(10)
]

created_tasks = []
for task_data in tasks_data:
    task = agent.create_task(task_data)
    created_tasks.append(task)

print(f"Created {len(created_tasks)} tasks")
</code></pre>
<h3 id="caching-agent-instance"><a class="header" href="#caching-agent-instance">Caching Agent Instance</a></h3>
<pre><code class="language-python"># Cache agent instance for reuse
class JACSManager:
    def __init__(self, config):
        self.config = config
        self._agent = None
    
    @property
    def agent(self):
        if self._agent is None:
            self._agent = jacs.Agent(self.config)
        return self._agent
    
    def create_task(self, task_data):
        return self.agent.create_task(task_data)
    
    def get_task(self, task_id):
        return self.agent.get_task(task_id)

# Usage
manager = JACSManager(config)
task = manager.create_task({"title": "Cached Task", "status": "pending"})
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Now that you understand the basics:</p>
<ol>
<li><strong><a href="python/mcp.html">MCP Integration</a></strong> - Add Model Context Protocol support</li>
<li><strong><a href="python/fastmcp.html">FastMCP Integration</a></strong> - Build advanced MCP servers</li>
<li><strong><a href="python/api.html">API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="python/../examples/python.html">Examples</a></strong> - More complex examples</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="task-pipeline"><a class="header" href="#task-pipeline">Task Pipeline</a></h3>
<pre><code class="language-python">def process_data_pipeline(agent, data_source):
    """Example data processing pipeline using JACS tasks"""
    
    # Create extraction task
    extract_task = agent.create_task({
        "title": "Extract Data",
        "description": f"Extract data from {data_source}",
        "status": "pending",
        "type": "extraction"
    })
    
    # Simulate extraction
    agent.update_task(extract_task['jacsId'], {
        "status": "completed",
        "results": {"records_extracted": 1000}
    })
    
    # Create transformation task
    transform_task = agent.create_task({
        "title": "Transform Data", 
        "description": "Clean and transform extracted data",
        "status": "pending",
        "type": "transformation",
        "depends_on": [extract_task['jacsId']]
    })
    
    # Continue pipeline...
    return [extract_task, transform_task]

# Usage
pipeline_tasks = process_data_pipeline(agent, "customer_database")
print(f"Created pipeline with {len(pipeline_tasks)} tasks")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcp-integration-1"><a class="header" href="#mcp-integration-1">MCP Integration</a></h1>
<p>JACS provides seamless integration with the Model Context Protocol (MCP), enabling cryptographically signed and verified communication between AI agents and MCP servers. This integration ensures that all tool calls, resource requests, and prompt interactions are authenticated and tamper-proof.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>JACS MCP integration provides:</p>
<ul>
<li><strong>Cryptographic Authentication</strong>: All MCP messages are signed and verified</li>
<li><strong>FastMCP Support</strong>: Native integration with FastMCP servers</li>
<li><strong>HTTP &amp; SSE Transports</strong>: Support for both HTTP and Server-Sent Events</li>
<li><strong>Transparent Security</strong>: Existing MCP code works with minimal changes</li>
</ul>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<h3 id="basic-mcp-server-with-jacs"><a class="header" href="#basic-mcp-server-with-jacs">Basic MCP Server with JACS</a></h3>
<pre><code class="language-python">import jacs
import os
from pathlib import Path
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import uvicorn

# Setup JACS configuration
current_dir = Path(__file__).parent.absolute()
jacs_config_path = current_dir / "jacs.config.json"

# Set password for private key
os.environ["JACS_PRIVATE_KEY_PASSWORD"] = "your_secure_password"

# Initialize JACS
jacs.load(str(jacs_config_path))

# Create FastMCP server with JACS authentication
mcp = JACSMCPServer(FastMCP("Authenticated Echo Server"))

@mcp.tool()
def echo_tool(text: str) -&gt; str:
    """Echo the input text with server prefix"""
    return f"SERVER SAYS: {text}"

@mcp.resource("echo://static")
def echo_resource() -&gt; str:
    return "Echo!"

@mcp.prompt("echo")
def echo_prompt(text: str) -&gt; str:
    return f"Echo prompt: {text}"

# Get the ASGI app with JACS middleware
sse_app_with_middleware = mcp.sse_app()

if __name__ == "__main__":
    print("Starting JACS-enabled MCP server...")
    uvicorn.run(sse_app_with_middleware, host="localhost", port=8000)
</code></pre>
<h3 id="basic-mcp-client-with-jacs"><a class="header" href="#basic-mcp-client-with-jacs">Basic MCP Client with JACS</a></h3>
<pre><code class="language-python">import asyncio
import os
from pathlib import Path
import jacs
from jacs.mcp import JACSMCPClient

# Setup JACS configuration
current_dir = Path(__file__).parent.absolute()
jacs_config_path = current_dir / "jacs.client.config.json"

# Set password for private key
os.environ["JACS_PRIVATE_KEY_PASSWORD"] = "your_secure_password"

# Initialize JACS
jacs.load(str(jacs_config_path))

async def main():
    server_url = "http://localhost:8000/sse"
    
    try:
        client = JACSMCPClient(server_url)
        
        async with client:
            # Call authenticated tool
            result = await client.call_tool("echo_tool", {
                "text": "Hello from authenticated client!"
            })
            print(f"Tool result: {result}")
            
            # Read authenticated resource
            resource = await client.read_resource("echo://static")
            print(f"Resource: {resource}")
            
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<h3 id="jacs-configuration-file"><a class="header" href="#jacs-configuration-file">JACS Configuration File</a></h3>
<p>Create a <code>jacs.config.json</code> file for your server and client:</p>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_agent_id_and_version": "your-agent-id:version",
  "jacs_agent_key_algorithm": "RSA-PSS",
  "jacs_agent_private_key_filename": "private.pem.enc",
  "jacs_agent_public_key_filename": "public.pem",
  "jacs_data_directory": "./jacs",
  "jacs_default_storage": "fs",
  "jacs_key_directory": "./jacs_keys",
  "jacs_private_key_password": "your_password",
  "jacs_use_security": "true"
}
</code></pre>
<h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<p>Generate cryptographic keys for your agents:</p>
<pre><code class="language-python">import jacs

# Load configuration
jacs.load("jacs.config.json")

# Generate keys (only needed once per agent)
agent = jacs.Agent()
agent.generate_keys()

# Create agent document
agent_doc = agent.create_agent({
    "name": "MCP Server Agent",
    "description": "Agent for MCP server authentication",
    "type": "mcp_server"
})

print(f"Agent ID: {agent_doc['jacsId']}")
</code></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="1-fastmcp-with-jacs-middleware"><a class="header" href="#1-fastmcp-with-jacs-middleware">1. FastMCP with JACS Middleware</a></h3>
<p>The <code>JACSMCPServer</code> wrapper automatically adds cryptographic middleware:</p>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP

# Create FastMCP server
base_server = FastMCP("My Server")

# Wrap with JACS authentication
authenticated_server = JACSMCPServer(base_server)

# All decorators work normally
@authenticated_server.tool()
def my_tool(data: str) -&gt; str:
    return f"Processed: {data}"
</code></pre>
<h3 id="2-http-mcp-with-manual-signing"><a class="header" href="#2-http-mcp-with-manual-signing">2. HTTP MCP with Manual Signing</a></h3>
<p>For HTTP-based MCP servers, you can manually sign responses:</p>
<pre><code class="language-python">from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jacs

app = FastAPI()

@app.post("/api/tool")
async def call_tool(request: Request):
    # Verify incoming request
    body = await request.body()
    verified_data = jacs.verify_request(body.decode())
    
    # Process the tool call
    result = {"message": "Tool executed", "data": verified_data}
    
    # Sign and return response
    signed_response = jacs.sign_response(result)
    return JSONResponse(content=signed_response)
</code></pre>
<h3 id="3-standard-mcp-with-stdio"><a class="header" href="#3-standard-mcp-with-stdio">3. Standard MCP with Stdio</a></h3>
<p>For stdio-based MCP servers:</p>
<pre><code class="language-python">from mcp.server.fastmcp import FastMCP
import jacs

# Initialize JACS
jacs.load("jacs.config.json")

mcp = FastMCP("Stdio Server")

@mcp.tool()
def secure_tool(input_data: str) -&gt; str:
    """A tool that processes signed input"""
    # Input is automatically verified by JACS middleware
    return f"Securely processed: {input_data}"

if __name__ == "__main__":
    # Run with stdio transport
    mcp.run()
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="custom-authentication-logic"><a class="header" href="#custom-authentication-logic">Custom Authentication Logic</a></h3>
<pre><code class="language-python">from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
import jacs

class CustomJACSServer:
    def __init__(self, base_server: FastMCP):
        self.base_server = base_server
        self.setup_middleware()
    
    def setup_middleware(self):
        # Custom verification logic
        @self.base_server.middleware("http")
        async def custom_auth(request, call_next):
            # Custom JACS verification
            if self.should_verify(request):
                body = await request.body()
                verified = jacs.verify_request(body.decode())
                # Update request with verified data
            
            response = await call_next(request)
            
            # Custom signing logic
            if self.should_sign(response):
                # Sign response
                pass
            
            return response
    
    def should_verify(self, request) -&gt; bool:
        # Custom logic for when to verify
        return True
    
    def should_sign(self, response) -&gt; bool:
        # Custom logic for when to sign
        return True
</code></pre>
<h3 id="multi-agent-authentication"><a class="header" href="#multi-agent-authentication">Multi-Agent Authentication</a></h3>
<pre><code class="language-python">import jacs
from jacs.mcp import JACSMCPServer, JACSMCPClient

# Server side - configure for multiple agents
server_config = {
    "trusted_agents": ["agent1-id", "agent2-id"],
    "require_signatures": True
}

mcp_server = JACSMCPServer(FastMCP("Multi-Agent Server"))

@mcp_server.tool()
def multi_agent_tool(data: str, agent_context: dict) -&gt; str:
    """Tool that can be called by multiple authenticated agents"""
    agent_id = agent_context.get("agent_id")
    return f"Agent {agent_id} processed: {data}"

# Client side - each agent uses its own keys
client1 = JACSMCPClient("http://server:8000/sse")
client2 = JACSMCPClient("http://server:8000/sse")
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<h3 id="common-jacs-mcp-errors"><a class="header" href="#common-jacs-mcp-errors">Common JACS MCP Errors</a></h3>
<pre><code class="language-python">import jacs
from jacs.mcp import JACSMCPClient

async def robust_mcp_client():
    try:
        client = JACSMCPClient("http://localhost:8000/sse")
        async with client:
            result = await client.call_tool("my_tool", {"data": "test"})
            return result
            
    except jacs.CryptographicError as e:
        print(f"Signature verification failed: {e}")
        # Handle invalid signatures
        
    except jacs.ConfigurationError as e:
        print(f"JACS configuration error: {e}")
        # Handle missing keys or config
        
    except ConnectionError as e:
        print(f"MCP connection failed: {e}")
        # Handle network issues
        
    except Exception as e:
        print(f"Unexpected error: {e}")
</code></pre>
<h3 id="debugging-authentication-issues"><a class="header" href="#debugging-authentication-issues">Debugging Authentication Issues</a></h3>
<pre><code class="language-python">import logging
import jacs

# Enable detailed JACS logging
logging.basicConfig(level=logging.DEBUG)
jacs_logger = logging.getLogger("jacs")
jacs_logger.setLevel(logging.DEBUG)

# Enable MCP debugging
mcp_logger = logging.getLogger("mcp")
mcp_logger.setLevel(logging.DEBUG)

# Your MCP code here...
</code></pre>
<h2 id="production-deployment"><a class="header" href="#production-deployment">Production Deployment</a></h2>
<h3 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h3>
<ol>
<li><strong>Key Management</strong>: Store private keys securely</li>
<li><strong>Environment Variables</strong>: Use environment variables for passwords</li>
<li><strong>Network Security</strong>: Use TLS for network transport</li>
<li><strong>Key Rotation</strong>: Implement key rotation policies</li>
</ol>
<pre><code class="language-python">import os
import jacs

# Production configuration
config = {
    "jacs_key_directory": os.getenv("JACS_KEY_DIR", "/secure/keys"),
    "jacs_private_key_password": os.getenv("JACS_KEY_PASSWORD"),
    "jacs_use_security": "true",
    "jacs_agent_key_algorithm": "RSA-PSS"
}

# Load with production settings
jacs.load_config(config)
</code></pre>
<h3 id="docker-deployment"><a class="header" href="#docker-deployment">Docker Deployment</a></h3>
<pre><code class="language-dockerfile">FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy application
COPY . .

# Create secure key directory
RUN mkdir -p /secure/keys &amp;&amp; chmod 700 /secure/keys

# Set environment variables
ENV JACS_KEY_DIR=/secure/keys
ENV JACS_USE_SECURITY=true

# Run MCP server
CMD ["python", "mcp_server.py"]
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="unit-testing-mcp-tools"><a class="header" href="#unit-testing-mcp-tools">Unit Testing MCP Tools</a></h3>
<pre><code class="language-python">import pytest
import jacs
from jacs.mcp import JACSMCPServer
from fastmcp import FastMCP
from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport

@pytest.fixture
def jacs_mcp_server():
    # Setup test configuration
    jacs.load("test.config.json")
    
    server = FastMCP("Test Server")
    return JACSMCPServer(server)

@pytest.fixture
def test_client(jacs_mcp_server):
    transport = FastMCPTransport(jacs_mcp_server)
    return Client(transport)

async def test_authenticated_tool(test_client):
    async with test_client:
        result = await test_client.call_tool("echo_tool", {"text": "test"})
        assert "test" in str(result)
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h3>
<ol>
<li><strong>Key Caching</strong>: JACS automatically caches keys</li>
<li><strong>Batch Operations</strong>: Group multiple tool calls when possible</li>
<li><strong>Connection Pooling</strong>: Reuse client connections</li>
<li><strong>Async Operations</strong>: Use async/await properly</li>
</ol>
<pre><code class="language-python"># Efficient client usage
async def efficient_mcp_usage():
    client = JACSMCPClient("http://server:8000/sse")
    
    # Single connection for multiple operations
    async with client:
        # Batch multiple tool calls
        tasks = [
            client.call_tool("tool1", {"data": f"item{i}"})
            for i in range(10)
        ]
        results = await asyncio.gather(*tasks)
    
    return results
</code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><strong><a href="python/fastmcp.html">FastMCP Integration</a></strong> - Advanced FastMCP patterns</li>
<li><strong><a href="python/api.html">API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="python/../examples/python.html">Examples</a></strong> - More complex examples</li>
<li><strong><a href="python/../security.html">Security Guide</a></strong> - Security best practices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schemas"><a class="header" href="#json-schemas">JSON Schemas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agent-schema"><a class="header" href="#agent-schema">Agent Schema</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-schema"><a class="header" href="#document-schema">Document Schema</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-schema"><a class="header" href="#task-schema">Task Schema</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-model"><a class="header" href="#security-model">Security Model</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-algorithms-2"><a class="header" href="#cryptographic-algorithms-2">Cryptographic Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-backends-2"><a class="header" href="#storage-backends-2">Storage Backends</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-schemas"><a class="header" href="#custom-schemas">Custom Schemas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-context-protocol-mcp"><a class="header" href="#model-context-protocol-mcp">Model Context Protocol (MCP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-servers"><a class="header" href="#web-servers">Web Servers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-examples"><a class="header" href="#cli-examples">CLI Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-examples"><a class="header" href="#nodejs-examples">Node.js Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-examples"><a class="header" href="#python-examples">Python Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-command-reference"><a class="header" href="#cli-command-reference">CLI Command Reference</a></h1>
<p>This page provides a comprehensive reference for all JACS command-line interface commands.</p>
<h2 id="global-commands"><a class="header" href="#global-commands">Global Commands</a></h2>
<h3 id="jacs-version"><a class="header" href="#jacs-version"><code>jacs version</code></a></h3>
<p>Prints version and build information for the JACS installation.</p>
<pre><code class="language-bash">jacs version
</code></pre>
<h3 id="jacs-init"><a class="header" href="#jacs-init"><code>jacs init</code></a></h3>
<p>Initialize JACS by creating both configuration and agent (with cryptographic keys). This is typically the first command run when setting up JACS.</p>
<pre><code class="language-bash">jacs init
</code></pre>
<h3 id="jacs-help"><a class="header" href="#jacs-help"><code>jacs help</code></a></h3>
<p>Print help information for JACS commands.</p>
<pre><code class="language-bash">jacs help [COMMAND]
</code></pre>
<h2 id="configuration-commands"><a class="header" href="#configuration-commands">Configuration Commands</a></h2>
<h3 id="jacs-config"><a class="header" href="#jacs-config"><code>jacs config</code></a></h3>
<p>Work with JACS configuration settings.</p>
<pre><code class="language-bash">jacs config [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for config are not detailed in the current help output.</em></p>
<h2 id="agent-commands"><a class="header" href="#agent-commands">Agent Commands</a></h2>
<h3 id="jacs-agent"><a class="header" href="#jacs-agent"><code>jacs agent</code></a></h3>
<p>Work with JACS agents - the cryptographic identities that sign and verify documents.</p>
<pre><code class="language-bash">jacs agent [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for agent management are not detailed in the current help output.</em></p>
<h2 id="task-commands"><a class="header" href="#task-commands">Task Commands</a></h2>
<h3 id="jacs-task"><a class="header" href="#jacs-task"><code>jacs task</code></a></h3>
<p>Work with JACS agent tasks - structured workflows between agents.</p>
<pre><code class="language-bash">jacs task [SUBCOMMAND]
</code></pre>
<p><em>Note: Specific subcommands for task management are not detailed in the current help output.</em></p>
<h2 id="document-commands"><a class="header" href="#document-commands">Document Commands</a></h2>
<p>The <code>jacs document</code> command provides comprehensive document management capabilities.</p>
<h3 id="jacs-document-create"><a class="header" href="#jacs-document-create"><code>jacs document create</code></a></h3>
<p>Create a new JACS document, either by embedding or parsing a document with optional file attachments.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document create [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file. If not specified, uses config <code>jacs_agent_id_and_version</code></li>
<li><code>-f &lt;filename&gt;</code> - Path to input file. Must be JSON format</li>
<li><code>-o &lt;output&gt;</code> - Output filename for the created document</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files. Files should end with <code>.json</code></li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-n, --no-save</code> - Instead of saving files, print to stdout</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file to use for validation</li>
<li><code>--attach &lt;attach&gt;</code> - Path to file or directory for file attachments</li>
<li><code>-e, --embed &lt;embed&gt;</code> - Embed documents or keep them external [possible values: true, false]</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Create document from JSON file
jacs document create -f my-document.json

# Create document with embedded attachment
jacs document create -f document.json --attach ./image.jpg --embed true

# Create document with referenced attachment
jacs document create -f document.json --attach ./data.csv --embed false

# Create from directory of JSON files
jacs document create -d ./documents/

# Create with custom schema validation
jacs document create -f document.json -s custom-schema.json

# Print to stdout instead of saving
jacs document create -f document.json --no-save
</code></pre>
<h3 id="jacs-document-update"><a class="header" href="#jacs-document-update"><code>jacs document update</code></a></h3>
<p>Create a new version of an existing document. Requires both the original JACS file and the modified JACS metadata.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document update [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to original document file</li>
<li><code>-n &lt;new-file&gt;</code> - Path to new/modified document file</li>
<li><code>-o &lt;output&gt;</code> - Output filename for updated document</li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-n, --no-save</code> - Print to stdout instead of saving</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file for validation</li>
<li><code>--attach &lt;attach&gt;</code> - Path to file or directory for additional attachments</li>
<li><code>-e, --embed &lt;embed&gt;</code> - Embed new attachments or keep them external</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Update document with new version
jacs document update -f original.json -n modified.json -o updated.json

# Update and add new attachments
jacs document update -f original.json -n modified.json --attach ./new-file.pdf --embed false
</code></pre>
<h3 id="jacs-document-verify"><a class="header" href="#jacs-document-verify"><code>jacs document verify</code></a></h3>
<p>Verify a document's hash, signatures, and schema compliance.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document verify [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to input file. Must be JSON format</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files. Files should end with <code>.json</code></li>
<li><code>-v, --verbose</code> - Enable verbose output</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file to use for validation</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Verify single document
jacs document verify -f signed-document.json

# Verify all documents in directory
jacs document verify -d ./documents/

# Verify with custom schema
jacs document verify -f document.json -s custom-schema.json
</code></pre>
<p><strong>Verification Process:</strong></p>
<ol>
<li><strong>Hash verification</strong> - Confirms document integrity</li>
<li><strong>Signature verification</strong> - Validates cryptographic signatures</li>
<li><strong>Schema validation</strong> - Ensures document structure compliance</li>
<li><strong>File integrity</strong> - Checks SHA256 checksums of attached files</li>
</ol>
<h3 id="jacs-document-extract"><a class="header" href="#jacs-document-extract"><code>jacs document extract</code></a></h3>
<p>Extract embedded file contents from documents back to the filesystem.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document extract [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>-a &lt;agent-file&gt;</code> - Path to the agent file</li>
<li><code>-f &lt;filename&gt;</code> - Path to input file containing embedded files</li>
<li><code>-d &lt;directory&gt;</code> - Path to directory of files to process</li>
<li><code>-s, --schema &lt;schema&gt;</code> - Path to JSON schema file for validation</li>
<li><code>-h, --help</code> - Print help information</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Extract embedded files from single document
jacs document extract -f document-with-embedded-files.json

# Extract from all documents in directory  
jacs document extract -d ./documents/
</code></pre>
<p><strong>Extract Process:</strong></p>
<ol>
<li>Reads embedded file contents from document</li>
<li>Decodes base64-encoded data</li>
<li>Writes files to their original paths</li>
<li>Creates backup of existing files (with timestamp)</li>
</ol>
<h3 id="agreement-commands"><a class="header" href="#agreement-commands">Agreement Commands</a></h3>
<p>JACS provides specialized commands for managing multi-agent agreements.</p>
<h4 id="jacs-document-check-agreement"><a class="header" href="#jacs-document-check-agreement"><code>jacs document check-agreement</code></a></h4>
<p>Given a document, provide a list of agents that should sign the document.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document check-agreement [OPTIONS]
</code></pre>
<h4 id="jacs-document-create-agreement"><a class="header" href="#jacs-document-create-agreement"><code>jacs document create-agreement</code></a></h4>
<p>Create an agreement structure for a document that requires multiple agent signatures.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document create-agreement [OPTIONS]
</code></pre>
<h4 id="jacs-document-sign-agreement"><a class="header" href="#jacs-document-sign-agreement"><code>jacs document sign-agreement</code></a></h4>
<p>Sign the agreement section of a document with the current agent's cryptographic signature.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">jacs document sign-agreement [OPTIONS]
</code></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="basic-document-lifecycle"><a class="header" href="#basic-document-lifecycle">Basic Document Lifecycle</a></h3>
<pre><code class="language-bash"># 1. Initialize JACS
jacs init

# 2. Create document with attachments
jacs document create -f document.json --attach ./files/ --embed true

# 3. Verify document integrity
jacs document verify -f created-document.json

# 4. Update document if needed
jacs document update -f original.json -n modified.json

# 5. Extract embedded files when needed
jacs document extract -f document.json
</code></pre>
<h3 id="working-with-attachments"><a class="header" href="#working-with-attachments">Working with Attachments</a></h3>
<pre><code class="language-bash"># Embed small files for portability
jacs document create -f doc.json --attach ./small-image.png --embed true

# Reference large files to save space
jacs document create -f doc.json --attach ./large-video.mp4 --embed false

# Attach multiple files from directory
jacs document create -f doc.json --attach ./attachments/ --embed false
</code></pre>
<h3 id="schema-validation-workflow"><a class="header" href="#schema-validation-workflow">Schema Validation Workflow</a></h3>
<pre><code class="language-bash"># Create with schema validation
jacs document create -f document.json -s schema.json

# Verify against specific schema
jacs document verify -f document.json -s schema.json
</code></pre>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<p>Most commands support these common options:</p>
<ul>
<li><code>-h, --help</code> - Show help information</li>
<li><code>-v, --verbose</code> - Enable verbose output for debugging</li>
<li><code>-a &lt;agent-file&gt;</code> - Specify custom agent file (overrides config default)</li>
</ul>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<ul>
<li><code>0</code> - Success</li>
<li><code>1</code> - General error (invalid arguments, file not found, etc.)</li>
<li><code>2</code> - Verification failure (hash mismatch, invalid signature, etc.)</li>
<li><code>3</code> - Schema validation failure</li>
</ul>
<h2 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h2>
<ul>
<li><code>JACS_CONFIG_PATH</code> - Override default configuration file location</li>
<li><code>JACS_DATA_DIR</code> - Override default data directory location</li>
<li><code>JACS_AGENT_FILE</code> - Default agent file to use (if not specified with <code>-a</code>)</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<h3 id="input-files"><a class="header" href="#input-files">Input Files</a></h3>
<ul>
<li><strong>JSON documents</strong> - Must be valid JSON format</li>
<li><strong>Schema files</strong> - JSON Schema format (draft-07 compatible)</li>
<li><strong>Agent files</strong> - JACS agent format with cryptographic keys</li>
<li><strong>Attachments</strong> - Any file type (automatically detected MIME type)</li>
</ul>
<h3 id="output-files"><a class="header" href="#output-files">Output Files</a></h3>
<ul>
<li><strong>JACS documents</strong> - JSON format with JACS metadata, signatures, and checksums</li>
<li><strong>Extracted files</strong> - Original format of embedded attachments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<h2 id="complete-example-configuration"><a class="header" href="#complete-example-configuration">Complete Example Configuration</a></h2>
<pre><code class="language-json">{
  "$schema": "https://hai.ai/schemas/jacs.config.schema.json",
  "jacs_use_security": "false",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys",
  "jacs_agent_private_key_filename": "jacs.private.pem.enc",
  "jacs_agent_public_key_filename": "jacs.public.pem",
  "jacs_agent_key_algorithm": "RSA-PSS",
  "jacs_default_storage": "fs",
  "observability": {
    "logs": {
      "enabled": true,
      "level": "info",
      "destination": {
        "type": "file",
        "path": "./logs"
      },
      "headers": {
        "Authorization": "Bearer token",
        "X-API-Key": "secret"
      }
    },
    "metrics": {
      "enabled": true,
      "destination": {
        "type": "prometheus",
        "endpoint": "http://localhost:9090/api/v1/write",
        "headers": {
          "Authorization": "Basic dXNlcjpwYXNz"
        }
      },
      "export_interval_seconds": 60,
      "headers": {
        "X-Service": "jacs"
      }
    },
    "tracing": {
      "enabled": true,
      "sampling": {
        "ratio": 0.1,
        "parent_based": true,
        "rate_limit": 100
      },
      "resource": {
        "service_name": "jacs",
        "service_version": "0.3.6",
        "environment": "production",
        "attributes": {
          "team": "platform",
          "region": "us-west-2"
        }
      }
    }
  }
}
</code></pre>
<h2 id="observability-configuration"><a class="header" href="#observability-configuration">Observability Configuration</a></h2>
<p>JACS supports comprehensive observability through configurable logging, metrics, and tracing. All observability features are optional and can be configured in the <code>jacs.config.json</code> file.</p>
<h3 id="logs-configuration"><a class="header" href="#logs-configuration">Logs Configuration</a></h3>
<p>Controls how JACS generates and outputs log messages.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether logging is enabled</td></tr>
<tr><td><code>level</code></td><td>string</td><td>Yes</td><td>Minimum log level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code></td></tr>
<tr><td><code>destination</code></td><td>object</td><td>Yes</td><td>Where logs are sent (see destinations below)</td></tr>
<tr><td><code>headers</code></td><td>object</td><td>No</td><td>Additional headers for remote destinations</td></tr>
</tbody></table>
</div>
<h4 id="log-destinations"><a class="header" href="#log-destinations">Log Destinations</a></h4>
<p><strong>File Logging</strong></p>
<pre><code class="language-json">{
  "type": "file",
  "path": "./logs"
}
</code></pre>
<p>Writes logs to rotating files in the specified directory.</p>
<p><strong>Console Logging (stderr)</strong></p>
<pre><code class="language-json">{
  "type": "stderr"
}
</code></pre>
<p>Outputs logs to standard error stream.</p>
<p><strong>OpenTelemetry Protocol (OTLP)</strong></p>
<pre><code class="language-json">{
  "type": "otlp",
  "endpoint": "http://localhost:4317",
  "headers": {
    "Authorization": "Bearer token"
  }
}
</code></pre>
<p>Sends logs to an OTLP-compatible endpoint (like Jaeger, Grafana Cloud).</p>
<p><strong>Null (disabled)</strong></p>
<pre><code class="language-json">{
  "type": "null"
}
</code></pre>
<p>Discards all log output.</p>
<h3 id="metrics-configuration"><a class="header" href="#metrics-configuration">Metrics Configuration</a></h3>
<p>Controls collection and export of application metrics.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether metrics collection is enabled</td></tr>
<tr><td><code>destination</code></td><td>object</td><td>Yes</td><td>Where metrics are exported (see destinations below)</td></tr>
<tr><td><code>export_interval_seconds</code></td><td>integer</td><td>No</td><td>How often to export metrics (default: 60)</td></tr>
<tr><td><code>headers</code></td><td>object</td><td>No</td><td>Additional headers for remote destinations</td></tr>
</tbody></table>
</div>
<h4 id="metrics-destinations"><a class="header" href="#metrics-destinations">Metrics Destinations</a></h4>
<p><strong>Prometheus Remote Write</strong></p>
<pre><code class="language-json">{
  "type": "prometheus",
  "endpoint": "http://localhost:9090/api/v1/write",
  "headers": {
    "Authorization": "Basic dXNlcjpwYXNz"
  }
}
</code></pre>
<p>Exports metrics in Prometheus format to a remote write endpoint.</p>
<p><strong>OpenTelemetry Protocol (OTLP)</strong></p>
<pre><code class="language-json">{
  "type": "otlp",
  "endpoint": "http://localhost:4317",
  "headers": {
    "Authorization": "Bearer token"
  }
}
</code></pre>
<p>Exports metrics to an OTLP-compatible endpoint.</p>
<p><strong>File Export</strong></p>
<pre><code class="language-json">{
  "type": "file",
  "path": "./metrics.txt"
}
</code></pre>
<p>Writes metrics to a local file.</p>
<p><strong>Console Output (stdout)</strong></p>
<pre><code class="language-json">{
  "type": "stdout"
}
</code></pre>
<p>Prints metrics to standard output.</p>
<h3 id="tracing-configuration"><a class="header" href="#tracing-configuration">Tracing Configuration</a></h3>
<p>Controls distributed tracing for request flows.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>boolean</td><td>Yes</td><td>Whether tracing is enabled</td></tr>
<tr><td><code>sampling</code></td><td>object</td><td>No</td><td>Sampling configuration (see below)</td></tr>
<tr><td><code>resource</code></td><td>object</td><td>No</td><td>Service identification (see below)</td></tr>
</tbody></table>
</div>
<h4 id="sampling-configuration"><a class="header" href="#sampling-configuration">Sampling Configuration</a></h4>
<p>Controls which traces are collected to manage overhead.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ratio</code></td><td>number</td><td>1.0</td><td>Fraction of traces to sample (0.0-1.0)</td></tr>
<tr><td><code>parent_based</code></td><td>boolean</td><td>true</td><td>Whether to respect parent trace sampling decisions</td></tr>
<tr><td><code>rate_limit</code></td><td>integer</td><td>none</td><td>Maximum traces per second</td></tr>
</tbody></table>
</div>
<p><strong>Examples:</strong></p>
<ul>
<li><code>"ratio": 1.0</code> - Sample all traces (100%)</li>
<li><code>"ratio": 0.1</code> - Sample 10% of traces</li>
<li><code>"ratio": 0.01</code> - Sample 1% of traces</li>
<li><code>"rate_limit": 10</code> - Maximum 10 traces per second</li>
</ul>
<h4 id="resource-configuration"><a class="header" href="#resource-configuration">Resource Configuration</a></h4>
<p>Identifies the service in distributed tracing systems.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>service_name</code></td><td>string</td><td>Yes</td><td>Name of the service</td></tr>
<tr><td><code>service_version</code></td><td>string</td><td>No</td><td>Version of the service</td></tr>
<tr><td><code>environment</code></td><td>string</td><td>No</td><td>Environment (dev, staging, prod)</td></tr>
<tr><td><code>attributes</code></td><td>object</td><td>No</td><td>Custom key-value attributes</td></tr>
</tbody></table>
</div>
<h2 id="authentication--headers"><a class="header" href="#authentication--headers">Authentication &amp; Headers</a></h2>
<p>For remote destinations (OTLP, Prometheus), you can specify authentication headers:</p>
<p><strong>Bearer Token Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "Authorization": "Bearer your-token-here"
}
</code></pre>
<p><strong>Basic Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "Authorization": "Basic dXNlcjpwYXNz"
}
</code></pre>
<p><strong>API Key Authentication:</strong></p>
<pre><code class="language-json">"headers": {
  "X-API-Key": "your-api-key",
  "X-Auth-Token": "your-auth-token"
}
</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "debug",
    "destination": { "type": "stderr" }
  },
  "metrics": {
    "enabled": true,
    "destination": { "type": "stdout" }
  }
}
</code></pre>
<h3 id="production-configuration"><a class="header" href="#production-configuration">Production Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "info",
    "destination": {
      "type": "otlp",
      "endpoint": "https://logs.example.com:4317",
      "headers": {
        "Authorization": "Bearer prod-token"
      }
    }
  },
  "metrics": {
    "enabled": true,
    "destination": {
      "type": "prometheus",
      "endpoint": "https://metrics.example.com/api/v1/write"
    },
    "export_interval_seconds": 30
  },
  "tracing": {
    "enabled": true,
    "sampling": {
      "ratio": 0.05,
      "rate_limit": 100
    },
    "resource": {
      "service_name": "jacs",
      "service_version": "0.3.6",
      "environment": "production"
    }
  }
}
</code></pre>
<h3 id="file-based-configuration"><a class="header" href="#file-based-configuration">File-based Configuration</a></h3>
<pre><code class="language-json">"observability": {
  "logs": {
    "enabled": true,
    "level": "info",
    "destination": {
      "type": "file",
      "path": "/var/log/jacs"
    }
  },
  "metrics": {
    "enabled": true,
    "destination": {
      "type": "file",
      "path": "/var/log/jacs/metrics.txt"
    },
    "export_interval_seconds": 60
  }
}
</code></pre>
<h2 id="environment-variable-integration"><a class="header" href="#environment-variable-integration">Environment Variable Integration</a></h2>
<p>The observability configuration works alongside JACS's core configuration system.</p>
<h3 id="required-environment-variable"><a class="header" href="#required-environment-variable">Required Environment Variable</a></h3>
<p>Only <strong>one</strong> environment variable is truly required:</p>
<ul>
<li><code>JACS_PRIVATE_KEY_PASSWORD</code> - Password for encrypting/decrypting private keys (required for cryptographic operations)</li>
</ul>
<h3 id="configuration-based-settings"><a class="header" href="#configuration-based-settings">Configuration-Based Settings</a></h3>
<p>All other JACS settings are <strong>configuration file fields</strong> that have sensible defaults:</p>
<ul>
<li><code>jacs_data_directory</code> - Where agent/document data is stored (default: <code>./jacs_data</code>)</li>
<li><code>jacs_key_directory</code> - Where cryptographic keys are stored (default: <code>./jacs_keys</code>)</li>
<li><code>jacs_agent_key_algorithm</code> - Cryptographic algorithm to use (default: <code>RSA-PSS</code>)</li>
<li><code>jacs_default_storage</code> - Storage backend (default: <code>fs</code>)</li>
<li><code>jacs_use_security</code> - Enable security features (default: <code>false</code>)</li>
</ul>
<p>These can be overridden by environment variables if needed, but they are primarily configured through the <code>jacs.config.json</code> file.</p>
<p>The observability configuration is completely optional - JACS will work without any observability configuration.</p>
<h2 id="storage-configuration"><a class="header" href="#storage-configuration">Storage Configuration</a></h2>
<p>The <code>jacs_default_storage</code> field determines where JACS stores agent data, documents, and keys. This is a critical configuration that affects how your data is persisted and accessed.</p>
<h3 id="available-storage-backends"><a class="header" href="#available-storage-backends">Available Storage Backends</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Backend</th><th>Value</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Filesystem</strong></td><td><code>"fs"</code></td><td>Local file system storage</td><td>Development, single-node deployments</td></tr>
<tr><td><strong>AWS S3</strong></td><td><code>"aws"</code></td><td>Amazon S3 object storage</td><td>Production, cloud deployments</td></tr>
<tr><td><strong>HAI Remote</strong></td><td><code>"hai"</code></td><td>HAI.ai remote storage service</td><td>HAI.ai platform integration</td></tr>
<tr><td><strong>Memory</strong></td><td><code>"memory"</code></td><td>In-memory storage (non-persistent)</td><td>Testing, temporary data</td></tr>
<tr><td><strong>Web Local</strong></td><td><code>"local"</code></td><td>Browser local storage (WASM only)</td><td>Web applications</td></tr>
</tbody></table>
</div>
<h3 id="backend-specific-configuration"><a class="header" href="#backend-specific-configuration">Backend-Specific Configuration</a></h3>
<h4 id="filesystem-storage-fs"><a class="header" href="#filesystem-storage-fs">Filesystem Storage (<code>"fs"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./jacs_data",
  "jacs_key_directory": "./jacs_keys"
}
</code></pre>
<p><strong>Requirements:</strong> None - works out of the box
<strong>Data location:</strong> Local directories as specified in config
<strong>Best for:</strong> Development, local testing, single-machine deployments</p>
<h4 id="aws-s3-storage-aws"><a class="header" href="#aws-s3-storage-aws">AWS S3 Storage (<code>"aws"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "aws"
}
</code></pre>
<p><strong>Required Environment Variables:</strong></p>
<ul>
<li><code>JACS_ENABLE_AWS_BUCKET_NAME</code> - S3 bucket name</li>
<li><code>AWS_ACCESS_KEY_ID</code> - AWS access key</li>
<li><code>AWS_SECRET_ACCESS_KEY</code> - AWS secret key</li>
<li><code>AWS_REGION</code> - AWS region (optional, defaults to us-east-1)</li>
</ul>
<p><strong>Best for:</strong> Production deployments, distributed systems, cloud-native applications</p>
<h4 id="hai-remote-storage-hai"><a class="header" href="#hai-remote-storage-hai">HAI Remote Storage (<code>"hai"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "hai"
}
</code></pre>
<p><strong>Required Environment Variables:</strong></p>
<ul>
<li><code>HAI_STORAGE_URL</code> - HAI.ai storage service endpoint</li>
</ul>
<p><strong>Best for:</strong> Integration with HAI.ai platform services</p>
<h4 id="memory-storage-memory"><a class="header" href="#memory-storage-memory">Memory Storage (<code>"memory"</code>)</a></h4>
<pre><code class="language-json">{
  "jacs_default_storage": "memory"
}
</code></pre>
<p><strong>Requirements:</strong> None
<strong>Data persistence:</strong> None - data is lost when application stops
<strong>Best for:</strong> Unit testing, temporary operations, development scenarios</p>
<h3 id="storage-behavior"><a class="header" href="#storage-behavior">Storage Behavior</a></h3>
<ul>
<li><strong>Agent data</strong> (agent definitions, signatures) are stored using the configured backend</li>
<li><strong>Documents</strong> are stored using the configured backend</li>
<li><strong>Cryptographic keys</strong> are stored using the configured backend</li>
<li><strong>Observability data</strong> (logs, metrics) can use separate storage via observability configuration</li>
</ul>
<h3 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h3>
<p><strong>Development Setup (Filesystem)</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "fs",
  "jacs_data_directory": "./dev_data",
  "jacs_key_directory": "./dev_keys"
}
</code></pre>
<p><strong>Production Setup (AWS S3)</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "aws"
}
</code></pre>
<p>With environment variables:</p>
<pre><code class="language-bash">export JACS_ENABLE_AWS_BUCKET_NAME="my-jacs-production-bucket"
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_REGION="us-west-2"
</code></pre>
<p><strong>HAI Platform Integration</strong></p>
<pre><code class="language-json">{
  "jacs_default_storage": "hai"
}
</code></pre>
<p>With environment variable:</p>
<pre><code class="language-bash">export HAI_STORAGE_URL="https://storage.hai.ai/v1"
</code></pre>
<h3 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h3>
<ul>
<li><strong>AWS S3</strong>: Ensure proper IAM permissions for bucket access</li>
<li><strong>HAI Remote</strong>: Secure the <code>HAI_STORAGE_URL</code> endpoint and any required authentication</li>
<li><strong>Filesystem</strong>: Ensure proper file system permissions for data and key directories</li>
<li><strong>Keys</strong>: Regardless of storage backend, always set <code>JACS_PRIVATE_KEY_PASSWORD</code> for key encryption</li>
</ul>
<h3 id="migration-between-storage-backends"><a class="header" href="#migration-between-storage-backends">Migration Between Storage Backends</a></h3>
<p>When changing storage backends, you'll need to:</p>
<ol>
<li>Export existing data from the current backend</li>
<li>Update the <code>jacs_default_storage</code> configuration</li>
<li>Set any required environment variables for the new backend</li>
<li>Import data into the new backend</li>
</ol>
<p>JACS doesn't automatically migrate data between storage backends - this must be done manually or via custom scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dns-verification-errors"><a class="header" href="#dns-verification-errors">DNS verification errors</a></h3>
<ul>
<li>
<p>"DNS TXT lookup failed for domain"</p>
<ul>
<li>The resolver could not fetch <code>_v1.agent.jacs.&lt;domain&gt;.</code> with DNSSEC. Check that DNSSEC is enabled, records are published, and DS is at registrar. Use <code>dig +dnssec</code>, <code>delv</code>, <code>kdig</code>, or <code>drill</code> to inspect.</li>
</ul>
</li>
<li>
<p>"DNS TXT lookup required (domain configured) or provide embedded fingerprint"</p>
<ul>
<li>Strict DNS mode is active because a domain is configured. Either publish the TXT or run with <code>--non-strict-dns</code> during initial propagation.</li>
</ul>
</li>
</ul>
<h1 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
